#if !defined(AFX_EDITORDOC_H__E8D75E3D_931B_4F57_8076_EF7245B2C71E__INCLUDED_)
#define AFX_EDITORDOC_H__E8D75E3D_931B_4F57_8076_EF7245B2C71E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "EditorStructures.h"
#include "ProgressDialog.h"
#include "ExportProgressDialog.h"
#include "avedit.h"
#include "AviSettings.h"

#include "LepSgml.h"          // filesdk

#include "WritingAudioDlg.h"

#include "Clipboard.h"
#include "Clipstream.h"
#include "MarkStream.h"
#include "UndoRedoManager.h"
#include "VideoView.h"
#include "..\Studio\ProgressListener.h"
#include "ManualConfiguration.h"


// do not include too many (big) header here: editorDoc.h is included in nearly any other file;
// huge recompilations for small changes would follow
class CInteractionStream;
class CMainFrameE;
class CQuestionStream;
class CWhiteboardView;
class CGraphicalObject;
enum GraphicalObjectType;
class CQuestionnaireEx;
class CMouseAction;


enum STREAM_UNIT
{
    SU_MINUTES = 0,
    SU_SECONDS,
    SU_MILLIS,
    SU_FRAMES
};

// these should be ordered by magnitude then they can be sorted or compared
enum UpdateHintId
{
    HINT_CHANGE_NOTHING,
    HINT_CHANGE_SELECTION,
    HINT_CHANGE_POSITION,
    HINT_CHANGE_PAGE,
    HINT_CHANGE_STRUCTURE
};

class CUpdateHint : public CObject
{
    DECLARE_DYNCREATE(CUpdateHint)

public:
    CUpdateHint();
    virtual ~CUpdateHint();

    UpdateHintId m_idUpdateHint;
    UINT m_nPositionMs;
};


class CEditorProject : public IUndoCapable, IProgressListener
{
    friend class CStreamCtrl; // works with the preview list for painting audio and video
    friend class CEditorDoc;
    friend class CClipCodecWnd;
    friend class CClips2Props;

public:
    CEditorProject();
    ~CEditorProject();

    // This is the associated Editor Document
    CEditorDoc *m_pDoc;

    enum 
    {
        ACTION_UNDO,
        ACTION_REDO,
        THUMB_BIG = 150,
        THUMB_MIDDLE = 120,
        THUMB_SMALL = 90,
        STREAM_UNDEFINED = 0,
        STREAM_AUDIO = 1,
        STREAM_VIDEO = 2,
        STREAM_WHITEBOARD = 3,
        STREAM_CLIPS = 4,
        STREAM_METADATA = 5
    };



public:
    // set member variables to default values
    void Init();
    // reset member variables, deletes all project information,
    // like recording documents, etc.
    void Clear();

    /**
     * Insert a group of controls ("Next" button, callout and stop mark at their timestamp) on the previous click page (acordingly to a specified algorithm).
     * Particularities of these "Next" buttons:
     *  - are always visible and active;
     *  - additional context menu to remove all demo document objects from recording;
     *  - default action: "jump to next page";
     *  - button type: image button;
     *  - position: bottom centered in the callout automatically generated by click event;
     *  - Insert rollback point for the last button -> insert all default demo document object before calling this function
     * Inserts a callout at same timestamp with "Next" button.
     * Also inserts a stop mark at same timestamp with previous controls.
     */
    void ConvertToDemoDocument();
    void InsertGraphicalObject(CGraphicalObject *pGraphicalObject, CRect &rcRange, GraphicalObjectType iGraphicalObjectType, CString csText, bool bDemoMode, int iTimestampPos, bool bLastInteraction, CLcElementInfo *pLcInfo = NULL);
    void GetGraphicalObjectDefaultSettings(COLORREF &clrText, COLORREF &clrLine, COLORREF &clrFill, LOGFONT &lf, int &iLineWidth, int &iLineStyle);
    void SetGraphicalObjectDefaultSettings(COLORREF clrText, COLORREF clrLine, COLORREF clrFill, LOGFONT lf, int iLineWidth, int iLineStyle);
    void InsertDemoDocumentObject(CRect rcCallout, GraphicalObjectType iGotType, CString csClick, int iTimestamp, bool bLastInteraction, CLcElementInfo* pLcElementInfo = NULL, CGraphicalObject* pGO = NULL);
    void InsertDemoDocumentStopmark(int iTimestamp);
    int GetObjectMinTimeSpan() {return m_iObjectMinTimeSpan;};

    // open lep-file
    bool StartOpen(LPCTSTR tszFilename);
    static UINT OpenThread(LPVOID pParam);
    bool Open(LPCTSTR tszFilename, IProgressListener *pListener=NULL);
    bool OpenLittle(LPCTSTR tszFilename);
    bool m_bOpenSuccess;
    // Specifies if current document is currently opening. 
    bool m_bOpening;
    // open lrd-file
    void Import(LPCTSTR tszFilename, bool bUpdateStructure=false);
    // close editor project
    void Close();
    // Save project settings
    void Save(LPCTSTR tszFilename, TCHAR *tszLastExportPath = NULL);

    bool SaveAs(LPCTSTR tszNewLrdPathName);
    CString &GetFilename() {return m_szFilename;}

    HRESULT SaveRecordingAsWord(LPCTSTR tszWordFilename=NULL, LPCTSTR tszDocumentTitle=NULL);

    // Initializes the AV-Edit DLL for
    // either preview or export
    //HRESULT InitAudioVideo(bool forPreview=true, LPCSTR prefix=NULL, bool onlyAudio=false, bool excludeClipAudio=false);

    // export edited data
    bool Export(LPCTSTR szFilename, bool bDoHidden, IProgressListener *pListener=NULL, 
       bool bSuppressSuccess=false, HANDLE hExportFinish=NULL);
    bool CopyExportedDocument(LPCTSTR tszFilename, LPCTSTR szExportedFilename);
    void CancelExport();
    // insert lrd in editor project
    void StartInsertLrd(LPCTSTR szFilename, int timestamp=0);
    static UINT InsertLrdThread(LPVOID pParam);
    bool InsertLrd(LPCTSTR szFilename, int timestamp);

    void ExportAudioAsWav(LPCTSTR tszRecordPath, LPCTSTR tszFileName);
    bool ImportAudio(LPCTSTR tszFileName);
    bool ImportVideo(LPCTSTR tszFileName);

    //void ExportSilent(const _TCHAR *tszTargetLrdPathName);
    //bool OpenAndExportAutomatic(_TCHAR *tszSourcePathName, bool bBlocking);
    bool ExportAutomatic(IProgressListener *pListener, bool bSuppressSuccess=false, HANDLE hExportFinish=NULL);
    bool GetLastExportSuccess() { return m_bLastExportSuccess; }

    // cut over all streams 
    void Cut(int from, int to, bool bCutFromEditor = false);
    // copy to clipboard
    void Copy(int from, int to, CArray<CPreviewSegment *, CPreviewSegment *> &clipBoard, bool bCopyFromEditor = false);
    // paste from clipBoard
    bool Paste(int to, CArray<CPreviewSegment *, CPreviewSegment *> &clipBoard, int &insertLength, bool bUseNormalClipboard = true, bool bSetUndoRollback = true);
    // delete over all stream (no copy to clipBoard)
    void Delete(int from, int to);

    // common function for undo and redo if action was cut or paste
    bool UndoRedoCutPaste(int action);
    // un- / redo if action was import audio
    bool UnRedoImportAudio(int action);
    // un-/redo if action was import video (with no audio)
    bool CEditorProject::UnRedoImportVideo(int action);
    // un-/redo if action was import video with audio
    bool CEditorProject::UnRedoImportVideoAudio(int action);
    // undo if action was insert clip
    bool UndoDeletePaste();
    // redo if action was insert clip
    bool RedoDeletePaste();
    // undi if action was move clip
    bool UnRedoMoveClip(int action);
    // undo last action (insert, cut, paste)
    bool Undo(UpdateHintId *pidMaximumChange, CArray<UINT, UINT> *paBeginTimes);
    // redo last undo
    bool Redo(UpdateHintId *pidMaximumChange, CArray<UINT, UINT> *paBeginTimes);
    // deletes all elements from undo list
    void EmptyUndoList();
    // deletes all elements from redo list
    void EmptyRedoList();
    // undo stack contains elements?
    bool IsUndoPossible();
    // redo stack contains elements?
    bool IsRedoPossible();

    virtual HRESULT UndoAction(UndoActionId idActionCode, 
        BYTE *pData, UINT nDataLength, UINT nPositionMs = 0, UINT nLengthMs = 0);
    virtual HRESULT ReleaseData(BYTE *pData, UINT nDataLength, bool bDeleteCompletely,
        UndoActionId idActionCode, UINT nPositionMs, UINT nLengthMs) { return S_OK; }

    bool WasUndoLegacy() { return m_bUndoLegacyAction; }

    HRESULT InsertNewPage(UINT nPositionMs, CString &csPageTitle, UINT nLengthMs);

    // insert Clip at timestamp
    bool InsertClip(LPCTSTR tszFilename, int timestamp, bool &bNeedUpdate);
    // find first clip in lrd file and insert at current position. sets csClipFileName
    // to the file name of the inserted clip if successful. otherwise not defined.
    bool InsertClipFromLrd(LPCTSTR tszFilename, int timestamp, CString &csClipFileName);
    // delete clip active at timestamp
    bool DeleteClip(int timestamp, bool &bNeedUpdate);
    // insert still image
    bool InsertStillImage(LPCTSTR tszStillImage);
    // remove still image
    bool RemoveStillImage();
    bool HasStillImage() {return !m_csStillImage.IsEmpty(); }
    CString& GetStillImage() { return m_csStillImage; }

    CMarkStream* GetMarkStream(bool bCreate = false);
    CClipStreamR* GetClipStream(bool bCreate = false);
    CInteractionStream* GetInteractionStream(bool bCreate = false);
    CQuestionStream* GetQuestionStream(bool bCreate = false);

    HRESULT CheckQuestion();
    HRESULT ResetQuestion();

    HRESULT StartQuestionTimers();
    /** Returns S_FALSE if there was nothing to reset. */
    HRESULT ResetQuestionsAfterPreview();

    HRESULT CalculateWhiteboardArea(CRect *prcView, CRect *prcTarget, double *pdZoomFactor, int iMenuZoom=0);
    HRESULT GetPageDimension(CSize &siPage);
    bool DrawWhiteboard(CDC *pDC, int timestamp, CRect &rcView, double dZoomFactor, bool bForce);
    // Calculate Width of Structure View
    int GetStructureWidth() {return m_nThumbWidth;}
    // Returns the height of a single thumbnail
    int GetThumbHeight();
    // Calculate Height of Structure View
    int GetStructureHeight();
    // Calculate y pos of actual page
    int GetActualStructurePos(int timestamp, int nPageHeight = -1);
    // Get time from page or clip drawn at position y
    int GetTimestamp(int y, int nHeight = -1);
    HRESULT GetStructureElements(CArray<CStructureInformation *, CStructureInformation *> *paElements);
    CStructureInformation *GetStructureInformationAtTimeStamp(int iPageBegin);
    int GetActivePage(int timestamp);
    void UpdatePageNumbers();

    // Recalculate the slides size
    void CalculateSlideSize();

    // Display Change clip title dialog
    void ChangeClipTitleAt(int nTimeMs);
    // Display Change page title dialog
    void ChangePageTitleAt(int nTimeMs);

    // find all pages appears between fromMsec an toMsec
    void GetPages(CArray<CPage *, CPage *> &pages, int fromMsec, int toMsec);

    CString& GetPageTitleForId(UINT nJumpId);

    CPage *FindPageAt(int timestamp);
    HRESULT GetPagePeriod(int timestamp, UINT &iStartMs, UINT &iEndMs);
    int GetNextPageBegin(int curMsec);
    int GetPrevPageBegin(int curMsec, bool bReallyPrevious = false);
    UINT GetTimeForPageId(UINT nPageId);
    // Get the value of the last used callout type.
    UINT GetActiveCalloutType(){return m_nActiveCalloutType;};
    // Set the value of the last used callout type.
    void SetActiveCalloutType(UINT nActiveCalloutType){m_nActiveCalloutType = nActiveCalloutType;};
    // Get the value of the last used demo object type.
    UINT GetActiveDemoObjectType(){return m_nActiveDemoObjectType;};
    // Set the value of the last used demo object type.
    void SetActiveDemoObjectType(UINT nActiveDemoObjectType){m_nActiveDemoObjectType = nActiveDemoObjectType;};

    // find clip at timestamp
   CClipInfo *FindClipAt(int timestamp);
   
    CStopJumpMark* GetMarkWithId(UINT nMarkId);
    CStopJumpMark* GetJumpMarkAt(UINT nPositionMs);
    CStopJumpMark* GetStopMarkAt(UINT nPositionMs);
    UINT GetTimeForMarkId(UINT nMarkId);

    bool IsEmpty();
    bool IsLrdUsed(CString &lrdName);

    int GetClipBoardSize() {return m_clipBoard.GetSize();}

    HRESULT ClearStreamClipboard();

    bool SetThumbWidth(int width); 

    bool HasStructure();
    bool HasMetadata();
    bool HasMarks();
    bool HasVideo();
    bool HasSgClips();
    bool HasStructuredSgClips();
    bool IsDenverDocument();

    bool ShowClickPages() {return m_bShowClickPages;}
    void SetShowClickPages(bool bShowClickPages, bool bRedraw=false);
    bool DocumentHasClickPages(){return m_bHasClickPages;};
    bool DocumentHasAnalysisPages(){return m_bHasAnalysisPages;};
    bool ShowScreenGrabbingAsRecording() {return m_bShowScreenGrabbingAsRecording;}
    void SetShowScreenGrabbingAsRecording(bool bShowSgAsRecording) {m_bShowScreenGrabbingAsRecording = bShowSgAsRecording;}

    int GetTotalLength();
    UINT GetAudioPreviewLength();

    bool InitAviSettingsFromFile(CAviSettings *pAviSettings, const _TCHAR *tszFilename, 
        CVideoStream *pVideoStream=NULL);
    CAviSettings *LookupClipAviSettings(const _TCHAR *tszClipFilename, int nTempVolume=-1);
    void InitMediaTypes();
    void ResetPreviewFormat();
    void CreatePreviewFormat();

    // Matches the video size and frame rate to the current input clips.
    // Works like CreatePreviewFormat(), but keeps the codec settings.
    void RecalcDenverVideoParams();

    DWORD GetCodePage() { return m_dwCodePage; }

    void GetUnsupportedFonts(CArray<CString, CString> &acsUnsupportedFonts);

    bool IsClipWithAudioInsertion(UINT nClickPosMs);

    // Methodes from interface IProgressListener
    virtual void SetProgress(float f);
    virtual void SetProgressLabel(CString& csLabel);
    virtual void ShowMessage(ProgressMessageType nType, CString& csMessage, CWnd *pWndParent=NULL);

    CManualConfiguration *GetManualConfiguration() {return &m_cManualConfiguration;};



    // Random questions memmbers

    // Returns the first questionnare within document. For some reason a recording can have only on questionnaire for now.
    // Retruns NULL if question stream, or questionare was not found.
    CQuestionnaireEx *GetFirstQuestionnaireEx();
    // Return true if questions are peeked randomly during play (Random Tests).
    bool FirstQuestionnaireIsRandomTest();
    // Returns the beginning timestamp of the first question. Returns -1 if some errors occur.
    int GetFirstQuestionBeginTimeStamp();
    // Returns the end timestamp of the last question. Returns -1 if some errors occur.
    int GetLastQuestionEndTimeStamp();
    // Sets "random test started" flag. This is required to avoid infinite loop during playing in case the first random question generated is exactly the first question in the document.
    bool StartRandomTest(int iNewPositionTimeStamp);
    void StartRandomTest(bool bStart);
    bool IsRandomTestStarted() {return m_bRandomTestStarted;};
    // Add a stop mark at the end of each question page. If one was deleted reinsert and register it. 
    // This is required to make sure user didn't delete one stopmark from a question page, which might generate infinite loops during play.
    void AddStopmarkAtEndOfEachQuestionPage();

    bool IsRandomTestEnabled();
    void SetRandomTestEnabled(bool bEnableRandomTest);

    // If pAction is INTERACTION_JUMP_RANDOM_QUESTION it will be set to INTERACTION_NO_ACTION
    void ClearJumpRandomQuestionAction(CMouseAction *pAction);
    // Will replace the INTERACTION_JUMP_RANDOM_QUESTION mouse action with INTERACTION_NO_ACTION for all interactions and questions within a project
    void ClearJumpRandomQuestionActions();
    // Set mouse actions to INTERACTION_JUMP_RANDOM_QUESTION
    void SetJumpRandomQuestionAction(CMouseAction *pAction);
    // Will set the INTERACTION_JUMP_RANDOM_QUESTION mouse action for all interactions and questions within a project
    void SetJumpRandomQuestionActions();

   /////////////////////////////////////////
   // PUBLIC MEMBER VARIABLES
   /////////////////////////////////////////

    // The export video format
    //AM_MEDIA_TYPE m_mtVideoFormat;
    // True if export video format has been initialized
    //bool m_isVideoFormatInitialized;
    // The export audio format
    AM_MEDIA_TYPE m_mtAudioFormat;
    // True if export audio format has been initialized
    bool m_isAudioFormatInitialized;

    // The FCC code of the export video codec
    //DWORD m_videoExportFCC;
    // The quality setting for the codec, 0 to 100 percent.
    //int   m_videoExportQuality;
    // The key frame rate; only important if m_videoExportUseKeyframes
    // is set to true
    //int   m_videoExportKeyframeRate;
    // True if keyframes should be used
    //bool  m_videoExportUseKeyframes;
    //   bool  m_videoExportUseQuality;
    //bool m_videoExportUseSmartRecompression;

    CAviSettings m_videoAviSettings;
    CMap<CString, LPCTSTR, CAviSettings *, CAviSettings *> m_clipAviSettings;
    // This variable is used if the entire video content
    // is removed from the project. The video format is
    // backed up into this variable in order to be able
    // to restore it if parts of the video are restored
    // (paste, undo, redo...).

    // This is the quick solution (with remaining problems).
    // The cleaner solution would be to separate the preview format
    // from the export format (in separate variables).

    // Apart from that it would be nice to remember the video
    // format upon Cut/Copy and Undo.
    CAviSettings m_videoBackupAviSettings;

    bool m_clipExportUseSmartRecompression;
    bool m_clipExportStretchDenverClips;
    bool m_clipExportAutoCalcDenverSize;

    // Global video offset
    int  m_videoExportGlobalOffset;

    CMetaInformation  m_targetMetainfo;
    int               m_targetPageWidth;
    int               m_targetPageHeight;
    HANDLE            m_hDialogInitEvent;
    HANDLE            m_hExportFinishEvent;

    // The stream length of the video stream, if available (in ms)
    int               m_videoStreamLength;

private:
    // Resets project variables without deleting any
    // structures; is called from Init() and Clear().
    void ResetProjectVariables();

    // Sets all variables dealing with user settings
    // to default values (e.g. video zoom factor)
    void ResetUserSettings();


    HRESULT PrepareRenderGraph(bool bForPreview, LPCTSTR tszPrefix, bool bMainAudioOnly = false);
    int FindStretchMode(CClipInfo *pClipInfo, bool bIsDenver);
    CString& FindLadString();


    void CreateDefaultProject();
    CString MakeAbsolute(LPCTSTR szLepFileName, LPCTSTR szRelPath);
    CString MakeAbsoluteAndCheck(LPCTSTR szLepFileName, LPCTSTR szRelPath);

    bool CheckVersion(CLepSgml *pLepFile, bool bShowMessage);
    bool ParseMetainfo(CLepSgml *pLepFile);
    bool ParseFiles(CLepSgml *pLepFile, LPCTSTR szLepFileName);
    bool ParseConfig(CLepSgml *pLepFile);
    void ExtractVideoExportSettings(CLepSgml *pLepFile, SgmlElement *pExportTag, CAviSettings *pAviSettings, const _TCHAR *tszLepFileName);
    bool ParseExportSettings(CLepSgml *pLepFile, const _TCHAR *tszLepFileName);
    bool ParseStreams(CLepSgml *pLepFile, LPCTSTR szLepFileName, IProgressListener *pListener);
    bool ParseAudioStream(CLepSgml *pLepFile, LPCTSTR szLepFileName, IProgressListener *pListener);
    bool ParseVideoStream(CLepSgml *pLepFile, LPCTSTR szLepFileName);
    bool ParseWbStream(CLepSgml *pLepFile, LPCTSTR szLepFileName);
    bool ParseClipStream(CLepSgml *pLepFile, LPCTSTR szLepFileName);
    bool ParseSlideStream(CLepSgml *pLepFile, LPCTSTR szLepFileName);

    int FindElementAt(int timestamp);
    void GetPreviewSegments(CArray<CPreviewSegment *, CPreviewSegment *> &arPreviewSegments, int fromMsec, int toMsec);
    void IncrementFrom(int insertIndex, int byLength);

    /**
    * Creates flat lists of pages and streams while going through all preview
    * segments. The same page or clip in adjacent segments are joined.
    */
    void UpdateStructureAndStreams();
    void VerifyLastPageEnd();
    void RemoveEmptyParts();
    void DeleteClipBoard(CArray<CPreviewSegment *, CPreviewSegment *> &clipBoard);

    // Import audio and video helper methods
    static UINT ImportAudioThreadLauncher(LPVOID lParam);
    void ImportAudioThread();
    CString m_csImportAudioFileName;
    static UINT ImportVideoThreadLauncher(LPVOID lParam);
    void ImportVideoThread();
    CString m_csImportVideoFileName;

    bool RemoveVideo();

    void GetWhiteboardElements(int iBeginTimestamp, int iEndTimestamp, CArray<DrawSdk::DrawObject *, DrawSdk::DrawObject *> &aObjects);
    void GetGraphicalObjects(int iBeginTimestamp, int iEndTimestamp, CArray<CGraphicalObject *, CGraphicalObject *> &aObjects);


    bool ExportWhiteboard(CString &recordPath, CString &prefix, IProgressListener *pListener);
    bool ExportMetadata(CString &recordPath, CString &prefix, CArray<UINT, UINT> *paClipTimes, IProgressListener *pListener);
    bool CreateThumbnailsForStructuredSgClip(CString &recordPath, CString &prefix);
    bool ExportLrd(CString &recordPath, CString &prefix, IProgressListener *pListener);
    bool ExportAudio(CString &recordPath, CString &prefix, IProgressListener *pListener, HWND hWndNotify=NULL);
    //void ExportVideo(CString &recordPath, CString &prefix);
    bool ExportClips(CString &recordPath, CString &prefix, IProgressListener *pListener);
    bool WriteWavFromFile(const _TCHAR *tszFileName, int nStreamId, CString &csTargetFileName, bool bTryGivenFileName=false);
    bool CheckAndRestoreAudioFile(CString &csAudioFile, int &nAudioStream, const _TCHAR *tszOrigAudio, int nOrigStream);

    static UINT RenameThreadLauncher(LPVOID pParam);
    void RenameThread(CString csSourceDir, CString csTargetDir, HANDLE hExportFinish);

    // Audio export
    static UINT ExportAudioAsWavThreadLauncher(LPVOID lParam);
    void ExportAudioAsWavThread();
    CString m_exportAudioAsWavFileName;
    CString m_exportAudioAsWavPath;

    void SaveProject(CString &recordPath, CString &prefix, TCHAR *tszLastExportPath = NULL);

    void WriteVideoExportType(CFileOutput *pOutput, CAviSettings *pAviSettings);
    void WriteMetaInformation(CFileOutput *pOutput);
    void WriteFileInformation(CFileOutput *pOutput, CString &recordPath, CString &prefix);
    void WriteConfiguration(CFileOutput *pOutput);
    void WriteAudioStreamEntry(CFileOutput *pOutput, CString &recordPath, CString &prefix);
    void WriteVideoStreamEntry(CFileOutput *pOutput, CString &recordPath, CString &prefix);
    void WriteWhiteboardStreamEntry(CFileOutput *pOutput, CString &recordPath, CString &prefix);
    void WriteSgStreamEntry(CFileOutput *pOutput, CString &recordPath, CString &prefix);
    void WriteSlideStream(CFileOutput *pOutput, CString &recordPath, CString &prefix);

private:
    // find preview segment begins at targetBegin
    CPreviewSegment *FindPreviewSegmentBeginsAt(int targetBegin);
    // find preview segment which include timestamp
    CPreviewSegment *FindPreviewSegment(int timestamp);
    // find preview segment with Stream which include timestamp
    CPreviewSegment *FindSegmentWithStream(int timestamp, int streamId);
    // find stream with id
    CStreamContainer *FindStreamContainer(int containerID);
    CAudioStream *FindAudioStream(int audioStreamID);
    CVideoStream *FindVideoStream(int videoStreamID);
    CClipStream *FindClipStream(int clipStreamID);
    CWhiteboardStream *FindWhiteboardStream(int whiteboardStreamID);
    CPageStream *FindPageStream(int pageStreamID);
    CMetadataStream *FindMetadata(int metadataID);

    bool InitAudioStream(CAudioStream *pAudioStream, LPCTSTR tszFileName, 
                        int nStreamSelector, UINT nErrorID, CWnd *hWnd, 
                        HWND hWndProgress=NULL, IProgressListener *pListener=NULL);
    // if all streams are empty (excepted the clip stream, audio stream is dummy stream) return true
    bool StreamsAreEmpty(int nFromMs, int nToMs);
    static UINT ExportThreadLauncher(LPVOID pData);
    void ExportThread(IProgressListener *pListener);

    static UINT CopyThreadLauncher(LPVOID pData);
    void CopyThread(IProgressListener *pListener);

    static UINT WriteWavFromFileThreadLauncher(LPVOID pData);
    void WriteWavFromFileThread();

    HRESULT UpdateQuestionnaireFeedback();

    CWritingAudioDlg *m_pWritingAudioDlg;
    const _TCHAR     *m_tszWriteWavFromFileFileName;
    int               m_nWriteWavFromFileStreamId;
    bool              m_bWriteWavFromFileTryGivenFileName;
    CString           m_csWriteWavFromFileTargetFileName;
    bool              m_bWriteWavFromFileReturnValue;

    // Pops up a MessageBox with the given error message.
    // The string has to contain a %08x and a %s (in that
    // succession).
    void HandleError(UINT msgId, HRESULT hr);

    // This method creates a media type which is useful for
    // exporting denver type AVI files. It creates a media type
    // which has the largest width and height which occurs
    // in the fileNames list of AVI files. The frame rate
    // is the lowest frame rate which occurs in the list.
    //HRESULT MakeDenverMediaType(CArray<CString, CString> &fileNames, AM_MEDIA_TYPE &mtOut);

    ///////////////////////////////
    // PRIVATE MEMBER VARIABLES
    ///////////////////////////////
    AM_MEDIA_TYPE            m_cachedDenverModeMediaType;
    CArray<CString, CString> m_cachedDenverModeFileNames;

    CString m_csStillImage;

    // This variable contains the file name for the LRD
    // export, right before ExportThread() is called.
    // This variable is for temporary use only!
    CString m_exportFileName;
    // This variable contains the file name for the LRD
    // created by the last export, right before CopyThread() is called.
    // This variable is for temporary use only!
    CString m_csLastExportFileName;

    CString m_szFilename;
    CArray<CPreviewSegment *, CPreviewSegment *>  m_previewList;

    CList<CLrdFile *, CLrdFile *>                 m_recordingList;
    CList<CStreamContainer *, CStreamContainer *> m_streamList;

    CArray<CPreviewSegment *, CPreviewSegment *>  m_clipBoard;
    CList<CUnRedoElement *, CUnRedoElement *>     m_undoList;
    CList<CUnRedoElement *, CUnRedoElement *>     m_redoList;

    CStructureInformation            *m_pTargetStructureWithClickPages;
    CStructureInformation            m_targetStructure;
    CArray<CClipInfo *, CClipInfo *> m_clipStream;

    /** TODO not correct anymore:
    * m_pageStream contains all page objects belonging to any preview
    * segment in this project. This means especially that it may
    * contain the same page (id) several times. 
    * During display and navigation (slide change) special care must
    * be taken if the same page is listed multiple times directly after 
    * each other.
    * In this case these pages form "one" page.
    */
    CArray<CPage *, CPage *> m_aPageStream;

    int                    m_actualPreviewSegment;

    // This is the object used for Audio and Video
    // editing
    AVEdit                 m_avEdit;
    bool                   m_bCancelExportRequested;
    bool                   m_bLastExportSuccess;

    bool                   m_bFunctionSucceeded;

    CProgressDialogE      *m_pProgress;
    CExportProgressDialog *m_pExportProgressDialog;

    int                    m_nVersionType;

    // Tuning of whiteboard display:

    // This variable contains the whiteboard stream which
    // was used for drawing the whiteboard the last time
    CWhiteboardStream     *m_pLastDrawnWhiteboard;

    int m_nThumbWidth;

    // Codepage support
    DWORD m_dwCodePage;


    CClipboard m_ClipboardNew;
    CUndoRedoManager m_UndoManager;

    bool m_bUndoLegacyAction;

    CArray<CBaseStream*, CBaseStream*> m_aStreams;
    CMarkStream *m_pMarkStream;
    CClipStreamR *m_pClipStream;
    CInteractionStream* m_pInteractionStream;
    CQuestionStream* m_pQuestionStream;

    int m_iLastPasteTo;
    int m_iLastPasteLength;

    bool m_bSuppressSuccess;

    CArray<CString, CString> m_acsUnsupportedFonts;

    bool m_bHasClickPages;
    bool m_bHasAnalysisPages;
    bool m_bShowClickPages;
    bool m_bShowScreenGrabbingAsRecording;

    /** 
    * Callouts can be drawn in 8 modes. This setting holds the value of the last used callout type.
    * It is not saved when application exit.
    * One of these values:
    *     ID_CALLOUT_TOP_LEFT, ID_CALLOUT_TOP_RIGHT, ID_CALLOUT_BOTTOM_LEFT, ID_CALLOUT_BOTTOM_RIGHT, ID_CALLOUT_LEFT_BOTTOM
    *     ID_CALLOUT_LEFT_TOP, ID_CALLOUT_RIGHT_BOTTOM, ID_CALLOUT_RIGHT_TOP
    */
    UINT m_nActiveCalloutType;
    UINT m_nActiveDemoObjectType;

    int m_iObjectMinTimeSpan; // min 10 ms

    CManualConfiguration m_cManualConfiguration;

    //Flag created to avoid infinite loop during random questionnaire playing in case the first random question generated is exactly the first question in the document.
    bool m_bRandomTestStarted;
    bool m_bIsRandomTestEnable;
};



class CEditorDoc : public CDocument
{
public:
    static int ShowInfoMessage(CString &csMessage, HWND hWndParent = NULL, UINT nButtonType = MB_OK);
    static int ShowWarningMessage(CString &csMessage, HWND hWndParent = NULL, UINT nButtonType = MB_OK);
    static int ShowErrorMessage(CString &csMessage, HWND hWndParent = NULL, UINT nButtonType = MB_OK);
    static CEditorDoc *GetCurrentInstance();

    static CString GetCorrespondingLep(CString& csLrdPath, HWND hwndParent=NULL);

protected: // Nur aus Serialisierung erzeugen
    CEditorDoc();
    DECLARE_DYNCREATE(CEditorDoc)

// Attribute
public:
    int m_docLengthMs;
    int m_curPosMs;
    int m_displayStartMs;
    int m_displayEndMs;
    int m_markStartMs;
    int m_markEndMs;

    STREAM_UNIT m_streamUnit;

    CEditorProject project;

// Operationen
public:

// Überladungen
    // Vom Klassenassistenten generierte Überladungen virtueller Funktionen
    //{{AFX_VIRTUAL(CEditorDoc)
    public:
    virtual BOOL OnNewDocument();
    virtual void Serialize(CArchive& ar);
    virtual void OnCloseDocument();
    virtual BOOL OnSaveDocument(LPCTSTR lpszPathName );
    afx_msg void OnFileSaveAs();
    virtual void DeleteContents();
    virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
    virtual void SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU = TRUE);
    // Overridden and changed from CDocument.
    // This has been changed in order to be able to
    // manipulate the default/initial save directory
    virtual BOOL DoSave(LPCTSTR lpszPathName, BOOL bReplace);
    //}}AFX_VIRTUAL

// Implementierung
public:
    virtual ~CEditorDoc();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

public:
    virtual void SetModifiedFlag(BOOL bFlag=TRUE);
    virtual void SetPreviewRebuildNeeded(BOOL bFlag=TRUE);
    virtual BOOL IsPreviewRebuildNeeded() { return m_bIsPreviewRebuildNeeded; }

    // Screengrabbing document with or without structure
    bool IsScreenGrabbingDocument() {return project.IsDenverDocument() || project.HasStructuredSgClips();}
    // Is screen grabbing document and demo document objects ("next" buttons and target marks at the end of each page) have been inserted.
    bool IsDemoDocument();
    // 
    bool IsDemoModeRequired();
    void UpdateScreenMode();

    CMainFrameE *GetMainFrame();
    CView *GetMainView();
    CWhiteboardView *GetWhiteboardView();
    CVideoView *GetVideoView();

    void UpdateDocument();
    void SetDirtyDuringOpen(bool bDirty) { m_bDirtyDuringOpen = bDirty; }

    void SetUserIsScrolling(bool bScrolling) { m_bUserIsScrolling = bScrolling; }
    bool IsUserScrolling() { return m_bUserIsScrolling; }

    bool InsertLrd(LPCTSTR tszFilename);
    bool Open(LPCTSTR tszFilename);
    void Import(LPCTSTR tszFilename);

    bool BuildPreview(HWND hWndContainer=NULL);
    void StartPreview(HWND hWndContainer=NULL, bool bDoSelection = false);
    void StartPreviewSelection(HWND hWndContainer=NULL);
    void PausePreview();
    /**
    * Invoke if you want to stop replay but still stay in preview mode.
    * Eg for the mouse action "stop" or for a stop mark being reached.
    */
    void PausePreviewSpecial();
    //void CalculateCursorPos();
    void StopPreview();
    void JumpPreview(int millis);
    void RebuildPreview(bool bProhibitJump = false);
    bool IsPreviewActive() { return m_bPreviewActive || m_bPausedSpecial; }
    bool IsPausedSpecial() { return m_bPausedSpecial; }
    HRESULT GetPreviewVideoSize(SIZE *pSize);
    HRESULT ResizePreviewVideoWindow(RECT *pRect);

    UINT GetCurrentPreviewPos() { return m_curPosMs; }
    UINT GetBackendPreviewPos();
    bool InformCurrentReplayTime(int iRelayMs);
		
    BOOL SwitchToView(CRuntimeClass* pNewViewClass);

    void Copy();
    void Cut();
    void Paste();
    void Delete();
    void Undo();
    void Redo();

    void ImportAudio(LPCTSTR tszFileName);
    void ImportVideo(LPCTSTR tszFileName);

    void RemoveVideo();

    HRESULT InsertNewPage(UINT nPositionMs, CString &csPageTitle, UINT nLengthMs);

    void InsertClip(LPCTSTR tszFilename);
    void InsertClipFromLrd(LPCTSTR tszFilename);
    void DeleteCurrentClip();
    void DeleteClipAt(int iPositionMs);
    void NotifyCommitMoveClip();

    void InsertStillImage(LPCTSTR tszStillImage);
    void RemoveStillImage();
    void MarkPageAt(int nTimeMs);
    void MarkClipAt(int nTimeMs);

    bool IsClipActive();

    void InitMediaTypes();

    bool ShowAsScreenSimulation();

    HRESULT OpenAsScreenRecording();
    HRESULT OpenAsScreenSimulation();
protected:

    void ShowPageView();
    virtual BOOL SaveModified();

    // Generierte Message-Map-Funktionen
protected:
    //{{AFX_MSG(CEditorDoc)
	    // HINWEIS - An dieser Stelle werden Member-Funktionen vom Klassen-Assistenten eingefügt und entfernt.
	    //    Innerhalb dieser generierten Quelltextabschnitte NICHTS VERÄNDERN!
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    BOOL m_bIsPreviewRebuildNeeded;
    bool m_bDirtyDuringOpen;
    CMainFrameE *m_pMainFrame;

    // Variables to initialize GDI+   
    Gdiplus::GdiplusStartupInput gdiplusStartupInput;
    ULONG_PTR gdiplusToken;

private:
    bool AdaptDisplayRange();

    void UndoRedo(bool bDoUndo);

    void AsyncTriggerDocUpdate();

    bool m_bPreviewActive;
    bool m_bPausedSpecial;
    bool m_bJumpActive;
    bool m_bUserIsScrolling;
    static CEditorDoc *s_pEditorDoc;
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ fügt unmittelbar vor der vorhergehenden Zeile zusätzliche Deklarationen ein.

#endif // !defined(AFX_EDITORDOC_H__E8D75E3D_931B_4F57_8076_EF7245B2C71E__INCLUDED_)
