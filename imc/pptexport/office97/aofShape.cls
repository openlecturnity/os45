VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "aofShape"
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False

Option Explicit
 
Public SlideIndex       As Long

Public ShapeType        As Long         ' As aofShapeType
Public Invisible        As Boolean

Public X                As Single
Public Y                As Single
Public Width            As Single
Public Height           As Single

Public Position         As Long          ' serial ID of the exported images

' determine if there are animation effects within the shape
' normally, only the text shape has such kind of sub-animation.
Public HasSubAnim       As Boolean
Public SubAnimOrder     As Long
Public AnimInReverse    As Boolean
Public Resistant        As Long

Public TextShapeType    As Long         ' As aofTextShapeType
Public HasTextItem      As Boolean       ' the text shape contains textitem (for text shape)
Private TextItems()     As aofTextItem
Public TextItemNum      As Long
' use these two properties to determin if there is a bullet in front of one text line
Public TextIndentLevel  As Long
Public ParaIndex        As Long

Public HasVertices      As Boolean       ' used by polys and lines
Private Vert()          As aofNode       ' control points of polyline or line
Public VertNum          As Long          ' number of control points
Public PointsString     As String        ' store the string of points (generated by control points)
Public PointNum         As Long          ' number of points on the Bezier curve
Public IsClosedPolyline As Boolean

' group shape setting
Public HasGroupItem     As Boolean
Private GroupItems()    As aofShape
Public GroupItemNum     As Long

' New shadow group 18.02.03
Public HasShadowItem    As Boolean
Private ShadowItems()   As aofShape
Public ShadowItemNum    As Long
Public bAppearInShadow  As Boolean  ' whether this shadow appears in shadow
                                    ' (if this shape is a line in a complex shape, it should be false)
'Public ShadowFillColor As String    ' fill color of shadow
'Public ShadowLineColor As String    ' line color of shadow

Public ContainText      As Boolean       ' the shape contains text (especially for Autoshapes)
Public TextInShape      As aofShape

' line setting and fill setting
Public GraphStyle       As Long         ' As aofGraphStyle
Public LineStyle        As String
Public LineWidth        As Long
Public LineColor        As String
Public ArrowStyle       As String
Public ArrowShape       As String
Public FillColor        As String

' Z-Order position of the shape
Public ZPosition       As Long

' only for image shape
Public ImageFileName    As String        ' image file name
Public DefaultPath      As String        ' default path of image file

' the image position offset of the objects with 3D effect
Private ThreeDOffsetX   As Long
Private ThreeDOffsetY   As Long

Private ThreeDAsGIF     As Boolean

' especially for the rectangle with text and was exported as an image.
Public ForceToNoText    As Boolean

' force to use GIF format - 3D objects, rotated images
Private OutputGIF       As Boolean

' the string to replace <Datum/Uhrzeit>, <Fusszeile> and <Nr.>
Private StrDate         As String
Private StrFooter       As String
Private StrSlideNumber  As String

Private FootersHeadersType   As Long

Private v() As Double
Private p() As Double
Private f() As Double

Public HasTextShadow    As Boolean
Public ShadowOffX       As Single
Public ShadowOffY       As Single
Public ShadowColor      As String

Private ShpHas3D                As Boolean
Private ShpHasText              As Boolean
Private ShpHasConvertableText   As Boolean
Private ShpHasShadow            As Boolean
Private ShpIsSolidFilled        As Boolean
'Private ShpHasRotatedText       As Boolean  ' added (13.02.03) to replace ShpHasConvertableText
Private ShpIsComplex            As Boolean  ' (17.02.03) to identify whether it's a complex Autoshape.
Private ShpIsUnsupported        As Boolean  ' Unsupported shape should be exported as image.

'Private BPoints     As aofPoints
Public BPoints     As aofPoints

Private bParsingAutoshape   As Boolean

Private IsComplexShape      As Boolean  ' the shapes which need 2 or more lsd objects. e.g.: Donut.

Public bConvertToPNG        As Boolean  ' true means the wmf images should be converted into PNG.
Public iCutTransOff         As Integer  ' 1 means cut the trans-part off, 0 not.

Public Sub SetFootersHeadersType(typ As Long)
    FootersHeadersType = typ
    If HasGroupItem Then
        Dim i As Long
        For i = 1 To GroupItemNum
            GroupItems(i).SetFootersHeadersType typ
        Next
    End If
End Sub

Public Function GetFootersHeadersType() As Long
    GetFootersHeadersType = FootersHeadersType
End Function

Public Sub GetZPosition(shp As Shape)
    On Error Resume Next
    ZPosition = shp.ZOrderPosition
End Sub

Public Sub SetZPosition(zp As Long)
    Dim i As Long
    ZPosition = zp
    If HasGroupItem Then
        For i = 1 To GroupItemNum
            GroupItems(i).SetZPosition zp
        Next
    End If
    If HasShadowItem Then
        For i = 1 To ShadowItemNum
            ShadowItems(i).SetZPosition zp
        Next
    End If
    If ContainText Then
        TextInShape.SetZPosition zp
    End If
End Sub

Public Sub SetReplaceText(dt As String, ftr As String, pn As String)
    StrDate = dt
    StrFooter = ftr
    StrSlideNumber = pn
    
    On Error Resume Next
    If HasGroupItem Then
        Dim i As Long
        For i = 1 To GroupItemNum
            GroupItems(i).SetReplaceText dt, ftr, pn
        Next
    End If
End Sub

Private Sub AddGroupItem()
    If HasGroupItem Then
        GroupItemNum = GroupItemNum + 1
    Else
        GroupItemNum = 1
        HasGroupItem = True
    End If
    
    ReDim Preserve GroupItems(1 To GroupItemNum) As aofShape
    Set GroupItems(GroupItemNum) = New aofShape
End Sub

Private Sub AddShadowItem()
    If HasShadowItem Then
        ShadowItemNum = ShadowItemNum + 1
    Else
        ShadowItemNum = 1
        HasShadowItem = True
    End If
    
    ReDim Preserve ShadowItems(1 To ShadowItemNum) As aofShape
    Set ShadowItems(ShadowItemNum) = New aofShape
End Sub

Private Function ShapeInfo() As String
    Select Case ShapeType
        Case aofShapeTypeTextGroup
            ShapeInfo = "ShapeType: TextGroup ItemNum: " & GroupItemNum
        Case aofShapeTypeText
            ShapeInfo = "ShapeType: TextAtom  "
        Case aofShapeTypeUserDefinedGroup
            ShapeInfo = "ShapeType: UserDefinedGroup ItemNum: " & GroupItemNum
        Case aofShapeTypePolygon
            ShapeInfo = "ShapeType: Polygon   "
        Case aofShapeTypeRect
            ShapeInfo = "ShapeType: Rectangle "
        Case aofShapeTypeCirc
            ShapeInfo = "ShapeType: Circle    "
        Case aofShapeTypeLine
            ShapeInfo = "ShapeType: Line"
        Case aofShapeTypeGroup
            ShapeInfo = "ShapeType: Group     ItemNum: " & GroupItemNum
        Case aofShapeTypeImage
            ShapeInfo = "ShapeType: Image     FileName: " & ImageFileName
'        Case aofShapeTypeFreehand
'        Case aofShapeTypeNone
        Case Else
            ShapeInfo = "ShapeType: None      "
    End Select
    If Invisible Then
        ShapeInfo = ShapeInfo & " Invisible! "
    End If
    ShapeInfo = " " & Position & ": " & ShapeInfo
End Function

Function GetGroupItem(idx As Long) As aofShape
    Set GetGroupItem = GroupItems(idx)
End Function

Private Function HasTextInShape(shp As Shape) As Boolean
    On Error Resume Next
    With shp
        If .HasTextFrame = msoFalse Then
            HasTextInShape = False
        ElseIf .TextFrame.hasText = msoFalse Then
            HasTextInShape = False
        ElseIf .TextFrame.TextRange.Text = "" Then
            HasTextInShape = False
        Else
            HasTextInShape = True
        End If
    End With
    
End Function

Private Function HasShadow(shp As Shape) As Boolean
    On Error GoTo ShadowError

    If shp.Shadow.Visible <> msoFalse Then
        HasShadow = True
    Else
        HasShadow = False
    End If
    Exit Function

ShadowError:
    HasShadow = False
    Exit Function
End Function

Private Sub GetBoundingRectDimension(shp As Shape, brl As Single, brt As Single, brw As Single, brh As Single)
    InitVertices 4
    SetVerticesRect shp
    NodesRotate shp.Rotation
    brl = Vert(1).X
    brt = Vert(1).Y
    brw = brl
    brh = brt
    Dim i As Long
    For i = 2 To 4
        If brl > Vert(i).X Then
            brl = Vert(i).X
        ElseIf brw < Vert(i).X Then
            brw = Vert(i).X
        End If
        If brt > Vert(i).Y Then
            brt = Vert(i).Y
        ElseIf brh < Vert(i).Y Then
            brh = Vert(i).Y
        End If
    Next i
    brw = brw - brl
    brh = brh - brt
    
End Sub

Sub SetShadowOffset(shp As Shape)
    Dim sl  As Single, st As Single, sw As Single, sh As Single
    Dim lm  As Single, rm As Single, bm As Single
    
    SetShapeVertices shp
    NewRotateNodes shp
    NewSetBoundingPoints    ' generate the bounding points.
    BPoints.GetDimension sl, st, sw, sh     ' get the dimesion of the shape
    
    Dim xoff As Single, yoff As Single
    xoff = shp.Shadow.OffsetX
    yoff = shp.Shadow.OffsetY
    
    ' there are still some problems with shadow no. 3,4,7,8,11,12,15,16
    ' if the shape is not Rectangle or it was rotated, the size of the shadow
    ' may be incorrect. In this case, the special transform functions of
    ' such kind of shadows should be make. So far, we use a simplier solution,
    ' the transparent part of the image should not be cut away.
    Select Case shp.Shadow.Type
        Case msoShadow1, msoShadow2, msoShadow5, msoShadow6, msoShadow14
            X = sl + IIf(xoff > 0, 0, xoff)
            Y = st + IIf(yoff > 0, 0, yoff)
            Width = sw + Abs(xoff)
            Height = sh + Abs(yoff)
        Case MsoShadowType.msoShadow9   ' width/height of shadow is 0.75 * width/height of shape
            X = sl + IIf(xoff > 0, 0, xoff)
            Y = st + IIf(yoff > 0, 0, yoff)
            If xoff < 0 Or xoff > sw * 0.25 Then
                Width = sw + Abs(xoff)
            Else
                Width = sw
            End If
            If yoff < 0 Or yoff > sh * 0.25 Then
                Height = sh + Abs(yoff)
            Else
                Height = sh
            End If
        Case MsoShadowType.msoShadow10  ' width/height of shadow is 1.25 * width/height of shape
            X = sl + IIf(xoff - sw * 1.25 > 0, 0, xoff - sw * 0.25)
            Y = st + IIf(yoff - sh * 1.25 > 0, 0, yoff - sh * 0.25)
            If xoff < 0 Then
                Width = sw * 1.25 - xoff    '
            ElseIf xoff < sw * 0.25 Then
                Width = sw
            Else
                Width = sw + xoff
            End If
            If yoff < 0 Then
                Height = sh * 1.25 - yoff
            ElseIf yoff < sh * -0.25 Then
                Height = sh
            Else
                Height = sh + yoff
            End If
        Case MsoShadowType.msoShadow13    ' this shadow has 3 layer, so, the offset is xoff * 3
            X = sl + IIf(xoff > 0, 0, xoff * 3)
            Y = st + IIf(yoff > 0, 0, yoff * 3)
            Width = sw + xoff * 3
            Height = sh + yoff * 3
        Case msoShadow17, msoShadow18
            X = sl - Abs(xoff)
            Y = st - Abs(yoff)
            Width = sw + Abs(xoff) * 2
            Height = sh + Abs(yoff) * 2
        Case MsoShadowType.msoShadow19
            X = sl
            Y = st
            Width = sw
            Height = sh
        Case MsoShadowType.msoShadow20
            X = sl
            Y = st
            Width = sw
            Height = sh * 2
        Case msoShapeMixed
            ' in this case, in order to get the correct image size, the shape should be
            ' exported as GIF (width=0, height=0), BUT, the position of the GIF
            ' may be incorrect.
            ' We do not have any solution about this. Because once OffsetX or
            ' OffsetY is modified by the user, the ShadowType was set to ShaodwMixed,
            ' therefore, the shadow type information is lost.
            X = sl + IIf(xoff > 0, 0, xoff)
            Y = st + IIf(yoff > 0, 0, yoff)
            Width = sw + Abs(xoff)
            Height = sh + Abs(yoff)
            iCutTransOff = 0
        Case Else   ' 3, 4, 7, 8, 11, 12, 15, 16
            GetSlopeShadowDimension shp.Shadow.Type, sl, st, sw, sh, X, Y, Width, Height
    End Select
End Sub

' Suppose all unsupported autoshapes are rectangles.
Private Sub GetSlopeShadowDimension(shdTyp As Long, sl As Single, st As Single, sw As Single, sh As Single, _
                                l As Single, t As Single, w As Single, h As Single)
    Dim i As Long, num As Long
    Dim x0 As Single, y0 As Single, xr As Single, yr As Single
    
    num = BPoints.Count
    If num < 1 Then
        Exit Sub
    End If
    
    Select Case shdTyp
        Case 3
            For i = 1 To num
                BPoints.GetPoint i, x0, y0
                Shadow3Transform st + sh, x0, y0, xr, yr
                BPoints.Add xr, yr
            Next
        Case 4
            For i = 1 To num
                BPoints.GetPoint i, x0, y0
                Shadow4Transform st + sh, x0, y0, xr, yr
                BPoints.Add xr, yr
            Next
        Case 7
            For i = 1 To num
                BPoints.GetPoint i, x0, y0
                Shadow7Transform st + sh, x0, y0, xr, yr
                BPoints.Add xr, yr
            Next
        Case 8
            For i = 1 To num
                BPoints.GetPoint i, x0, y0
                Shadow8Transform st + sh, x0, y0, xr, yr
                BPoints.Add xr, yr
            Next
        Case 11
            For i = 1 To num
                BPoints.GetPoint i, x0, y0
                Shadow11Transform sl, st + sh, x0, y0, xr, yr
                BPoints.Add xr, yr
            Next
        Case 12
            For i = 1 To num
                BPoints.GetPoint i, x0, y0
                Shadow12Transform sl + sw, st + sh, x0, y0, xr, yr
                BPoints.Add xr, yr
            Next
        Case 15
            For i = 1 To num
                BPoints.GetPoint i, x0, y0
                Shadow15Transform sl, st + sh, x0, y0, xr, yr
                BPoints.Add xr, yr
            Next
        Case 16
            For i = 1 To num
                BPoints.GetPoint i, x0, y0
                Shadow16Transform sl + sw, st + sh, x0, y0, xr, yr
                BPoints.Add xr, yr
            Next
    End Select
    BPoints.GetDimension l, t, w, h
End Sub

' do not extract the text, only export the shape (without text) as image
Public Sub SetAsImageWithoutText(shp As Shape)
    Dim tw As Long      ' shape width
    Dim th As Long      ' shape height
    Dim tl  As Long     ' shape left
    Dim tt As Long      ' shape top
    Dim tr As Long 'MsoTriState   ' LockAspectRatio
   
    With shp
        ' save shape settings
        tw = .Width
        th = .Height
        tl = .Left
        tt = .Top
        tr = .LockAspectRatio       ' IMPORTANT! fixed a bug: background of text "Lernplattform"
                                    ' in slide 55 of "the world of imc.ppt", size incorrect.

        
        .TextFrame.TextRange.Cut
        
        ' set shape as original size
        ' but this make the presentation modified.
        .LockAspectRatio = msoFalse
        .Width = tw
        .Height = th
        .Left = tl
        .Top = tt
        
        SetAsImage shp
        
        ' resume text
        .TextFrame.TextRange.Paste
        ' after paste, there is an addtional linefeed added,
        ' so we must delete the last character.
        .TextFrame.TextRange.Characters(.TextFrame.TextRange.Length, 1).Delete
        
        ' restore the text setting
        .LockAspectRatio = tr
    End With
End Sub

' extract the text first. delete text temporarily, in order to
' export the shape (without text) as image
Public Sub SetAsImageWithTextInShape(shp As Shape)
   
   ' add text
    ContainText = True
    Set TextInShape = New aofShape
    TextInShape.SetAsText shp
        
    SetAsImageWithoutText shp
End Sub

Public Sub SetCalloutOffset(shp As Shape)
    Dim ratio1 As Single
    Dim ratio2 As Single
    Dim l As Single
    Dim r As Single
    Dim t As Single
    Dim b As Single
    
    With shp
        On Error Resume Next
        l = .Left
        t = .Top
        r = .Left + .Width
        b = .Top + .Height
        
        ratio1 = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio1 = 0.0625
            Err.Clear
        End If
        ratio2 = .Adjustments(2)
        If Err.Number <> 0 Then
            ratio2 = 1.2
        End If
        On Error GoTo 0
        
        If ratio1 < 0 Then
            l = .Left + .Width * ratio1
        ElseIf ratio1 > 1 Then
            r = .Left + .Width * ratio1
        End If
        
        If ratio2 < 0 Then
            t = .Top + .Height * ratio2
        ElseIf ratio2 > 1 Then
            b = .Top + .Height * ratio2
        End If
        
    End With
    
    X = l
    Y = t
    Width = r - l
    Height = b - t
End Sub

Private Sub SetShapeProperties(shp As Shape)
    SetSize shp
    
    ShpHas3D = Has3DEffect(shp)
    ShpHasShadow = HasShadow(shp)
    ShpHasText = HasTextInShape(shp)
    ShpIsSolidFilled = IsSolidFilled(shp)
    
    If Not ShpHasText Then
        ShpHasConvertableText = False
    ElseIf shp.TextFrame.Orientation <> msoTextOrientationHorizontal Then
        ShpHasConvertableText = False
    ElseIf shp.Rotation <> 0 Then
        ShpHasConvertableText = False
    Else
        ShpHasConvertableText = True
    End If
    
    ' if there is unconvertable text, the resulting image remains WMF format.
    If ShpHasText And Not ShpHasConvertableText Then
        bConvertToPNG = False
    End If
    
    ' set ShpIsComplex
    Select Case shp.AutoShapeType
        Case msoShapeStripedRightArrow, _
            msoShapeFlowchartConnector, _
            msoShapeDonut, _
            msoShapeFlowchartOr, _
            msoShapeCube, _
            msoShapeFlowchartSummingJunction, _
            msoShapeCan, msoShapeFlowchartMagneticDisk, _
            msoShapeBevel, msoShapeActionButtonCustom, _
            msoShapeDoubleBracket, _
            msoShapeDoubleBrace, _
            msoShapeFoldedCorner, _
            msoShapeSmileyFace, _
            msoShapeCurvedRightArrow, _
            msoShapeCurvedLeftArrow, _
            msoShapeCurvedUpArrow, _
            msoShapeCurvedDownArrow, _
            msoShapeOvalCallout, msoShapeCloudCallout
               ShpIsComplex = True
        Case msoShapeMixed
            Select Case shp.ConnectorFormat.Type
                Case msoConnectorStraight, _
                     msoConnectorElbow, _
                     msoConnectorCurve
                        ShpIsComplex = False
                Case Else
                        ShpIsComplex = False
            End Select
        Case Else
            ShpIsComplex = False
    End Select
End Sub

Private Sub SetShapeAsImage(shp As Shape)
    If Not ShpHasConvertableText Then
        SetAsImage shp
    Else
        SetAsImageWithTextInShape shp
    End If
End Sub

Public Sub ConvertToPNG()
    Dim wname As String, pname As String
    Dim iRet As Integer
    
    If Not bConvertToPNG Or ImageFileName = "" Then
        Exit Sub
    End If

    On Error GoTo ConvertToPNGError
    If StrComp(Right(ImageFileName, 4), ".wmf", vbTextCompare) = 0 Then
        wname = CvtOpt.WBFilePath & Me.ImageFileName
        pname = Left(ImageFileName, Len(ImageFileName) - 4) & ".png"
        iRet = ConvertWMFtoPNG(wname, CvtOpt.WBFilePath & pname, iCutTransOff)
        If iRet = 1 Then
            ' conversion success. delete the wmf file
            ImageFileName = pname
            Kill wname
        End If
    End If
    Exit Sub
ConvertToPNGError:
    Exit Sub
End Sub

' if the callout is not solid filled, then the text box
' should be exported as image, and the callout lines would
' be converted to lines.
Private Sub ParseCalloutAsImage(shp As Shape)
    ' duplicate a gourp
    Dim tmpShp As ShapeRange
    
    ParseCallout shp
    
    shp.Copy
    Set tmpShp = ActivePresentation.Slides(1).Shapes.Paste()
    With tmpShp(tmpShp.Count)
        .Top = shp.Top
        .Left = shp.Left
        .AutoShapeType = msoShapeRectangle
        .Line.Visible = shp.Callout.Border
    End With
    Set GroupItems(GroupItemNum) = Nothing
    Set GroupItems(GroupItemNum) = New aofShape    ' rebuild the text box
    GroupItems(GroupItemNum).Perform tmpShp(tmpShp.Count)
    
    tmpShp.Delete
    Set tmpShp = Nothing
    
End Sub

Public Sub GetShadowColors(fc As ColorFormat, col1 As String, col2 As String)
    Dim r As Long, g As Long, b As Long
    Dim rt As Long, gt As Long, bt As Long
    
    r = fc Mod 256
    g = CLng(fc / 256 - 0.5) Mod 256
    b = CLng(fc / 65536 - 0.5)
    
    col1 = GetHexColor(r, g, b)
    
    col2 = GetHexColor(IIf(r < 154, r + 102, 255), IIf(g < 154, g + 102, 255), IIf(b < 154, b + 102, 255))
    
End Sub


' implement the conversion
'
' +++ Some known rules (according to experiments, no official documents) +++
'
' 0. Shadow and 3D are mutually exclusive.
' 1. Tables have no shadow/3D effects
' 2. Some OLE objects have shadow effects 1,2,5,6,13,14,17,18, but no 3D.
' 3. Charts have no 3D effects, have shadow effects 1,2,5,6,13,14,17,18.
' 4. Complex Autoshapes (Can, Cube, Bevel, etc.) HAVE shaodw effects now(?!).
'    As I knew before, these kinds of Autoshape had no shadow effects.
' 5. Textbox without outline and fillcolor has no 3D effects, has shadow 1,2,5,
'    6,13,14,17,18.
' 6. Single lines, single brackets, single braces, connectors and arcs can only
'    have shadow 1,2,5,6,13,14,17,18.
' 7. Polylines (opened or closed), double brackets and double braces have all
'    shadow effects.
' 8. Pointed callouts, rectangle callout, round corner rectangle callout, oval
'    callout and cloudy callout can only have shaodw 1,2,5,6,13,14,17,18.
' 9. Images can also have shaodws, only 1,2,5,6,13,14,17,18.
' 10.Line may have Shadow 1,2,5,6,13,14,17,18. Line donot have Text content.
' 11.Text may ONLY have shadow 1,2,5,6,14.
'
' +++ Known bugs (TODO list) +++
'
' 1. If the text's bounding box exceeds its host autoshape's territory, and,
'    this shape (rotated) should be exported as image, the image size is no
'    longer the bounding box of the autoshape. This should be fixed in future.
'
Public Sub Perform(shp As Shape)
    On Error Resume Next
    Dim i           As Long

    ' A visible shape won't be converted. Property "Invisible" is marked as
    ' True, this object will not be written into lsd file.
    If shp.Visible = msoFalse Then
        Invisible = True
        Exit Sub
    End If

    ' As we now know, a group can have 3D or shadow effect.
    ' Fortunately, the 3D/shadow effect is applied to each group item.
    ' That means, it is safe to convert group items without considering the
    ' effect on the group itself. First, the group will be ungrouped, then
    ' each item will be converted individually (following the normal flow).
    If shp.Type <> msoGroup Then

        ' In this procedure, some important properties are set:
        ' a) ShapeSize (by SetSize(shp))
        ' b) ShpHas3D  (by Has3DEffect(shp))
        ' c) ShpHasShadow (by HasShadow(shp))
        ' d) ShpHasText   (by HasTextInShape(shp))
        ' e) ShpHasConvertableText
        '    e.1) "ConvertableText" means the Text is not null/invisible string,
        '         OrientationVertical and not rotated. So,
        '         if ShapeHasText and TextOrientation <> OrientationHorizontal
        '            and Shp.Rotate = 0 then ShpHasConvertableText is true,
        '         otherwise, false.
        '    e.2) If there is unconvertalbe text, the (whole) shape should be
        '         exported into image, and in WMF format in order to keep the
        '         fine display quality.
        '    (+) "ShpHasRotatedText" is more reasonable. (13.02.03)
        '    e.3) If ShpHasText and TextOrientation <> OrientationHorizontal
        '            and Shp.Rotate = 0
        '         then ShpHasRotatedText is false, set bConvertToPNG as true,
        '         else ShpHasRotatedText is true, set bConvertToPNG as false.
        ' f) ShpIsSolidFilled (by IsSolidFilled(shp), since Lecturnity only
        '      supports solid fill mode, shapes with other fill modes should be
        '      exported as images)
        SetShapeProperties shp

        ' At present, all 3D objects are converted as images.
        If ShpHas3D Then

            ' In this procedure, the "convertable" text should be converted to
            ' an individual object, the further content search and retrieve is
            ' therefore possible.
            ' The resulting image is in WMF format.
            SetShapeAsImage shp

            ' This is the core function of 3D object conversion, the accurate
            ' position and size of the exported image are given here.
            Set3DObjectOffset shp

            ' In this procedure, the WMF image would be converted into PNG.
            ' Relevant properties (bConvertToPNG and iCutTransOff) should be set
            ' befroe the conversion.
            ' If the shape contians text, the resulting WMF should not be
            ' converted into PNG format (by setting bConvertToPNG as False).
            ConvertToPNG
            Exit Sub
        End If ' ShpHas3D
        
        ' In this If section, we determine whether the shape (with shadow)
        ' should be exported as image or not. If it should be exported as image,
        ' the image position offset should be given. If not, the shape should
        ' be converted to a set of objects (normally shape object and shadow
        ' object(s)).
        If ShpHasShadow Then
    
            ' If there is unconvertable text in the shape, the whole shape (with
            ' the text) should be exported as image. It is difficult (and
            ' unmeaningful) to convert the text and the background separately.
            If (ShpHasText And Not ShpHasConvertableText) Then

                ' As described before, ConvertableText, if available, will be
                ' converted to an individual (text) object.
                SetShapeAsImage shp

                ' An core procedure of shadow conversion.
                ' New position and size of the image should be given here.
                SetShadowOffset shp

                ' Same with in "3D" section.
                ConvertToPNG
                Exit Sub
            End If ' (ShpHasText and not ShpHasConvertableText)
            
            ' Shapes with fill modes other than solid fill mode should be
            ' exported as images.
            If Not ShpIsSolidFilled Then
                ' As described before, ConvertableText, if available, will be
                ' converted to an individual (text) object.
                SetShapeAsImage shp

                ' An core procedure of shadow conversion.
                ' New position and size of the image should be given here.
                SetShadowOffset shp

                ' Same with in "3D" section.
                ConvertToPNG
                Exit Sub
            End If ' Not ShpIsSolidFilled
            
            ' Now convert the "normal" shapes with shadow.
            ' 1) is solid filled.
            ' 2) doesn't contain text or contains convertable text.
            Select Case shp.Shadow.Type
                Case msoShadowMixed
'                    ' Cannot handle these types correctly.
'                    ' At present, presume the ShadowType is 1.
                    SetShapeAsImage shp
                    SetShadowOffset shp
                    ConvertToPNG
                    Exit Sub
                Case Else
                    ' Complex autoshapes, like: CurvedArrows (Up/Down/Left/Right),
                    ' Cube, Can, FoldedCorner, Bevel, SmilyFace, Sun, etc., should
                    ' be converted as group. Therefore their shadow should also be
                    ' saved as a group.
                    If ShpIsComplex Then
                       ' Convert the shape without shadow
                       ' !!!IMPORTANT!!!
                       ' In this precedure, all the vertices are set at first, and
                       ' saved in Me.Vert() by invoke NewSetVertices().
                       ' The array Vert() should be used to find out the bounding
                       ' box (dimension) of the whole shape, which is very important
                       ' for the shadow conversion.
                       ' So that Vert() should not be erased before shadow generating
                       ' procedure finished GenerateShadowItems().
                        ' NewParseAutoshape shp   ' should be deprecated .
                        SetShapeVertices shp
                        ParseComplexShapes shp
                        ' convert the text within the shape
                        If ShpHasConvertableText Then
                           AddGroupItem
                           With GroupItems(GroupItemNum)
                               .SetAsText shp
                           End With
                        End If
                       ' Generate shadow items (in ShadowItems())
                       ' If there is shadow effect, generate the shadowItems.
                       ' Meanwhile, the ShapeType should be aofUserDefinedGroup
                       GenerateComplexShadowItems shp
                    Else    ' simple autoshapes or unsupported shapes
                        ' Core procedure of shadow conversion.
                        SetShapeVertices shp
                        
                        If ShpIsUnsupported Then
                            ' Notice: here the shadow offset should be applied.
                            ParseImage shp
                            SetShadowOffset shp
                            ConvertToPNG
                            Exit Sub
                        End If

                        ParseSimpleShape shp
                        ' convert text within the shape
                        If ShpHasConvertableText Then
                           ContainText = True
                           Set TextInShape = New aofShape
                           TextInShape.SetAsText shp
                        End If
                        
                        GenerateSimpleShadowItems shp
                    End If
            End Select
            
            Exit Sub
        End If ' ShpHasShadow
            
        ' Shapes without 3D or shadow, but with rotated text, should be
        ' converted into images.
        If ShpHasText And Not ShpHasConvertableText Then
            ' Callouts are special, they may have accent bar, callout line.
            If shp.Type = msoCallout Then
                ' An important precedure (should be revised).
                ParseCalloutAsImage shp
                Exit Sub
            End If

            ' Simply convert the shape into image.
            SetAsImage shp
            
            ' Then set the new position and size.
            NewSetNewAnchor shp     ' vertices set here, rotated here

            ' if the shape contains text, use WMF format.
            ConvertToPNG
            Exit Sub
        End If 'ShpHasText And Not ShpHasConvertableText
        
        ' Shapes without 3D or shadow, without rotated text, but with special
        ' fill mode, should be converted into images.
        '
        If Not ShpIsSolidFilled Then
            ' Callouts.
            If shp.Type = msoCallout Then
                ParseCalloutAsImage shp
                Exit Sub
            End If

            ' If shape contains text (ConvertalbeText), then convert the text
            ' into an individual object.
            If ShpHasConvertableText Then
                SetAsImageWithTextInShape shp
            Else
                SetAsImage shp
            End If
            
            ' Set the accurate position and size of the (rotated) shape.
            ' Pay attention to the "Known bugs No.1".
            bParsingAutoshape = False
            SetShapeVertices shp
            NewRotateNodes shp
            NewSetBoundingPoints
            BPoints.GetDimension X, Y, Width, Height
            bConvertToPNG = True
            ConvertToPNG
            Exit Sub
        End If ' Not ShpIsSolidFilled

    End If ' shp.Type <> msoGroup
    
    ' Normal shape conversion procedure.
    ' Now the shapes obey following rules:
    ' 1) No 3D or Shadow effect.
    ' 2) No unconvertable text.
    ' 3) No special fill mode.
    ' They may:
    ' 1) With convertable text.
    ' 2) Rotated but no text.
    Select Case shp.Type
        Case MsoShapeType.msoTextBox
            ParseTextBox shp, ShpHasConvertableText
        Case MsoShapeType.msoGroup
            ParseGroup shp
        Case MsoShapeType.msoLine
            ParseLine shp
        Case MsoShapeType.msoPlaceholder
            Select Case shp.PlaceholderFormat.Type
                Case PpPlaceholderType.ppPlaceholderTitle, _
                    PpPlaceholderType.ppPlaceholderBody, _
                    PpPlaceholderType.ppPlaceholderCenterTitle, _
                    PpPlaceholderType.ppPlaceholderSubtitle, _
                    PpPlaceholderType.ppPlaceholderFooter, _
                    PpPlaceholderType.ppPlaceholderHeader, _
                    PpPlaceholderType.ppPlaceholderSlideNumber, _
                    PpPlaceholderType.ppPlaceholderDate
                        ParseTextBox shp, ShpHasConvertableText
                Case PpPlaceholderType.ppPlaceholderBitmap
                    bConvertToPNG = True
                    iCutTransOff = 0
                    ParseImage shp
                Case Else
                    bConvertToPNG = False
                    iCutTransOff = 0
                    ParseImage shp
            End Select
        Case MsoShapeType.msoAutoShape
            NewParseAutoshape shp
            If ShpHasConvertableText Then
                ContainText = True
                Set TextInShape = New aofShape
                TextInShape.SetAsText shp
            End If
        Case MsoShapeType.msoFreeform
            ParsePolygon shp, ShpHasConvertableText
        Case MsoShapeType.msoLinkedPicture, msoPicture
            bConvertToPNG = True
            iCutTransOff = 0
            ParseImage shp
'        Case MsoShapeType.msoTable
'            ParseGroup shp
        Case MsoShapeType.msoCallout
            ParseCallout shp
        Case MsoShapeType.msoEmbeddedOLEObject, MsoShapeType.msoLinkedOLEObject
            ParseOLEObject shp
        Case Else
            ParseImage shp
    End Select

End Sub

Private Sub GenerateSimpleShadowItems(shp As Shape)
    Dim i As Long
    Dim sl  As Single, st As Single, sw As Single, sh As Single
    Dim ShadowLineColor As String, ShadowFillColor As String
    Dim col1 As String, col2 As String
    
    'NewSetBoundingPoints            ' set all bounding points.
    
    ' Now we no longer need Vert(), therefore it can be safely
    ' cleared and use it to calculate the Bounding Rectangle's dimension.
    GetBoundingRectDimension shp, sl, st, sw, sh
    
    ShadowFillColor = MLBColor(shp.Shadow.ForeColor)
    ShadowLineColor = ShadowFillColor
    
    Select Case shp.Shadow.Type
    Case msoShadow1, msoShadow2, msoShadow5, msoShadow6, msoShadow14    ' simple shadow
        AddShadowItem
        MakeShadow Me, ShadowItems(ShadowItemNum), _
                sl, st, sw, sh, shp.Shadow.OffsetX, shp.Shadow.OffsetY, _
                ShadowFillColor, ShadowLineColor, msoShadow1
    Case MsoShadowType.msoShadow13    ' this shadow has 2 layer, so, the offset is xoff * 2
        GetShadowColors shp.Shadow.ForeColor, col1, col2
        AddShadowItem
        MakeShadow Me, ShadowItems(ShadowItemNum), _
                sl, st, sw, sh, shp.Shadow.OffsetX * 2, shp.Shadow.OffsetY * 2, _
                col2, col2, msoShadow1
        AddShadowItem
        MakeShadow Me, ShadowItems(ShadowItemNum), _
                sl, st, sw, sh, shp.Shadow.OffsetX, shp.Shadow.OffsetY, _
                col1, col1, msoShadow1
    Case msoShadow17, msoShadow18     ' 2 layers
        ' the shadow colors are related to the shp.Fill.ForeColor of the shape,
        ' not the shp.Shadow.ForeColor.
        GetShadowColors shp.Fill.ForeColor, col1, col2
        AddShadowItem
        MakeShadow Me, ShadowItems(ShadowItemNum), _
                sl, st, sw, sh, shp.Shadow.OffsetX, shp.Shadow.OffsetY, _
                col1, col1, msoShadow1
        AddShadowItem
        MakeShadow Me, ShadowItems(ShadowItemNum), _
                sl, st, sw, sh, -shp.Shadow.OffsetX, -shp.Shadow.OffsetY, _
                col2, col2, msoShadow1
    Case Else
        AddShadowItem
        MakeShadow Me, ShadowItems(ShadowItemNum), _
                sl, st, sw, sh, shp.Shadow.OffsetX, shp.Shadow.OffsetY, _
                ShadowFillColor, ShadowLineColor, shp.Shadow.Type
    End Select
    
End Sub

Private Sub GenerateComplexShadowItems(shp As Shape)
    Dim i As Long
    Dim sl  As Single, st As Single, sw As Single, sh As Single
    Dim ShadowLineColor As String, ShadowFillColor As String
    Dim col1 As String, col2 As String
    
    GetBoundingRectDimension shp, sl, st, sw, sh
    ShadowFillColor = MLBColor(shp.Shadow.ForeColor)
' so strange! it seems that line color in shadow can be set, but no
' respective properties in ShadowFormat. Here we use fill color instead.
    ShadowLineColor = ShadowFillColor
    For i = 1 To GroupItemNum
        Select Case shp.Shadow.Type
        Case msoShadow1, msoShadow2, msoShadow5, msoShadow6, msoShadow14    ' simple shadow
            AddShadowItem
            MakeShadow GroupItems(i), ShadowItems(ShadowItemNum), _
                    sl, st, sw, sh, shp.Shadow.OffsetX, shp.Shadow.OffsetY, _
                    ShadowFillColor, ShadowLineColor, msoShadow1
        Case MsoShadowType.msoShadow13    ' this shadow has 2 layers, so, the offset is xoff * 2
            GetShadowColors shp.Shadow.ForeColor, col1, col2
            AddShadowItem
            MakeShadow GroupItems(i), ShadowItems(ShadowItemNum), _
                    sl, st, sw, sh, shp.Shadow.OffsetX * 2, shp.Shadow.OffsetY * 2, _
                    col2, col2, msoShadow1
            AddShadowItem
            MakeShadow GroupItems(i), ShadowItems(ShadowItemNum), _
                    sl, st, sw, sh, shp.Shadow.OffsetX, shp.Shadow.OffsetY, _
                    col1, col1, msoShadow1
        Case msoShadow17, msoShadow18    ' 2 shadow layers
            GetShadowColors shp.Fill.ForeColor, col1, col2
            AddShadowItem
            MakeShadow GroupItems(i), ShadowItems(ShadowItemNum), _
                    sl, st, sw, sh, shp.Shadow.OffsetX, shp.Shadow.OffsetY, _
                    col1, col1, msoShadow1
            AddShadowItem
            MakeShadow GroupItems(i), ShadowItems(ShadowItemNum), _
                    sl, st, sw, sh, -shp.Shadow.OffsetX, -shp.Shadow.OffsetY, _
                    col2, col2, msoShadow1
        Case Else
            AddShadowItem
            MakeShadow GroupItems(i), ShadowItems(ShadowItemNum), _
                    sl, st, sw, sh, shp.Shadow.OffsetX, shp.Shadow.OffsetY, _
                    ShadowFillColor, ShadowLineColor, shp.Shadow.Type
        End Select
    Next
End Sub


' oObj: the original object (aofShape)
' sObj: the shadwo object (aofShape)
Private Sub MakeShadow(oObj As aofShape, sObj As aofShape, _
        sl As Single, st As Single, sw As Single, sh As Single, _
        xoff As Single, yoff As Single, _
        ShadowFillColor As String, ShadowLineColor As String, _
        shpType As Long)

    Dim i As Long
    Dim x0 As Single, y0 As Single, xr As Single, yr As Single
    
    Select Case shpType
        Case 1 'msoShadow1, msoShadow2, msoShadow5, msoShadow6, msoShadow14,msoShadow13,msoShadow17,msoShadow18
            For i = 1 To oObj.BPoints.Count
                oObj.BPoints.GetPoint i, x0, y0
                sObj.BPoints.Add (x0 + xoff), (y0 + yoff)
            Next
        Case 9 'MsoShadowType.msoShadow9   ' width/height of shadow is 0.75 * width/height of shape
            For i = 1 To oObj.BPoints.Count
                oObj.BPoints.GetPoint i, x0, y0
                sObj.BPoints.Add ((x0 - sl) * 0.75 + sl + xoff), _
                                 ((y0 - st) * 0.75 + st + yoff)
            Next
        Case 10 'MsoShadowType.msoShadow10  ' width/height of shadow is 1.25 * width/height of shape
            For i = 1 To oObj.BPoints.Count
                oObj.BPoints.GetPoint i, x0, y0
                sObj.BPoints.Add ((x0 - (sl + sw)) * 1.25 + (sl + sw) + xoff), _
                                 ((y0 - (st + sh)) * 1.25 + (st + sh) + yoff)
            Next
        Case MsoShadowType.msoShadow3
            For i = 1 To oObj.BPoints.Count
                oObj.BPoints.GetPoint i, x0, y0
                Shadow3Transform (st + sh), x0, y0, xr, yr
                sObj.BPoints.Add (xr + xoff), (yr + yoff)
            Next
        Case MsoShadowType.msoShadow4
            For i = 1 To oObj.BPoints.Count
                oObj.BPoints.GetPoint i, x0, y0
                Shadow4Transform (st + sh), x0, y0, xr, yr
                sObj.BPoints.Add (xr + xoff), (yr + yoff)
            Next
        Case MsoShadowType.msoShadow7
            For i = 1 To oObj.BPoints.Count
                oObj.BPoints.GetPoint i, x0, y0
                Shadow7Transform (st + sh), x0, y0, xr, yr
                sObj.BPoints.Add (xr + xoff), (yr + yoff)
            Next
        Case MsoShadowType.msoShadow8
            For i = 1 To oObj.BPoints.Count
                oObj.BPoints.GetPoint i, x0, y0
                Shadow8Transform (st + sh), x0, y0, xr, yr
                sObj.BPoints.Add (xr + xoff), (yr + yoff)
            Next
        Case MsoShadowType.msoShadow11
            For i = 1 To oObj.BPoints.Count
                oObj.BPoints.GetPoint i, x0, y0
                Shadow11Transform sl, (st + sh), x0, y0, xr, yr
                sObj.BPoints.Add (xr + xoff), (yr + yoff)
            Next
        Case MsoShadowType.msoShadow12
            For i = 1 To oObj.BPoints.Count
                oObj.BPoints.GetPoint i, x0, y0
                Shadow12Transform (sl + sw), (st + sh), x0, y0, xr, yr
                sObj.BPoints.Add (xr + xoff), (yr + yoff)
            Next
        Case MsoShadowType.msoShadow15
            For i = 1 To oObj.BPoints.Count
                oObj.BPoints.GetPoint i, x0, y0
                Shadow15Transform sl, (st + sh), x0, y0, xr, yr
                sObj.BPoints.Add (xr + xoff), (yr + yoff)
            Next
        Case MsoShadowType.msoShadow16
            For i = 1 To oObj.BPoints.Count
                oObj.BPoints.GetPoint i, x0, y0
                Shadow16Transform (sl + sw), (st + sh), x0, y0, xr, yr
                sObj.BPoints.Add (xr + xoff), (yr + yoff)
            Next
        Case MsoShadowType.msoShadow19
            For i = 1 To oObj.BPoints.Count
                oObj.BPoints.GetPoint i, x0, y0
                Shadow19Transform (sl + sw / 2), (st + sh), x0, y0, xr, yr
                sObj.BPoints.Add (xr + xoff), (yr + yoff)
            Next
        Case MsoShadowType.msoShadow20
            For i = 1 To oObj.BPoints.Count
                oObj.BPoints.GetPoint i, x0, y0
                sObj.BPoints.Add (x0 + xoff), _
                                 ((st + sh) * 2 - y0)
            Next
        'Case Else
            ' msoShadowMixed should be exported into images in Function
            ' Perform(). NOT HERE!!!
    End Select
    
    With sObj
        .PointsString = .BPoints.PrintString()
        .FillColor = ShadowFillColor
        .LineColor = ShadowLineColor
        
        .ShapeType = oObj.ShapeType
        .GraphStyle = oObj.GraphStyle
        .LineStyle = oObj.LineStyle
        .LineWidth = oObj.LineWidth
        .ArrowStyle = oObj.ArrowStyle
        .ArrowShape = oObj.ArrowShape
        .IsClosedPolyline = oObj.IsClosedPolyline
    End With
End Sub

' do the point transform of shadow3
' bottom: bottom of the rotated bounding rectantle.
' x0, y0: original coordinate.
' xr, yr: results
Private Sub Shadow3Transform(bottom As Single, x0 As Single, y0 As Single, xr As Single, yr As Single)
    xr = x0 - (bottom - y0) * Tan(PI / 3) / 2
    yr = (y0 + bottom) / 2
End Sub

Private Sub Shadow4Transform(bottom As Single, x0 As Single, y0 As Single, xr As Single, yr As Single)
    xr = x0 + (bottom - y0) * Tan(PI / 3) / 2
    yr = (y0 + bottom) / 2
End Sub

' do the point transform of shadow7, vertical mirror of shadow3
Private Sub Shadow7Transform(bottom As Single, x0 As Single, y0 As Single, xr As Single, yr As Single)
    xr = x0 - (bottom - y0) * Tan(PI / 3) / 2
    yr = (bottom - y0) / 2 + bottom
End Sub

' do the point transform of shadow8, vertical mirror of shadow4
Private Sub Shadow8Transform(bottom As Single, x0 As Single, y0 As Single, xr As Single, yr As Single)
    xr = x0 + (bottom - y0) * Tan(PI / 3) / 2
    yr = (bottom - y0) / 2 + bottom
End Sub

' do the point transform of shadow11
' bottom: bottom of the rotated bounding rectantle.
' leftmost: left border of the rotated bounding rectangle
' x0, y0: original coordinate.
' xr, yr: results
Private Sub Shadow11Transform(leftmost As Single, bottom As Single, x0 As Single, y0 As Single, xr As Single, yr As Single)
    ' The transform follow these rules:
    ' a) shadow lines of all (parallel) vertical lines intersect at one certain Point:
    '     D (leftmost-d0, bottom-h0), here d0 = 119, h0 = 83.
    '    or: the shadow of point (x, Infinite) is D.
    ' b) lines through points and their shadows intersect as another certain Point:
    '     H (leftmost-d0, bottom)
    ' So, point(x0, y0)'s shadow (xr, yr) satisfy:
    '     xr = x0 - (x0 -leftmost + d0) *(bottom - y0)/(h0 + bottom - y0)
    '     yr = bottom - ((bottom - y0) · h0)/(bottom - y0 + h0)
    Dim d0 As Single, h0 As Single
    d0 = 119
    h0 = 83
    xr = x0 - (x0 - leftmost + d0) * (bottom - y0) / (h0 + bottom - y0)
    yr = bottom - ((bottom - y0) * h0) / (bottom - y0 + h0)
End Sub

' do the point transform of shadow15, vertical mirror of shadow11
Private Sub Shadow15Transform(leftmost As Single, bottom As Single, x0 As Single, y0 As Single, xr As Single, yr As Single)
    Dim d0 As Single, h0 As Single
    d0 = 119
    h0 = 83
    xr = x0 - (x0 - leftmost + d0) * (bottom - y0) / (h0 + bottom - y0)
    yr = bottom + ((bottom - y0) * h0) / (bottom - y0 + h0)
End Sub

' do the point transform of shadow12
' bottom: bottom of the rotated bounding rectantle.
' rightmost: right border of the rotated bounding rectangle
' x0, y0: original coordinate.
' xr, yr: results
Private Sub Shadow12Transform(rightmost As Single, bottom As Single, x0 As Single, y0 As Single, xr As Single, yr As Single)
    ' The transform follow these rules:
    ' a) shadow lines of all (parallel) vertical lines intersect at one certain Point:
    '     D (rightmost+d0, bottom-h0), here d0 = 119, h0 = 83.
    '    or: the shadow of point (x, Infinite) is D.
    ' b) lines through points and their shadows intersect as another certain Point:
    '     H (rightmost+d0, bottom)
    ' So, point(x0, y0)'s shadow (xr, yr) satisfy:
    '     xr = x0 + (rightmost + d0 -x0) *(bottom - y0)/(h0 + bottom - y0)
    '     yr = bottom - ((bottom - y0) · h0)/(bottom - y0 + h0)
    Dim d0 As Single, h0 As Single
    d0 = 119
    h0 = 83
    xr = x0 + (rightmost + d0 - x0) * (bottom - y0) / (h0 + bottom - y0)
    yr = bottom - ((bottom - y0) * h0) / (bottom - y0 + h0)
End Sub

' do the point transform of shadow16, vertical mirror of shadow12
Private Sub Shadow16Transform(rightmost As Single, bottom As Single, x0 As Single, y0 As Single, xr As Single, yr As Single)
    ' The transform follow these rules:
    ' a) shadow lines of all (parallel) vertical lines intersect at one certain Point:
    '     D (rightmost+d0, bottom-h0), here d0 = 119, h0 = 83.
    '    or: the shadow of point (x, Infinite) is D.
    ' b) lines through points and their shadows intersect as another certain Point:
    '     H (rightmost+d0, bottom)
    ' So, point(x0, y0)'s shadow (xr, yr) satisfy:
    '     xr = x0 + (rightmost + d0 -x0) *(bottom - y0)/(h0 + bottom - y0)
    '     yr = bottom - ((bottom - y0) · h0)/(bottom - y0 + h0)
    Dim d0 As Single, h0 As Single
    d0 = 119
    h0 = 83
    xr = x0 + (rightmost + d0 - x0) * (bottom - y0) / (h0 + bottom - y0)
    yr = bottom + ((bottom - y0) * h0) / (bottom - y0 + h0)
End Sub

' do the point transform of shadow19
' middle: horizonal middle point of the rotated bounding rectangle
' bottom: bottom of the rotated bounding rectantle.
' x0, y0: original coordinate.
' xr, yr: results
Private Sub Shadow19Transform(middle As Single, bottom As Single, x0 As Single, y0 As Single, xr As Single, yr As Single)
    ' The transform follow these rules:
    ' a) shadow lines of all (parallel) vertical lines intersect at one certain Point:
    '     D (middle, bottom-h0), here , h0 = 83.
    '    or: the shadow of point (x, Infinite) is D.
    ' b) lines through points and their shadows intersect as another certain Point:
    '     H (middle, bottom+h0)
    ' So, point(x0, y0)'s shadow (xr, yr) satisfy:
    '     xr = middle - 2 * h0 * ( middle - x0)/(bottom - y0 + 2h0)
    '     yr = bottom - ((bottom - y0) * h0)/(bottom - y0 + 2h0)
    Dim h0 As Single
    h0 = 83
    xr = middle - 2 * h0 * (middle - x0) / (bottom - y0 + 2 * h0)
    yr = bottom - ((bottom - y0) * h0) / (bottom - y0 + 2 * h0)
End Sub
Private Sub ParseOLEObject(shp As Shape)
    Dim progType As String
    'progType = shp.OLEFormat.ProgID
    'If InStr(1, progType, "Equation", vbTextCompare) > 0 Then
        bConvertToPNG = False
    'End If
    ParseImage shp
End Sub

Sub ParseCallout(shp As Shape)
    Dim i As Long
    Dim t As Single
    Dim l As Single
    Dim r As Single
    Dim b As Single
    
    SetSize shp
    SetLineArt shp
    
    Select Case shp.Callout.Type
        Case msoCalloutOne
            ParseCalloutOne shp
        Case msoCalloutTwo
            ParseCalloutTwo shp
        Case msoCalloutThree
            ParseCalloutThree shp
        Case msoCalloutFour
            ParseCalloutFour shp
    End Select
    
'    If Not IsSolidFilled(shp) Then
'        l = x
'        r = x
'        t = y
'        b = y
'        For i = 1 To VertNum
'            If Vert(i).x < l Then
'                l = Vert(i).x
'            ElseIf Vert(i).x > r Then
'                r = Vert(i).x
'            End If
'            If Vert(i).y < t Then
'                t = Vert(i).y
'            ElseIf Vert(i).y > b Then
'                b = Vert(i).y
'            End If
'        Next
'
'        x = l
'        y = t
'        Width = r - l
'        Height = b - t
'
'        SetAsImage shp
'        SetNewAnchor shp, True
'
'        Exit Sub
'    End If

'    If shp.HasTextFrame = msoTrue Then
'        If shp.TextFrame.TextRange.Text <> "" Then
'            ContainText = True
'            Invisible = False
'            Set TextInShape = New aofShape
'            TextInShape.SetAsText shp
'        End If
'    End If

End Sub

Private Sub ParseCalloutOne(shp As Shape)
    ParseCalloutTwo shp
End Sub

Public Sub SetVertOfCalloutTwo(shp As Shape, ByRef hasAccent As Boolean)
    Dim ratio1  As Single
    Dim ratio2  As Single
    Dim ratio3  As Single
    Dim ratio4  As Single
    
    With shp.Callout
        If .Type = msoCalloutTwo And .Accent = msoTrue Then
            hasAccent = True
'            GroupItemNum = 3
            VertNum = 4
        Else
            hasAccent = False
'            GroupItemNum = 2
            VertNum = 2
        End If
    End With
    
    ReDim Vert(1 To VertNum) As aofNode
    
    With shp
        On Error Resume Next
        ratio1 = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio1 = -1
            Err.Clear
        End If
        ratio2 = .Adjustments(2)
        If Err.Number <> 0 Then
            ratio2 = -0.08333334
            Err.Clear
        End If
        ratio3 = .Adjustments(3)
        If Err.Number <> 0 Then
            ratio3 = -1
            Err.Clear
        End If
        ratio4 = .Adjustments(4)
        If Err.Number <> 0 Then
            ratio4 = -0.08333334
            Err.Clear
        End If
        
        Vert(1).X = .Left + .Width * ratio1
        Vert(1).Y = .Top + .Height * ratio2
      
        Vert(2).X = .Left + .Width * ratio3
        Vert(2).Y = .Top + .Height * ratio4
        
        If hasAccent Then
            If Vert(2).X < .Left Or Vert(2).X > .Left + .Width Then
                ' accent is vertical
                Vert(3).X = Vert(2).X
                Vert(4).X = Vert(2).X
                Vert(3).Y = .Top
                Vert(4).Y = .Top + .Height
            ElseIf Vert(2).Y < .Top Or Vert(2).Y > .Top + .Height Then
                Vert(3).X = .Left
                Vert(4).X = .Left + .Width
                Vert(3).Y = Vert(2).Y
                Vert(4).Y = Vert(2).Y
            End If
        End If
    End With
End Sub

Private Sub ParseCalloutTwo(shp As Shape)
    Dim arrh    As Boolean
    Dim arre    As Boolean
    Dim hasAccent As Boolean
    
    ShapeType = aofShapeTypeUserDefinedGroup
    
    HasGroupItem = True
    
    SetVertOfCalloutTwo shp, hasAccent
    
    If hasAccent Then
        GroupItemNum = 3
    Else
        GroupItemNum = 2
    End If
    
    ReDim GroupItems(1 To GroupItemNum) As aofShape
    
    
    FlipNodes Vert, VertNum, shp
    NodesRotate shp.Rotation
    
    If shp.Line.BeginArrowheadStyle <> msoArrowheadNone Then
        arrh = True
    End If
    If shp.Line.EndArrowheadStyle <> msoArrowheadNone Then
        arre = True
    End If
        
    'point line
    Set GroupItems(1) = New aofShape
    With GroupItems(1)
        .ShapeType = aofShapeTypeLine
        .SetLineArt shp
        .SetVerts Vert, 1, 2
        .BuildLineWithVert arrh, arre
    End With
    
    ' text box
    ' accent
    If hasAccent Then
        Set GroupItems(2) = New aofShape
        With GroupItems(2)
            .ShapeType = aofShapeTypeLine
            .SetLineArt shp
            .ArrowStyle = "none"        ' no arrow
            .SetVerts Vert, 3, 2
            .BuildLineWithVert arrh, arre
        End With
    End If
    
    Set GroupItems(GroupItemNum) = New aofShape
    With GroupItems(GroupItemNum)
'        .ParseTextBox shp
'        .SetLineArt shp
'        If shp.Callout.Border = msoFalse Then
'            .GraphStyle = .GraphStyle - aofGraphStyleOutline
'        End If
        .SetAsFourPointsRect shp
        
        If shp.Callout.Border = msoTrue Then
            If .GraphStyle = aofGraphStyleNone Or .GraphStyle = aofGraphStyleFilled Then
                .GraphStyle = aofGraphStyleOutline + .GraphStyle
            End If
        ElseIf shp.Callout.Border = msoFalse Then
            If .GraphStyle = aofGraphStyleOutline Or .GraphStyle = aofGraphStyleFilledOutline Then
                .GraphStyle = .GraphStyle - aofGraphStyleOutline
            End If
        End If
        
        If HasTextInShape(shp) Then
            .ContainText = True
            Set .TextInShape = New aofShape
            .TextInShape.SetAsText shp
        End If
    End With
    
    
End Sub

Public Sub SetVertOfCalloutThree(shp As Shape, ByRef hasAccent As Boolean)
    Dim ratio1  As Single
    Dim ratio2  As Single
    Dim ratio3  As Single
    Dim ratio4  As Single
    Dim ratio5  As Single
    Dim ratio6  As Single
    
    If shp.Callout.Accent = msoTrue Then
        hasAccent = True
'        GroupItemNum = 4
        VertNum = 5
    Else
        hasAccent = False
'        GroupItemNum = 3
        VertNum = 3
    End If
    
    ReDim Vert(1 To VertNum) As aofNode
    
    With shp
        On Error Resume Next
        ratio1 = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio1 = -2
            Err.Clear
        End If
        ratio2 = .Adjustments(2)
        If Err.Number <> 0 Then
            ratio2 = -2
            Err.Clear
        End If
        ratio3 = .Adjustments(3)
        If Err.Number <> 0 Then
            ratio3 = -1
            Err.Clear
        End If
        ratio4 = .Adjustments(4)
        If Err.Number <> 0 Then
            ratio4 = 9 / .Height
            Err.Clear
        End If
        ratio5 = .Adjustments(5)
        If Err.Number <> 0 Then
            ratio5 = -0.08333334
            Err.Clear
        End If
        ratio6 = .Adjustments(6)
        If Err.Number <> 0 Then
            ratio6 = ratio4
        End If
        
        Vert(1).X = .Left + .Width * ratio1
        Vert(1).Y = .Top + .Height * ratio2
        
        Vert(2).X = .Left + .Width * ratio3
        Vert(2).Y = .Top + .Height * ratio4
        
        Vert(3).X = .Left + .Width * ratio5
        Vert(3).Y = .Top + .Height * ratio6
        
        If .Callout.Accent = msoTrue Then
            Vert(4).X = Vert(3).X
            Vert(4).Y = .Top
            Vert(5).X = Vert(3).X
            Vert(5).Y = .Top + .Height
        End If
    End With
End Sub

' a callout object in mlb is presented as a group
' there are 3 or 4 shapes in the group
' 1st:  line
' 2nd:  line
' 3rd:  if with Accent, line
'       with out Accent, Autoshape (normally Rect)
' 4th:  only when with Accent, Autoshape (normally Rect)
Private Sub ParseCalloutThree(shp As Shape)
    Dim arrh    As Boolean
    Dim arre    As Boolean
    Dim hasAccent As Boolean
    
    ShapeType = aofShapeTypeUserDefinedGroup
    HasGroupItem = True
    
    SetVertOfCalloutThree shp, hasAccent
    
    If hasAccent Then
        GroupItemNum = 4
    Else
        GroupItemNum = 3
    End If
    
    ReDim GroupItems(1 To GroupItemNum) As aofShape
    
    
    FlipNodes Vert, VertNum, shp
    NodesRotate shp.Rotation
    
    ' the arrow setting of the callout
    If shp.Line.BeginArrowheadStyle <> msoArrowheadNone Then
        arrh = True
    End If
    If shp.Line.EndArrowheadStyle <> msoArrowheadNone Then
        arre = True
    End If
        
    Set GroupItems(1) = New aofShape
    With GroupItems(1)
        .ShapeType = aofShapeTypeLine
        .SetLineArt shp
        .SetVerts Vert, 1, 2
        .BuildLineWithVert arrh, False
    End With
    
    Set GroupItems(2) = New aofShape
    With GroupItems(2)
        .ShapeType = aofShapeTypeLine
        .SetLineArt shp
        .SetVerts Vert, 2, 2
        .BuildLineWithVert False, arre
    End With
    
    If hasAccent Then
        Set GroupItems(3) = New aofShape
        With GroupItems(3)
            .ShapeType = aofShapeTypeLine
            .SetLineArt shp
            .ArrowStyle = "none"
            .SetVerts Vert, 4, 2
            .BuildLineWithVert False, arre
        End With
    End If
    
    Set GroupItems(GroupItemNum) = New aofShape
    With GroupItems(GroupItemNum)
'        .ParseTextBox shp
'        If shp.Callout.Border = msoFalse Then
'            .GraphStyle = .GraphStyle - aofGraphStyleOutline
'        End If
        .SetAsFourPointsRect shp
        
        If shp.Callout.Border = msoTrue Then
            If .GraphStyle = aofGraphStyleNone Or .GraphStyle = aofGraphStyleFilled Then
                .GraphStyle = aofGraphStyleOutline + .GraphStyle
            End If
        ElseIf shp.Callout.Border = msoFalse Then
            If .GraphStyle = aofGraphStyleOutline Or .GraphStyle = aofGraphStyleFilledOutline Then
                .GraphStyle = .GraphStyle - aofGraphStyleOutline
            End If
        End If
        
        If HasTextInShape(shp) Then
            .ContainText = True
            Set .TextInShape = New aofShape
            .TextInShape.SetAsText shp
        End If
    End With


End Sub

Public Sub SetVertOfCalloutFour(shp As Shape, ByRef hasAccent As Boolean)
    Dim ratio1  As Single
    Dim ratio2  As Single
    Dim ratio3  As Single
    Dim ratio4  As Single
    Dim ratio5  As Single
    Dim ratio6  As Single
    Dim ratio7  As Single
    Dim ratio8  As Single

    If shp.Callout.Accent = msoTrue Then
        hasAccent = True
'        GroupItemNum = 5
        VertNum = 6
    Else
        hasAccent = False
'        GroupItemNum = 4
        VertNum = 4
    End If
    
    ReDim Vert(1 To VertNum) As aofNode
    
    With shp
        On Error Resume Next
        ratio1 = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio1 = -3
            Err.Clear
        End If
        ratio2 = .Adjustments(2)
        If Err.Number <> 0 Then
            ratio2 = -4
            Err.Clear
        End If
        ratio3 = .Adjustments(3)
        If Err.Number <> 0 Then
            ratio3 = 3
            Err.Clear
        End If
        ratio4 = .Adjustments(4)
        If Err.Number <> 0 Then
            ratio4 = -2
            Err.Clear
        End If
        ratio5 = .Adjustments(5)
        If Err.Number <> 0 Then
            ratio5 = ratio3
            Err.Clear
        End If
        ratio6 = .Adjustments(6)
        If Err.Number <> 0 Then
            ratio6 = 9 / .Height
        End If
        
        ratio7 = .Adjustments(7)
        If Err.Number <> 0 Then
            ratio7 = 6 / .Width
            Err.Clear
        End If
        ratio8 = .Adjustments(8)
        If Err.Number <> 0 Then
            ratio8 = ratio6
        End If
        
        Vert(1).X = .Left + .Width * ratio1
        Vert(1).Y = .Top + .Height * ratio2
        
        Vert(2).X = .Left + .Width * ratio3
        Vert(2).Y = .Top + .Height * ratio4
        
        Vert(3).X = .Left + .Width * ratio5
        Vert(3).Y = .Top + .Height * ratio6
        
        Vert(3).X = .Left + .Width * ratio5
        Vert(3).Y = .Top + .Height * ratio6
        
        Vert(4).X = .Left + .Width * ratio7
        Vert(4).Y = .Top + .Height * ratio8
        
        If .Callout.Accent = msoTrue Then
            Vert(5).X = Vert(4).X
            Vert(5).Y = .Top
            Vert(6).X = Vert(4).X
            Vert(6).Y = .Top + .Height
        End If
    End With
End Sub
Private Sub ParseCalloutFour(shp As Shape)
    Dim arrh    As Boolean
    Dim arre    As Boolean
    Dim hasAccent As Boolean
    
    
    ShapeType = aofShapeTypeUserDefinedGroup
    HasGroupItem = True
    
    SetVertOfCalloutFour shp, hasAccent
    
    If hasAccent Then
        GroupItemNum = 5
    Else
        GroupItemNum = 4
    End If
    
    ReDim GroupItems(1 To GroupItemNum) As aofShape
    
    FlipNodes Vert, VertNum, shp
    NodesRotate shp.Rotation
    
    If shp.Line.BeginArrowheadStyle <> msoArrowheadNone Then
        arrh = True
    End If
    If shp.Line.EndArrowheadStyle <> msoArrowheadNone Then
        arre = True
    End If
        
    Set GroupItems(1) = New aofShape
    With GroupItems(1)
        .ShapeType = aofShapeTypeLine
        .SetLineArt shp
        .SetVerts Vert, 1, 2
        .BuildLineWithVert arrh, False
    End With
    
    Set GroupItems(2) = New aofShape
    With GroupItems(2)
        .ShapeType = aofShapeTypeLine
        .SetLineArt shp
        .SetVerts Vert, 2, 2
        .BuildLineWithVert False, False
    End With
    
    Set GroupItems(3) = New aofShape
    With GroupItems(3)
        .ShapeType = aofShapeTypeLine
        .SetLineArt shp
        .SetVerts Vert, 3, 2
        .BuildLineWithVert False, arre
    End With
    
    If hasAccent Then
        Set GroupItems(4) = New aofShape
        With GroupItems(4)
            .ShapeType = aofShapeTypeLine
            .SetLineArt shp
            .SetVerts Vert, 5, 2
            .BuildLineWithVert False, arre
        End With
    End If
    
    Set GroupItems(GroupItemNum) = New aofShape
    With GroupItems(GroupItemNum)
        .SetAsFourPointsRect shp
        
        If shp.Callout.Border = msoTrue Then
            If .GraphStyle = aofGraphStyleNone Or .GraphStyle = aofGraphStyleFilled Then
                .GraphStyle = aofGraphStyleOutline + .GraphStyle
            End If
        ElseIf shp.Callout.Border = msoFalse Then
            If .GraphStyle = aofGraphStyleOutline Or .GraphStyle = aofGraphStyleFilledOutline Then
                .GraphStyle = .GraphStyle - aofGraphStyleOutline
            End If
        End If
        
        If HasTextInShape(shp) Then
            .ContainText = True
            Set .TextInShape = New aofShape
            .TextInShape.SetAsText shp
        End If
    End With


End Sub

Sub ParseTextBox(shp As Shape, Optional hasText As Boolean = False)
    
    SetSize shp
    
    With shp
        If .Fill.Visible = msoTrue Then
            If .Fill.Type <> msoFillSolid Then
                If hasText Then
                    SetAsImageWithTextInShape shp
                Else
                    SetAsImage shp
                End If
                Exit Sub
            End If
            GraphStyle = aofGraphStyleFilled
            SetFillArt shp
            LineColor = FillColor
        End If
        If .Line.Visible = msoTrue Then
            GraphStyle = GraphStyle + aofGraphStyleOutline
            SetLineArt shp
        End If
    End With
    
    SetAsText shp
    
End Sub

Private Sub ParsePolygon(shp As Shape, hasText As Boolean, Optional bRotateNodes As Boolean = True)
    
    SetAsPolygon shp, False, bRotateNodes
    
    If hasText Then
        Set TextInShape = New aofShape
        TextInShape.SetAsText shp
    End If
End Sub

Private Sub ParseImage(shp As Shape)
    SetAsImage shp
    ConvertToPNG
End Sub

Sub SetAsImage(shp As Shape, Optional bConvWMFtoPNG As Boolean = True, Optional iDelTrans As Integer = 1)

    ShapeType = aofShapeTypeImage
    
    SetSize shp
    
    If Not CvtOpt.WithImageSize Then
        Width = 0
        Height = 0
    End If
    
    On Error GoTo ExpError:
    With CvtOpt
        If OutputGIF Or ThreeDAsGIF Then
            ImageFileName = .ImgFileNamePrefix & "_s" _
                        & CurPageNumber & "p" & Position & ".gif"
            'Call shp.Export(.WBFilePath & ImageFileName, ppShapeFormatGIF)
            MyExport shp, .WBFilePath & ImageFileName, "gif"
        Else
            ImageFileName = .ImgFileNamePrefix & "_s" _
                        & CurPageNumber & "p" & Position & .ExpImageSuffix
            'Call shp.Export(.WBFilePath & ImageFileName, ppShapeFormatGIF)
            MyExport shp, .WBFilePath & ImageFileName, Mid(.ExpImageSuffix, 2, 3)
        End If
    End With
   
    Exit Sub
ExpError:
    If Err.Number = -2147467259 Then
        CvtOpt.FailInfo = Err.Number 'Err.Description
        'MsgBox Err.Description
        CvtOpt.Failed = True
    End If
    Resume Next
End Sub

Sub MyExport(shp As Shape, FileName As String, FilterName As String)
   ' MsgBox FileName
   Dim tmpShp As ShapeRange
   
   On Error Resume Next
   shp.Copy
   Set tmpShp = GlobalTempSlide.Shapes.Paste()
   
   GlobalTempSlide.Export FileName, Right(FilterName, 3)
   
'    If Err.Number = -2147467259 Then
'        CvtOpt.Failed = True
'    End If
'    CvtOpt.FailInfo = Err.Number
   
   tmpShp.Delete
   Set tmpShp = Nothing
   Err.Clear
End Sub

Private Sub ParseGroup(shp As Shape)
    Dim i As Long
    Dim j As Long
    Dim shpRgn As ShapeRange
    
    ShapeType = aofShapeTypeGroup
    HasGroupItem = True
    
    ' duplicate a gourp
    Dim tmpGrp As ShapeRange
    shp.Copy
    With ActivePresentation.Slides(CurPageNumber).Shapes '.Slides(1).Shapes
        Set tmpGrp = .Paste()
        tmpGrp.Top = shp.Top
        tmpGrp.Left = shp.Left
    End With
    
    GroupItemNum = tmpGrp.GroupItems.Count
    
    If GroupItemNum < 1 Then
        Exit Sub
    End If
    
    ReDim GroupItems(1 To GroupItemNum) As aofShape
    
    ' at first, ungroup
    Set shpRgn = tmpGrp.Ungroup
    
    i = 1   ' number of visible shapes
    j = 1   ' index of ppt shapes
    
    Do
        Set GroupItems(i) = New aofShape
        GroupItems(i).Perform shpRgn(j)
        If GroupItems(i).Invisible = False Then
            i = i + 1
        End If
        j = j + 1
    Loop Until j > shpRgn.Count
    
    GroupItemNum = i - 1
    
    shpRgn.Delete
    
    Set shpRgn = Nothing
    Set tmpGrp = Nothing

End Sub

Public Sub PerformAtom(txtSeg As TextRange, tr As TextRange, para As Long, maxFntSize As Single)
    Dim tmp     As aofTextItem
    Dim SpcWithin As Single
    
    With txtSeg
    
        ShapeType = aofShapeTypeText
        TextShapeType = aofTextShapeTypeAtom
        
        ParaIndex = para
        X = .BoundLeft
        
        If .ParagraphFormat.LineRuleWithin Then
            ' the spacewithin depends on the max font size in the line.
            Y = .BoundTop + .ParagraphFormat.SpaceWithin * maxFntSize   '.Font.Size
        Else
            Y = .BoundTop + .ParagraphFormat.SpaceWithin
        End If
        
        Width = .BoundWidth
        Height = .BoundHeight
            
        TextIndentLevel = .IndentLevel
        HasTextItem = True
        TextItemNum = 1
         
        If tr.Length < 1 Then
            Exit Sub
        End If
        
        ReDim TextItems(1 To tr.Length) As aofTextItem       ' reach the maximum
        
        Set TextItems(TextItemNum) = New aofTextItem
        TextItems(TextItemNum).Perform txtSeg
        
    End With
End Sub

Public Sub SetNewAnchor(shp As Shape, Optional UseUserDefinedSize As Boolean = False)
    
    Dim l As Single
    Dim r As Single
    Dim t As Single
    Dim b As Single
    
    Dim dummy As Boolean
    
    Select Case shp.Type
        Case MsoShapeType.msoCallout
            Select Case shp.Callout.Type
                Case MsoCalloutType.msoCalloutOne, MsoCalloutType.msoCalloutTwo
                    SetVertOfCalloutTwo shp, dummy
                Case MsoCalloutType.msoCalloutThree
                    SetVertOfCalloutThree shp, dummy
                Case MsoCalloutType.msoCalloutFour
                    SetVertOfCalloutFour shp, dummy
            End Select
'        Case MsoShapeType.msoAutoShape
'            Select Case shp.AutoShapeType
'                Case MsoAutoShapeType.msoShapeRectangularCallout, MsoAutoShapeType.msoShapeRoundedRectangularCallout
'            End Select
    End Select
    
    VertNum = VertNum + 4
    ReDim Preserve Vert(1 To VertNum) As aofNode
    
    If UseUserDefinedSize Then
        Vert(VertNum - 3).X = X
        Vert(VertNum - 3).Y = Y
        Vert(VertNum - 2).X = X + Width
        Vert(VertNum - 2).Y = Y
        Vert(VertNum - 1).X = X
        Vert(VertNum - 1).Y = Y + Height
        Vert(VertNum).X = X + Width
        Vert(VertNum).Y = Y + Height
    Else
        Vert(VertNum - 3).X = shp.Left
        Vert(VertNum - 3).Y = shp.Top
        Vert(VertNum - 2).X = shp.Left + shp.Width
        Vert(VertNum - 2).Y = shp.Top
        Vert(VertNum - 1).X = shp.Left
        Vert(VertNum - 1).Y = shp.Top + shp.Height
        Vert(VertNum).X = shp.Left + shp.Width
        Vert(VertNum).Y = shp.Top + shp.Height
        SetSize shp         'important!  necessary in nodesrotate
    End If
    
    NodesRotate shp.Rotation
        
    l = Vert(1).X
    r = Vert(1).X
    t = Vert(1).Y
    b = Vert(1).Y
    
    Dim i As Long
    For i = 2 To VertNum
        If l > Vert(i).X Then
            l = Vert(i).X
        ElseIf r < Vert(i).X Then
            r = Vert(i).X
        End If
        If t > Vert(i).Y Then
            t = Vert(i).Y
        ElseIf b < Vert(i).Y Then
            b = Vert(i).Y
        End If
    Next
    
    X = CLng(l)
    Y = CLng(t)
    
    If CvtOpt.WithImageSize Then
        Width = r - l
        Height = b - t
    Else
        Width = 0
        Height = 0
    End If
    
    VertNum = 0
    Erase Vert
End Sub

Public Sub NewSetNewAnchor(shp As Shape, Optional UseUserDefinedSize As Boolean = False)
    
    Dim l As Single
    Dim r As Single
    Dim t As Single
    Dim b As Single
    
    SetShapeVertices shp
    NewRotateNodes shp
        
    l = Vert(1).X
    r = Vert(1).X
    t = Vert(1).Y
    b = Vert(1).Y
    
    Dim i As Long
    For i = 2 To VertNum
        If l > Vert(i).X Then
            l = Vert(i).X
        ElseIf r < Vert(i).X Then
            r = Vert(i).X
        End If
        If t > Vert(i).Y Then
            t = Vert(i).Y
        ElseIf b < Vert(i).Y Then
            b = Vert(i).Y
        End If
    Next
    
    X = CLng(l)
    Y = CLng(t)
    
    If CvtOpt.WithImageSize Then
        Width = r - l
        Height = b - t
    Else
        Width = 0
        Height = 0
    End If
    
    VertNum = 0
End Sub

Sub SetAsText(shp As Shape)
    
    'On Error Resume Next
    Dim strScript       As String
    Dim bIsParaHead     As Boolean
    Dim paraNum         As Long
    Dim cntObj          As Long
    Dim tr              As TextRange
    Dim i               As Long
    Dim totalParaNum    As Long
    
    ShapeType = aofShapeTypeTextGroup
    Invisible = False
    
    With shp.AnimationSettings
        If .Animate = msoTrue Then
            Select Case .TextLevelEffect
                Case ppAnimateByAllLevels, ppAnimateLevelMixed, ppAnimateLevelNone
                Case Else
                    HasSubAnim = True
                    SubAnimOrder = .TextLevelEffect
                    If .AnimateTextInReverse Then
                        AnimInReverse = True
                    End If
            End Select
        End If
    End With
    
    'cntObj = 0
    bIsParaHead = True
    paraNum = 1
    
    With shp.TextFrame.TextRange
        GroupItemNum = .Lines.Count * 3
        
        If GroupItemNum < 1 Then
            GroupItemNum = 1
            HasGroupItem = True
            ReDim GroupItems(1 To GroupItemNum) As aofShape
            Set GroupItems(1) = New aofShape
            GroupItems(1).SetBlankText
            Exit Sub
        End If
        
        HasGroupItem = True
        
        ReDim GroupItems(1 To GroupItemNum) As aofShape
        
        totalParaNum = .Paragraphs.Count
        
        'For Each tr In .Lines
        'For Each tr In .Paragraphs
        For i = 1 To totalParaNum - 1
            
            Set tr = .Paragraphs(i)
            'ParseTextLine tr, bIsParaHead, cntObj, paraNum
            
            ParseTextParagraph tr, bIsParaHead, cntObj, paraNum
        Next
        
        
        ' the last paragraph
        Set tr = .Paragraphs(totalParaNum)
        If tr.Text = "" Or (tr.Length = 1 And tr.Text = Chr$(13) & Chr$(10)) Then
            ' an empty paragraph
        Else
            ' if the bullet should be converted as image,
            ' add an empty line in the end of text, in order to
            ' extract the bullet of the last line.
            If Not BulletIsText(tr) Then
                tr.InsertAfter vbNewLine
                ParseTextParagraph tr, bIsParaHead, cntObj, paraNum, True
            Else
                ParseTextParagraph tr, bIsParaHead, cntObj, paraNum, False
            End If
        ' the inserted "vbNewLine" should be deleted RIGHT after "PerformBullet" in function ParseTextparagragh
        End If
        
        If GroupItemNum > cntObj Then
            GroupItemNum = cntObj
            
            If GroupItemNum > 0 Then
                ReDim Preserve GroupItems(1 To GroupItemNum) As aofShape
            End If
        End If
        
    End With

    If TextHasShadow(shp) Then
        HasTextShadow = True
        ShadowOffX = shp.Shadow.OffsetX
        ShadowOffY = shp.Shadow.OffsetY
        ShadowColor = MLBColor(shp.Shadow.ForeColor)
        SetShadowStatus
    End If

End Sub

Private Function TextHasShadow(shp As Shape) As Boolean
'--- deprecated---
'    If HasShadow(shp) Then
'        ' if the shape is not filled. the shadow applies to the text within the shape
'        If shp.Fill.Visible = msoFalse Then
'            TextHasShadow = True
'        Else
'            TextHasShadow = False
'        End If
'    Else
'        TextHasShadow = False
'    End If
    Select Case shp.Shadow.Type
        Case msoShadow1, msoShadow2, msoShadow5, msoShadow6, msoShadow14
            TextHasShadow = True
        Case Else
            TextHasShadow = False
    End Select
End Function

Public Sub SetShadowStatus()
    Dim i As Long
    If HasGroupItem Then
        For i = 1 To GroupItemNum
            With GroupItems(i)
                .HasTextShadow = HasTextShadow
                .ShadowOffX = ShadowOffX
                .ShadowOffY = ShadowOffY
                .ShadowColor = ShadowColor
                .SetShadowStatus
            End With
        Next
    End If
End Sub

Private Function GetMaxFontSize(tr As TextRange) As Single
    Dim i As Long
    Dim c As TextRange
    Dim fntSize As Single
    
    If tr.Length < 1 Then
        GetMaxFontSize = 0
        Exit Function
    End If
    GetMaxFontSize = tr.Characters(1).Font.Size
    For i = 2 To tr.Length
        'fntSize = tr.Characters(i).Font.Size
        Set c = tr.Characters(i)
        Select Case AscW(c)
            Case 11, 13
            Case Else
                fntSize = c.Font.Size
                If fntSize > GetMaxFontSize Then
                    GetMaxFontSize = fntSize
                End If
        End Select
    Next
    Set c = Nothing
End Function

' if this is the last paragraph, a linefeed should be added at the end of text range,
' this line feed should be removed before converting the text.
' "bRemoveLastChr" is true, if the line feed was added (in function SetAsText())
Private Sub ParseTextParagraph(trPara As TextRange, ByRef bIsParaHead As Boolean, ByRef cntObj As Long, ByRef paraNum As Long, Optional bRemoveLastChr As Boolean = False)

    Dim txtSeg          As TextRange
    Dim start           As Long
    Dim chrLen          As Long
    Dim bReachedLineEnd As Boolean
    Dim bTabBegin       As Boolean
    Dim bIsFirstSeg     As Boolean
    Dim bSpecialChr     As Boolean
    Dim MaxFontSize     As Single
    Dim GroupItemCount  As Long
    
    Dim tr As TextRange
    Dim j As Long
    
    If Len(trPara.Text) = 0 Then
        Exit Sub
    End If
    
    ' test if there is a bullet
    With trPara
        If .ParagraphFormat.Bullet.Visible = msoFalse Or .Length = 0 _
            Or (.Length = 1 And .Text = Chr$(13) & Chr$(10)) Then
        Else
            cntObj = cntObj + 1
            GroupItemCount = UBound(GroupItems)
            If cntObj > GroupItemCount Then           ' ensure the array is large enough
                GroupItemCount = GroupItemCount + aofItemInc
                ReDim Preserve GroupItems(1 To GroupItemCount) As aofShape
            End If
            
            MaxFontSize = GetMaxFontSize(trPara.Lines(1))
            Set GroupItems(cntObj) = New aofShape
            GroupItemNum = cntObj
            GroupItems(cntObj).PerformBullet trPara, paraNum, MaxFontSize   ' here paraNum is no longer useful
        End If
        
        ' remove the last linefeed that was added in "SetAsText"
        If bRemoveLastChr Then
            .Characters(.Length, 1).Delete
        End If
    End With
    
    
    For j = 1 To trPara.Lines.Count
        
        Set tr = trPara.Lines(j)
        MaxFontSize = GetMaxFontSize(tr)
        
        bIsFirstSeg = True
        start = 1
        Do      ' begin to convert text
            Set txtSeg = FindTextSegment(tr, start, chrLen, bReachedLineEnd, bTabBegin, bSpecialChr)
            
            If chrLen <= 0 Then
                'Invisible = True
                If cntObj > 0 Then
                    GroupItems(cntObj).ClearItems
                End If
                Exit Do
'                Exit Sub
            End If
            
            start = start + chrLen
            With txtSeg
                If bSpecialChr Then
                    cntObj = cntObj + 1
                    If cntObj > GroupItemNum Then           ' ensure the array is large enough
                        GroupItemNum = GroupItemNum + aofItemInc
                        ReDim Preserve GroupItems(1 To GroupItemNum) As aofShape
                    End If
                        
                    If cntObj > 1 Then
                        GroupItems(cntObj - 1).ClearItems
                    End If
                    
                    Set GroupItems(cntObj) = New aofShape
                    
                    GroupItems(cntObj).ExportTextrangeAsImage txtSeg
                    
                    bIsFirstSeg = True
                Else
                    If bIsFirstSeg Or (bTabBegin And txtSeg.Text <> "") Then
                        
                        cntObj = cntObj + 1
                        If cntObj > GroupItemNum Then           ' ensure the array is large enough
                            GroupItemNum = GroupItemNum + aofItemInc
                            ReDim Preserve GroupItems(1 To GroupItemNum) As aofShape
                        End If
                            
                        If cntObj > 1 Then
                            GroupItems(cntObj - 1).ClearItems
                        End If
                        
                        Set GroupItems(cntObj) = New aofShape
                        
                        GroupItems(cntObj).PerformAtom txtSeg, tr, paraNum, MaxFontSize
                        GroupItems(cntObj).SetReplaceText StrDate, StrFooter, StrSlideNumber
                        
                        bIsFirstSeg = False
                        
                    Else
                        GroupItems(cntObj).InsertAsTextItem txtSeg
                    End If
                End If      'bSpecialChr
            End With
        Loop Until bReachedLineEnd
    Next
    
    If cntObj < 1 Then
        HasGroupItem = False
        GroupItemNum = 0
        Erase GroupItems
    Else
        GroupItems(cntObj).ClearItems
    End If
    
    If tr.Length = 0 Then
        bIsParaHead = True
        paraNum = paraNum + 1
    ElseIf Asc(Mid(tr.Text, tr.Length, 1)) = 13 Then    ' a paragraph is ended by a linefeed
        bIsParaHead = True
        paraNum = paraNum + 1
    Else
        bIsParaHead = False
    End If
    
    Set tr = Nothing
End Sub

Sub ExportTextrangeAsImage(tr As TextRange)
    Dim tmpShp As Shape
    
    ShapeType = aofShapeTypeImage
    With tr
        X = .BoundLeft
        Y = .BoundTop
        
        Set tmpShp = GlobalPres.Slides(1).Shapes.AddTextbox _
            (msoTextOrientationHorizontal, 0, 0, .BoundWidth * 1.2, .BoundHeight)
        
    End With
    
    tr.Copy
    With tmpShp.TextFrame
        .TextRange.Paste
        '.TextRange.ParagraphFormat.Bullet.Type = ppBulletNone
        .WordWrap = msoFalse
        .MarginLeft = 0
        .MarginRight = 0
        .MarginTop = 0
'        .MarginBottom = 0
        With .TextRange.ParagraphFormat
            .LineRuleAfter = tr.ParagraphFormat.LineRuleAfter
            .SpaceAfter = tr.ParagraphFormat.SpaceAfter
            .LineRuleBefore = tr.ParagraphFormat.LineRuleBefore
            .SpaceBefore = tr.ParagraphFormat.SpaceBefore
            .LineRuleWithin = tr.ParagraphFormat.LineRuleWithin
            .SpaceWithin = tr.ParagraphFormat.SpaceWithin
        End With
    End With
    
    If CvtOpt.WithImageSize Then
        Width = tmpShp.Width
        Height = tmpShp.Height
    Else
        Width = 0
        Height = 0
    End If
    
    On Error GoTo ExpError:
    With CvtOpt
        If OutputGIF Then
            ImageFileName = .ImgFileNamePrefix & "_s" _
                        & CurPageNumber & "p" & Position & ".gif"
            'tmpShp.Export .WBFilePath & ImageFileName, ppShapeFormatGIF
            MyExport tmpShp, .WBFilePath & ImageFileName, "gif"
        Else
            ImageFileName = .ImgFileNamePrefix & "_s" _
                        & CurPageNumber & "p" & Position & .ExpImageSuffix '".gif"
            'tmpShp.Export .WBFilePath & ImageFileName, .ExpImageFormat
            MyExport tmpShp, .WBFilePath & ImageFileName, .ExpImageSuffix
        End If
    End With
    
    tmpShp.Delete
    Set tmpShp = Nothing

    Exit Sub
    
ExpError:
    If Err.Number = -2147467259 Then
        CvtOpt.FailInfo = Err.Number 'Err.Description
        'MsgBox Err.Description
        CvtOpt.Failed = True
    End If
    Resume Next
End Sub

Sub SetBlankText()
    ShapeType = aofShapeTypeText
    HasTextItem = True
    TextItemNum = 1
    ReDim TextItems(1 To 1) As aofTextItem
    Set TextItems(1) = New aofTextItem
    
End Sub

Private Function FindTextSegment(ByVal tr As TextRange, start As Long, chrLen As Long, _
            bReachedLineEnd As Boolean, bTabBegin As Boolean, bSpecialChr As Boolean) As TextRange
    Dim i           As Long
    Dim firstFnt    As Font
    Dim curFnt      As Font
    Dim bNoChr      As Boolean
    Dim chrVal      As Integer
    Dim bIsSpecial  As Boolean
    Dim curText     As TextRange
    
    bNoChr = True
    bTabBegin = False
    bReachedLineEnd = True
    
    For i = start To tr.Length
        If Asc(tr.Characters(i).Text) <> 9 Then     ' tabstop
            bNoChr = False
            Exit For
        Else
            bTabBegin = True
        End If
    Next
    
    If bNoChr Then          ' all the chars are tabstops
        'Set FindTextSegment = ""
        chrLen = 0
        Exit Function
    End If
    
    start = i
        
    If tr.Length >= start Then
        ' determine the first character
        Set curText = tr.Characters(start, 1)
        'chrVal = AscW(tr.Characters(start, 1).Text)      ' one character
        chrVal = AscW(curText.Text)
        
        If IsSpecialChr(chrVal) Or IsMathFont(curText) Then
            bSpecialChr = True
        Else
            bSpecialChr = False
            Set firstFnt = tr.Characters(start).Font
        End If
    
        For i = start + 1 To tr.Length
            Set curText = tr.Characters(i, 1)
            With curText                'tr.Characters(i, 1)
                chrVal = AscW(.Text)
                Set curFnt = .Font
            End With
            
            bIsSpecial = (IsSpecialChr(chrVal) Or IsMathFont(curText))
            If (bIsSpecial <> bSpecialChr) Then     ' segment end
                    bReachedLineEnd = False
                    Exit For
            Else
                If Not bSpecialChr Then                 ' ascii character, continue
                    If Not IsSameFontsetting(firstFnt, curFnt) Or chrVal = 9 Then   'Or Asc(tr.Characters(i).Text) = 9 Then
                            bReachedLineEnd = False
                        Exit For
                    End If
                End If
            End If
        Next
        chrLen = i - start
    Else
        chrLen = 1
    End If
    
    Set FindTextSegment = tr.Characters(start, chrLen)

End Function
 
'asc : unicode
'   128 : 8364
'
'   130 : 8218
'   131 : 402
'   132 : 8222
'   133 : 8230
'   134 : 8224
'   135 : 8225
'   136 : 710
'   137 : 8240
'   138 : 352
'   139 : 8249
'   140 : 338
'
'   142 : 381
'
'
'   145 : 8216
'   146 : 8217
'   147 : 8220
'   148 : 8221
'   149 : 8226
'   150 : 8211
'   151 : 8212
'   152 : 732
'   153 : 8482
'   154 : 353
'   155 : 8250
'   156 : 339
'
'   158 : 382
'   159 : 376
' these characters are legal ASCII
Private Function IsSpecialChr(val As Integer) As Boolean
    Select Case val
        Case 8364, 8218, 402, 8222, 8230, 8224, 8225, _
             710, 8240, 352, 8249, 338, 381, 8216, _
             8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, _
             353, 8250, 339, 382, 376
                 IsSpecialChr = False
        Case Else
            If val > 255 Or val < 0 Then
                IsSpecialChr = True
            Else
                IsSpecialChr = False
            End If
    End Select
End Function

Private Function IsMathFont(tr As TextRange) As Boolean
    If InStr(1, tr.Font.Name, "Math", vbTextCompare) > 0 Then
        IsMathFont = True
    Else
        IsMathFont = False
    End If
End Function
 
Private Function IsSameFontsetting(fstFnt As Font, fnt As Font) As Boolean
    If fstFnt.Bold <> fnt.Bold Or _
        fstFnt.Italic <> fnt.Italic Or _
        fstFnt.Color.RGB <> fnt.Color.RGB Or _
        fstFnt.NameAscii <> fnt.NameAscii Or _
        fstFnt.Size <> fnt.Size Or _
        fstFnt.Subscript <> fnt.Subscript Or _
        fstFnt.Superscript <> fnt.Superscript Then
            IsSameFontsetting = False
    Else
            IsSameFontsetting = True
    End If
End Function

Sub ClearItems()
    If TextItemNum > 0 Then
        ReDim Preserve TextItems(1 To TextItemNum) As aofTextItem
    End If
End Sub

Sub InsertAsTextItem(txtSeg As TextRange)
    TextItemNum = TextItemNum + 1
    Set TextItems(TextItemNum) = New aofTextItem
    TextItems(TextItemNum).Perform txtSeg
End Sub

Sub PerformBulletAsText(tr As TextRange, para As Long, maxFntSize As Single)
    Dim fntSize     As Long
    Dim OffX        As Long
    Dim OffY        As Long
    Dim tf          As TextFrame
    Dim boffx       As Long         ' the offset of bullet to the shape border

    ShapeType = aofShapeTypeText
    TextShapeType = aofTextShapeTypeBullet

    ParaIndex = para
    TextItemNum = 1
    ReDim TextItems(1 To 1) As aofTextItem

    ' we must do so because sometims the tr.ParagraphFormat.Bullet.Font.Size = -2
    fntSize = CLng(tr.ParagraphFormat.Bullet.RelativeSize _
                * tr.Characters(1, 1).Font.Size)

    Set tf = tr.Parent

    ' in fact, if no indent, IndentLevel = -2 (0xFFFFFFFE)
    ' PowerPoint support 5 indent levels.
    If tr.IndentLevel < 1 Or tr.IndentLevel > 5 Then
        OffX = 0
    Else
        If tr.ParagraphFormat.Alignment = ppAlignLeft Then
            ' if the text aligns to left, we can get the bullet's absolut position.
            ' And we can always get the absolute position of the TextRange.
            ' So, in this case, OffX is accurate. Both Bullet position and Text Position
            ' are accurate.
            boffx = IIf(tf.Ruler.Levels(tr.IndentLevel).FirstMargin < tf.Ruler.Levels(tr.IndentLevel).LeftMargin, _
                    tf.Ruler.Levels(tr.IndentLevel).FirstMargin, tf.Ruler.Levels(tr.IndentLevel).LeftMargin)

            OffX = tf.Parent.Left + tf.MarginLeft + boffx - tr.BoundLeft
        Else
            ' If the text aligns to right or middle, we can not get the bullets's absolut
            ' position. In this Case, OffX is the distance between the LeftMargin and FirstMargin,
            ' theoretically, the distance between the bullet and the first character.
            OffX = tf.Ruler.Levels(tr.IndentLevel).LeftMargin - tf.Ruler.Levels(tr.IndentLevel).FirstMargin

            If OffX > 0 Then
                OffX = -OffX
            End If

            ' But, if OffX < the "real width" of the bullet. The bullet and the text (in
            ' Assistant) may overlap each other.
            ' In PowerPoint, even if the OffX < the width of the bullet, the bullet and the text
            ' won't overlap each other, because the text are shifted to fit the bullet.
            ' For us, the problem is, we do not know the exact width of the bullet, so that
            ' we cannot avoid the possible overlapping.
            ' We suppose that the bullet width is 60% of its height:
            Dim tmpBullet As Shape
            Dim tmpstr As String
            Set tmpBullet = GlobalTempSlide.Shapes.AddTextbox(msoTextOrientationHorizontal, 0, 0, 100, 100)
            With tmpBullet.TextFrame.TextRange
                tmpstr = ChrW(tr.ParagraphFormat.Bullet.Character)
                .Text = tmpstr
                .Font.Size = tr.ParagraphFormat.Bullet.Font.Size
                If tr.ParagraphFormat.Bullet.UseTextFont = msoTrue Then
                    .Font.Name = tr.ParagraphFormat.Bullet.Font.NameAscii
                Else
                .Font.Name = tr.ParagraphFormat.Bullet.Font.Name
                End If
                .Font.Bold = tr.ParagraphFormat.Bullet.Font.Bold
                .Font.Italic = tr.ParagraphFormat.Bullet.Font.Italic
                OffX = -.BoundWidth
            End With
            tmpBullet.Delete
            Set tmpBullet = Nothing
            
            'If OffX >= -fntSize * 0.6 Then
            '    OffX = -fntSize * 0.6  ' shift left the width of the bullet.
            'End If
            ' In brief, if the OffX > the width of the bullet, the positions are accurate,
            ' otherwise, the position is not accurate.
        End If
    End If

    With tr

        X = .BoundLeft + OffX
        'y = .BoundTop + .Font.Size

        If .ParagraphFormat.SpaceWithin Then
            ' the spacewithin depends on the max font size in the line.
            Y = .BoundTop + .ParagraphFormat.SpaceWithin ' * maxFntSize   '.Font.Size
        Else
            Y = .BoundTop + .ParagraphFormat.SpaceWithin
        End If

        Width = .BoundWidth
        Height = .BoundHeight

        TextIndentLevel = .IndentLevel


    End With

    Set TextItems(1) = New aofTextItem
    TextItems(1).PerformAsBullet tr, fntSize, X

End Sub


Function BulletIsText(tr As TextRange) As Boolean

    With tr.ParagraphFormat.Bullet
        If .Visible = msoFalse Then
            BulletIsText = True
            Exit Function
        End If

        If Not IsSpecialChr(.Character) And IsSupportedFont(.Font) Then
            BulletIsText = True
        Else
            BulletIsText = False
        End If
    End With
    
End Function

Private Function IsSupportedFont(ft As Font) As Boolean
        IsSupportedFont = True
    'Dim fname As String
    'fname = ft.NameAscii
    'If InStr(1, fname, "Times", vbTextCompare) > 0 Then
    '    IsSupportedFont = True
    'ElseIf InStr(1, fname, "Arial", vbTextCompare) > 0 Then
    '    IsSupportedFont = True
    'ElseIf InStr(1, fname, "Courier", vbTextCompare) > 0 Then
    '    IsSupportedFont = True
    'ElseIf InStr(1, fname, "Symbol", vbTextCompare) > 0 Then
    '    IsSupportedFont = True
    'Else
    '    IsSupportedFont = False
    'End If
End Function

Sub PerformBullet(tr As TextRange, para As Long, maxFntSize As Single)
    
    If BulletIsText(tr.Characters(1, 1)) Then
        PerformBulletAsText tr.Characters(1, 1), para, maxFntSize
        Exit Sub
    End If
    
    ShapeType = aofShapeTypeImage
  
    bConvertToPNG = False
    ExtractBulletAsImage2 tr, ImageFileName, maxFntSize, Width, Height
        
    X = tr.Parent.Parent.Left
    Y = tr.BoundTop '+ .Parent.MarginTop '+ SpcBefore
End Sub


Private Function GetBulletImageName(shp As Shape) As String
    On Error Resume Next
    Dim bulName As String
    With shp.TextFrame
        With .TextRange.ParagraphFormat.Bullet
            bulName = .Font.Name & "_" & (.Font.Color.RGB) & "_" & .Character
        End With
        With .Ruler.Levels(.TextRange.IndentLevel)
            bulName = bulName & "_" & .FirstMargin & "_" & .LeftMargin
        End With
    End With
    
    bulName = bulName & "_" & CLng(shp.Width) & "_" & CLng(shp.Height)
    
    If shp.Shadow.Visible = msoTrue Then
        bulName = bulName & "_shd_" & shp.Shadow.Type
    Else
        bulName = bulName & "_noshd"
    End If
    
    If OutputGIF Then
        bulName = bulName & ".gif"
    Else
        bulName = bulName & CvtOpt.ExpImageSuffix
    End If
    
    GetBulletImageName = bulName
End Function

Private Sub ExtractBulletAsImage2(tr As TextRange, imgPath As String, maxFntSize As Single, w As Single, h As Single)

    Dim tmpShp As Shape
    Dim txtFrm As TextFrame
    Dim tmpLevel As Long
    
    tr.Copy
    
    Set tmpShp = GlobalPres.Slides(1).Shapes.AddTextbox(msoTextOrientationHorizontal, 0, 0, 50, 50)
    Set txtFrm = tr.Parent
    
    tmpShp.Shadow.Visible = tr.Parent.Parent.Shadow.Visible
    
    With tmpShp.TextFrame
        .TextRange.Paste
        .TextRange.Text = "  "
        .TextRange.ParagraphFormat.Bullet.Font.Color.RGB = tr.ParagraphFormat.Bullet.Font.Color.RGB
        ' the second blank should have the maxFntSize to simulate the real textrange.
        .TextRange.Characters(2, 1).Font.Size = maxFntSize ' that's why the text contains 2 blanks.
        .WordWrap = msoFalse        ' make the new shape size to fit the text size.
        
        ' set the ruler:
        tmpLevel = IIf(tr.IndentLevel > 0, tr.IndentLevel, 1)
        With .Ruler.Levels(tmpLevel) '(tr.IndentLevel)
'            .FirstMargin = txtFrm.Ruler.Levels(tr.IndentLevel).FirstMargin
'            .LeftMargin = txtFrm.Ruler.Levels(tr.IndentLevel).LeftMargin
            .FirstMargin = txtFrm.Ruler.Levels(tmpLevel).FirstMargin
            .LeftMargin = txtFrm.Ruler.Levels(tmpLevel).LeftMargin
        End With
        
        .TextRange.ParagraphFormat.Alignment = tr.ParagraphFormat.Alignment
        
        If CvtOpt.WithImageSize Then
            w = .TextRange.BoundLeft + .TextRange.BoundWidth '+ .MarginRight
            h = .TextRange.BoundHeight
            
            If .TextRange.ParagraphFormat.Alignment <> ppAlignLeft Then
                .TextRange.ParagraphFormat.Alignment = ppAlignRight
'                offx = tr.BoundLeft - tr.Parent.Parent.Left - w
                tmpShp.Width = tr.BoundLeft - tr.Parent.Parent.Left + .TextRange.BoundWidth + .MarginLeft ' + .MarginRight
                w = tmpShp.Width
            End If
            
            tmpShp.Width = w
            tmpShp.Height = h
            tmpShp.Left = tr.Parent.Parent.Left '+ tmpShp.TextFrame.MarginLeft
            tmpShp.Top = tr.BoundTop - tmpShp.TextFrame.MarginTop
        Else
            w = 0
            h = 0
        End If
    End With
    
    imgPath = GetBulletImageName(tmpShp)
    
    On Error GoTo ExpError:
    If OutputGIF Then
      '  tmpShp.Export CvtOpt.WBFilePath & imgPath, ppShapeFormatGIF
        MyExport tmpShp, CvtOpt.WBFilePath & imgPath, "gif"
    Else
        'tmpShp.Export CvtOpt.WBFilePath & imgPath, CvtOpt.ExpImageFormat
        MyExport tmpShp, CvtOpt.WBFilePath & imgPath, CvtOpt.ExpImageSuffix
    End If
    
    tmpShp.Delete
    
    Set tmpShp = Nothing
    Exit Sub
ExpError:
    If Err.Number = -2147467259 Then
        CvtOpt.FailInfo = Err.Number 'Err.Description
        'MsgBox Err.Description
        CvtOpt.Failed = True
    End If
    Resume Next
End Sub

Private Sub ParseLine(shp As Shape)
    SetAsLine shp
End Sub

Sub SetAsLine(shp As Shape)
    
    ShapeType = aofShapeTypeLine
    
    ' modify the size.
    With shp
        If .HorizontalFlip = msoTrue Then
            X = X + Width
            Width = -Width
        End If
        If .VerticalFlip = msoTrue Then
            Y = Y + Height
            Height = -Height
        End If
        
        If .Rotation <> 0 Then
            HasVertices = True
            VertNum = 2
            ReDim Vert(1 To VertNum) As aofNode
            Vert(1).X = X
            Vert(1).Y = Y
            Vert(2).X = X + Width
            Vert(2).Y = Y + Height
            NodesRotate CLng(.Rotation)
            X = Vert(1).X
            Y = Vert(1).Y
            Width = Vert(2).X - Vert(1).X
            Height = Vert(2).Y - Vert(1).Y
        End If
    End With
    
    SetGraphmode shp
    
    If Invisible Then
        Exit Sub
    End If
    
    'SetLineArt shp
    
End Sub

Public Function ScriptTextShadow() As String
    Dim strScript As String
    Dim rStr        As String
    Dim i As Long
    
    If HasGroupItem Then
        For i = 1 To GroupItemNum
            strScript = strScript & GroupItems(i).ScriptTextShadow()
        Next
        ScriptTextShadow = strScript
        Exit Function
    End If
    
    If HasTextShadow Then
'        IncIndent
        If Not CvtOpt.NoGroup And TextItemNum > 1 Then
            strScript = NewLine() & "<GROUP>" '  name=""" & NameForAnim & """>"
            IncIndent
        End If
        For i = 1 To TextItemNum
            With TextItems(i)
                If InTemplateScript Then
                    rStr = ReplaceAutoTextField(.Text)
                    .Width = 0
                Else
                    rStr = .Text
                End If
                .Length = Len(rStr)
                
                If .Length > 0 Then
                    ' add text shadow
                    strScript = strScript & NewLine() & "<TEXT x=""" & CLng(.X + ShadowOffX) _
                            & """ y=""" & CLng(Y + .OffY + ShadowOffY) _
                            & """ width=""" & .Width _
                            & """ color=""" & ShadowColor _
                            & """ size=""" & .FontSize _
                            & """ family=""" & .Family _
                            & """ weight=""" & .Weight _
                            & """ slant=""" & .Slant _
                            & """ position=""" & .Position _
                            & """ length=""" & Len(rStr) _
                            & """ ZPosition=""" & ZPosition _
                            & """>" _
                            & NewLine() & "  """ & rStr & """" _
                            & NewLine() & "</TEXT>"
                End If
            End With
        Next
        If Not CvtOpt.NoGroup And TextItemNum > 1 Then
            DecIndent
            strScript = strScript & NewLine() & "</GROUP>"
        End If
'        DecIndent
    End If
    ScriptTextShadow = strScript
End Function

Public Function Script() As String
    Dim strScript       As String
    Dim i               As Long
    Dim rStr    As String
    
    If Invisible Then
        Script = ""
        Exit Function
    End If
    
    ' Shadows
    If HasShadowItem Then
        If Not CvtOpt.NoGroup Then
            IncIndent
            strScript = NewLine() & "<GROUP>" '  name=""" & NameForAnim & """>"
        End If
        For i = 1 To ShadowItemNum
            If Not ShadowItems(i).Invisible Then
                strScript = strScript & ShadowItems(i).Script()
            End If
        Next
        If Not CvtOpt.NoGroup Then
            strScript = strScript & NewLine() & "</GROUP>"
            DecIndent
        End If
    End If
    
    ' add text shadow
    If ContainText Then
        strScript = strScript & TextInShape.ScriptTextShadow()
    End If
    
    Select Case ShapeType
        Case aofShapeTypeLine
            IncIndent
            If ArrowStyle <> "none" Then
                strScript = strScript & """ arrowStyle=""" & ArrowStyle _
                        & """ arrowShape=""" & ArrowShape
            End If
            strScript = NewLine() & "<LINE x=""" & X _
                        & """ y=""" & Y _
                        & """ width=""" & CLng(Width) _
                        & """ height=""" & CLng(Height) _
                        & """ color=""" & LineColor _
                        & """ lineWidth=""" & LineWidth _
                        & """ lineStyle=""" & LineStyle _
                        & strScript _
                        & """ ZPosition=""" & ZPosition _
                        & """></LINE>"
'                        & """ name=""" & NameForAnim _

            DecIndent
            
        Case aofShapeTypeGroup
            If Not CvtOpt.NoGroup Then
                IncIndent
                strScript = NewLine() & "<GROUP>" '  name=""" & NameForAnim & """>"
            End If
            
            For i = 1 To GroupItemNum
                If Not GroupItems(i).Invisible Then
                    strScript = strScript & GroupItems(i).Script()
                End If
            Next
            
            If Not CvtOpt.NoGroup Then
                strScript = strScript & NewLine() & "</GROUP>"
                DecIndent
            End If
            
        Case aofShapeTypeText
            IncIndent
            If Not CvtOpt.NoGroup And TextItemNum > 1 Then
                strScript = NewLine() & "<GROUP>" '  name=""" & NameForAnim & """>"
                IncIndent
            End If
            For i = 1 To TextItemNum
                With TextItems(i)
                    'Dim rStr    As String
                    If InTemplateScript Then
                        rStr = ReplaceAutoTextField(.Text)
                        .Width = 0
                    Else
                        rStr = .Text
                    End If
                    .Length = Len(rStr)
                    
                    If .Length > 0 Then
' --- moved
'                        If HasTextShadow Then       ' add text shadow
'                            strScript = strScript & NewLine() & "<TEXT x=""" & CLng(.x + ShadowOffX) _
'                                    & """ y=""" & CLng(y + .OffY + ShadowOffY) _
'                                    & """ width=""" & .Width _
'                                    & """ color=""" & ShadowColor _
'                                    & """ size=""" & .FontSize _
'                                    & """ family=""" & .Family _
'                                    & """ weight=""" & .Weight _
'                                    & """ slant=""" & .Slant _
'                                    & """ position=""" & .Position _
'                                    & """ length=""" & Len(rStr) _
'                                    & """ ZPosition=""" & ZPosition _
'                                    & """>" _
'                                    & NewLine() & "  """ & rStr & """" _
'                                    & NewLine() & "</TEXT>"
'                        End If
                        
                        strScript = strScript & NewLine() & "<TEXT x=""" & CLng(.X) _
                                & """ y=""" & CLng(Y + .OffY) _
                                & """ width=""" & .Width _
                                & """ color=""" & .FontColor _
                                & """ size=""" & .FontSize _
                                & """ family=""" & .Family _
                                & """ weight=""" & .Weight _
                                & """ slant=""" & .Slant _
                                & """ position=""" & .Position _
                                & """ length=""" & Len(rStr) _
                                & """ ZPosition=""" & ZPosition _
                                & """>" _
                                & NewLine() & "  """ & rStr & """" _
                                & NewLine() & "</TEXT>"
                    End If
                End With
            Next
            If Not CvtOpt.NoGroup And TextItemNum > 1 Then
                DecIndent
                strScript = strScript & NewLine() & "</GROUP>"
            End If
            DecIndent
        Case aofShapeTypeRect
            If GraphStyle <> aofGraphStyleNone Then
                IncIndent
                
                strScript = NewLine() & "<RECTANGLE x=""" & CLng(X) _
                            & """ y=""" & CLng(Y) _
                            & """ width=""" & CLng(Width) _
                            & """ height=""" & CLng(Height) _
                            & """ color=""" & LineColor _
                            & """ fillColor=""" & FillColor _
                            & """ lineWidth=""" & LineWidth _
                            & """ lineStyle=""" & LineStyle _
                            & """ ZPosition=""" & ZPosition _
                            & """></RECTANGLE>"

                DecIndent
           End If
        Case aofShapeTypePolygon
            ' this is a polygon without outline. so the "color" is set to "fillColor"
            IncIndent
            
            If FillColor <> "none" Or LineColor <> "none" Then
                If GraphStyle = aofGraphStyleFilledOutline And Not CvtOpt.NoGroup Then
                    strScript = NewLine() & "<GROUP>" '  name=""" & NameForAnim & """>"
                    IncIndent
                End If
                
                If GraphStyle = aofGraphStyleFilled Then
                    strScript = strScript & NewLine() & "<POLYGON x=""" & CLng(X) _
                                & """ y=""" & CLng(Y) _
                                & """ width=""" & CLng(Width) _
                                & """ height=""" & CLng(Height) _
                                & """ color=""" & FillColor _
                                & """ fillColor=""" & FillColor _
                                & """ lineWidth=""" & LineWidth _
                                & """ lineStyle=""" & LineStyle _
                                & """ length=""" & Len(PointsString) _
                                & """ ZPosition=""" & ZPosition _
                                & """>" _
                                & NewLine() & "  """ & PointsString & """" _
                                & NewLine() & "</POLYGON>"
                ElseIf (GraphStyle = aofGraphStyleFilledOutline And IsClosedPolyline) Then
                    strScript = strScript & NewLine() & "<POLYGON x=""" & CLng(X) _
                                & """ y=""" & CLng(Y) _
                                & """ width=""" & CLng(Width) _
                                & """ height=""" & CLng(Height) _
                                & """ color=""" & LineColor _
                                & """ fillColor=""" & FillColor _
                                & """ lineWidth=""" & LineWidth _
                                & """ lineStyle=""" & LineStyle _
                                & """ length=""" & Len(PointsString) _
                                & """ ZPosition=""" & ZPosition _
                                & """>" _
                                & NewLine() & "  """ & PointsString & """" _
                                & NewLine() & "</POLYGON>"
                ElseIf GraphStyle = aofGraphStyleFilledOutline And Not IsClosedPolyline Then
                    strScript = strScript & NewLine() & "<POLYGON x=""" & CLng(X) _
                                & """ y=""" & CLng(Y) _
                                & """ width=""" & CLng(Width) _
                                & """ height=""" & CLng(Height) _
                                & """ color=""" & FillColor _
                                & """ fillColor=""" & FillColor _
                                & """ lineWidth=""" & LineWidth _
                                & """ lineStyle=""" & LineStyle _
                                & """ length=""" & Len(PointsString) _
                                & """ ZPosition=""" & ZPosition _
                                & """>" _
                                & NewLine() & "  """ & PointsString & """" _
                                & NewLine() & "</POLYGON>"
                    strScript = strScript & NewLine() & "<POLYLINE x=""" & CLng(X) _
                                & """ y=""" & CLng(Y) _
                                & """ width=""" & CLng(Width) _
                                & """ height=""" & CLng(Height) _
                                & """ color=""" & LineColor _
                                & """ lineWidth=""" & LineWidth _
                                & """ lineStyle=""" & LineStyle _
                                & """ arrowStyle=""" & ArrowStyle _
                                & """ arrowShape=""" & ArrowShape _
                                & """ length=""" & Len(PointsString) _
                                & """ ZPosition=""" & ZPosition _
                                & """>" _
                                & NewLine() & "  """ & PointsString & """" _
                                & NewLine() & "</POLYLINE>"
                ElseIf GraphStyle = aofGraphStyleOutline Then 'Or GraphStyle = aofGraphStyleFilledOutline Then
                    strScript = strScript & NewLine() & "<POLYLINE x=""" & CLng(X) _
                                & """ y=""" & CLng(Y) _
                                & """ width=""" & CLng(Width) _
                                & """ height=""" & CLng(Height) _
                                & """ color=""" & LineColor _
                                & """ lineWidth=""" & LineWidth _
                                & """ lineStyle=""" & LineStyle _
                                & """ arrowStyle=""" & ArrowStyle _
                                & """ arrowShape=""" & ArrowShape _
                                & """ length=""" & Len(PointsString) _
                                & """ ZPosition=""" & ZPosition _
                                & """>" _
                                & NewLine() & "  """ & PointsString & """" _
                                & NewLine() & "</POLYLINE>"
    '                            & """ name=""" & NameForAnim & "L"
                End If
                
                If GraphStyle = aofGraphStyleFilledOutline And Not CvtOpt.NoGroup Then
                    DecIndent
                    strScript = strScript & NewLine() & "</GROUP>"
                End If
            End If
            DecIndent
            
        Case aofShapeTypeCirc
            If GraphStyle <> aofGraphStyleNone Then
                IncIndent
                strScript = NewLine() & "<OVAL x=""" & CLng(X) _
                            & """ y=""" & CLng(Y) _
                            & """ width=""" & CLng(Width) _
                            & """ height=""" & CLng(Height) _
                            & """ color=""" & LineColor _
                            & """ fillColor=""" & FillColor _
                            & """ lineWidth=""" & LineWidth _
                            & """ lineStyle=""" & LineStyle _
                            & """ ZPosition=""" & ZPosition _
                            & """></OVAL>"
    '                        & """ name=""" & NameForAnim
                DecIndent
            End If
        Case aofShapeTypeImage
            
            IncIndent
            
            'strScript = NewLine() & "<IMAGE x=""" & CLng(X) & """ y=""" & CLng(Y) _
            '           & """ width=""" & CLng(Width) & """ height=""" & CLng(Height) _
            '           & """ filename=""" & ImageFileName & """ length=""0" _
            '           & """ ZPosition=""" & ZPosition _
            '           & """></IMAGE>"

            strScript = NewLine() & "<IMAGE x=0 y=0 width=""" & CLng(GlobalSlideWidth) _
                        & """ height=""" & CLng(GlobalSlideHeight) _
                        & """ filename=""" & ImageFileName & """ length=""0" _
                        & """></IMAGE>"
            DecIndent
            
        Case aofShapeTypeTextGroup
            IncIndent
            If Not CvtOpt.NoGroup Then
                strScript = NewLine() & "<GROUP>" '  name=""" & NameForAnim & """>"
                IncIndent
            End If
            If GraphStyle <> aofGraphStyleNone Then
                strScript = strScript & NewLine() & "<RECTANGLE x=""" & CLng(X) _
                            & """ y=""" & CLng(Y) _
                            & """ width=""" & CLng(Width) _
                            & """ height=""" & CLng(Height) _
                            & """ color=""" & LineColor _
                            & """ fillColor=""" & FillColor _
                            & """ lineWidth=""" & LineWidth _
                            & """ lineStyle=""" & LineStyle _
                            & """ ZPosition=""" & ZPosition _
                            & """></RECTANGLE>"
            End If
            
            For i = 1 To GroupItemNum
                DecIndent
                If Not GroupItems(i).Invisible Then
                    strScript = strScript & GroupItems(i).Script()
                End If
                IncIndent
            Next
            If Not CvtOpt.NoGroup Then
                DecIndent
                strScript = strScript & NewLine() & "</GROUP>"
            End If
            DecIndent
        Case aofShapeTypeUserDefinedGroup
            If Not CvtOpt.NoGroup Then
                IncIndent
                strScript = NewLine() & "<GROUP>" '  name=""" & NameForAnim & """>"
            End If
            For i = 1 To GroupItemNum
                If Not GroupItems(i).Invisible Then
                    strScript = strScript & GroupItems(i).Script()
                End If
            Next
            If Not CvtOpt.NoGroup Then
                strScript = strScript & NewLine() & "</GROUP>"
                DecIndent
            End If
        Case Else
            'ErrLog aofErrUnknown, "Unknown object type."
    End Select
    
    If ContainText Then
        strScript = strScript & TextInShape.Script()
    End If
    
    Script = strScript
End Function

' to replace the special text field in template
' IMPORTANT: Should be written in FAQ.
'  This function is not accurate! Reasons:
'  In PowerPoint 97, all auto text field are shown as "*", so that:
'  1. It's impossible to distinguish which one is Date/time,
'     which one is Footer or SlideNumber. We just assume that
'     the auto text field in a Date/Time placeholder is Date/Time
'     field, etc.
'  2. Each "*" in the text, no matter it really is an auto text shape
'     or just normal text set by the user, is replaced by the auto
'     text field strings.
Private Function ReplaceAutoTextField(txt As String) As String
    Dim strTmp As String
    Select Case FootersHeadersType
        Case aofDateTime
            strTmp = MyReplace(txt, "*", StrDate)
        Case aofFooter
            strTmp = MyReplace(txt, "*", StrFooter)
        Case aofSlideNumber
            strTmp = MyReplace(txt, "*", StrSlideNumber) 'CurPageNumber)
        Case Else
            strTmp = txt
    End Select
    
    ReplaceAutoTextField = strTmp
End Function

Private Sub ParseRect(shp As Shape)
    SetAsRect shp
    
    If ShapeType = aofShapeTypeImage Then   ' the rect is converted as image
        ForceToNoText = True
    End If
    
End Sub

Sub SetAsFourPointsRect(shp As Shape)
    
    VertNum = 5
    ReDim Vert(1 To VertNum) As aofNode
    
    With shp
    
        Vert(1).X = .Left
        Vert(1).Y = .Top
        Vert(2).X = .Left + .Width
        Vert(2).Y = .Top
        Vert(3).X = .Left + .Width
        Vert(3).Y = .Top + .Height
        Vert(4).X = .Left
        Vert(4).Y = .Top + .Height
        Vert(5).X = .Left
        Vert(5).Y = .Top
        
        SetSize shp
        NodesRotate .Rotation
    End With
    SetAsPolygon shp, True

End Sub

Sub SetAsRect(shp As Shape)
        
    If shp.Rotation <> 0 Then
        SetAsFourPointsRect shp
        Exit Sub
    End If
    
    ShapeType = aofShapeTypeRect
    SetSize shp
    
    If SetGraphmode(shp) Then    ' lineart and fillart are set here
        'ErrLog aofErrInvisibleShape, "invisible Rect"
        Exit Sub
    End If
    
    Select Case shp.Fill.Type
        Case MsoFillType.msoFillBackground, MsoFillType.msoFillSolid
        Case Else
            SetAsImage shp
            'ErrLog aofErrNotSolidFilled, "Rect saved as image."
            Exit Sub
    End Select
    
End Sub

Function SetGraphmode(shp As Shape) As Boolean
    If shp.Visible = msoFalse Then
        Invisible = True
    ElseIf SetGraphstyle(shp) = aofGraphStyleNone And shp.HasTextFrame = msoFalse Then
        Invisible = True
    Else
        Invisible = False
    End If
    
    SetGraphmode = Invisible
End Function

Public Function SetGraphstyle(shp As Shape) As Long ' As aofGraphStyle
'    If shp.Fill.Visible = msoTrue Then
'        GraphStyle = aofGraphStyleFilled
'        SetFillArt shp
'        LineColor = FillColor
'        LineWidth = 1
'        LineStyle = " "
'    End If
    GraphStyle = aofGraphStyleNone
    
    If shp.Fill.Visible = msoTrue Then
        GraphStyle = aofGraphStyleFilled
        SetFillArt shp
        LineColor = FillColor
        'If shp.Fill.Type <> msoFillBackground Or shp.Fill.Type <> msoFillSolid Then
            
    End If
    
    If shp.Line.Visible = msoTrue Then
        GraphStyle = GraphStyle + aofGraphStyleOutline
        SetLineArt shp
    End If
    
    SetGraphstyle = GraphStyle
End Function

Sub SetAsPolygon(shp As Shape, Optional UserDefinedNodes As Boolean = False, Optional bRotateNodes As Boolean = True)
    
    If Not IsSolidFilled(shp) Then
        SetAsImage shp
        SetNewAnchor shp
        Exit Sub
    End If

    ShapeType = aofShapeTypePolygon
    'SetSize shp
    
    SetLineArt shp
    
    If SetGraphmode(shp) Then    ' lineart and fillart are set here
        'ErrLog aofErrInvisibleShape, "invisible Polygon"
        Exit Sub
    End If
    
    If Not UserDefinedNodes Then
        ReadNodes shp
        If bRotateNodes Then
            NodesRotate shp.Rotation
        End If
    End If
        
    PrintPointsString
    
    'Erase Vert
    HasVertices = False
    
End Sub

Sub PrintPointsString()
'    Dim i                   As Long
'    Dim j                   As Long
'    Dim strTemp             As String
'    Dim InsertedPoints      As Long
'    Dim sgPoints(0 To 3)    As WBPoint
'
''    Set BPoints = New aofPoints
'
'    i = 1
'    Do While i <= VertNum
'        With Vert(i)
'            If .SegType = MsoSegmentType.msoSegmentLine Then        ' line segment
'                strTemp = strTemp & "{" & CLng(.x) & " " & CLng(.y) & "} "
'                i = i + 1
'                PointNum = PointNum + 1
'
'                BPoints.Add CLng(.x), CLng(.y)
'
'            Else        'nSegType = MsoSegmentType.msoSegmentCurve   bezier curve segment
'                If i < VertNum Then        ' else reached the end of Vertices.
'                    For j = 1 To 4
'                        If i - 1 + j <= VertNum Then
'                            sgPoints(j - 1).x = Vert(i - 1 + j).x
'                            sgPoints(j - 1).y = Vert(i - 1 + j).y
'                        Else
'                            sgPoints(j - 1).x = Vert(1).x
'                            sgPoints(j - 1).y = Vert(1).y
'                        End If
'                    Next
'                    strTemp = strTemp & InsertBezierPoints(sgPoints, InsertedPoints)
'                    i = i + 3
'                    PointNum = PointNum + InsertedPoints
'                Else
'                    strTemp = strTemp & "{" & CLng(.x) & " " & CLng(.y) & "} "
'                    i = i + 1
'                    PointNum = PointNum + 1
'
'                    BPoints.Add CLng(.x), CLng(.y)
'
'                End If
'            End If
'        End With
'    Loop
'
'    If BPoints.Count < 1 Then
'        Invisible = True
'        'ErrLog aofErrInvalidPolygon, "No points (in function PrintPointsString())"
'    End If
    
    NewSetBoundingPoints
    IsClosedPolyline = BPoints.IsClosed()
    PointsString = BPoints.PrintString()
End Sub

Sub NodesRotate(rotAng As Long)
    Dim c11     As Double
    Dim c12     As Double
    Dim c21     As Double
    Dim c22     As Double
    Dim d1      As Double
    Dim d2      As Double
    Dim ang     As Double
    
    Dim nx      As Double
'    Dim ny      As Double
    
    If rotAng = 0 Then
        Exit Sub
    End If
    
    ang = -rotAng * PI / 180
    c11 = Cos(ang)
    c12 = Sin(ang)
    c21 = -c12
    c22 = c11
    
    Dim x0      As Double
    Dim y0      As Double
    
    x0 = X + Width / 2
    y0 = Y + Height / 2
    
    d1 = x0 - x0 * c11 - y0 * c12
    d2 = y0 - x0 * c21 - y0 * c22
    
    Dim i        As Long
    
    For i = 1 To VertNum
        With Vert(i)
            nx = .X
            .X = c11 * .X + c12 * .Y + d1
            .Y = c21 * nx + c22 * .Y + d2
        End With
    Next
    
End Sub

Private Sub ReadNodes(shp As Shape)
    Dim i       As Long
    Dim minx    As Double
    Dim maxx    As Double
    Dim miny    As Double
    Dim maxy    As Double
    Dim xx       As Double
    Dim yy       As Double
    Dim shftx   As Double
    Dim shfty   As Double
    Dim ratw    As Double
    Dim rath    As Double

    'Dim ndsNum  As Long
    
    On Error Resume Next
    
    'ndsNum = shp.Nodes.Count
    VertNum = UBound(shp.Vertices)
    
    If Err.Number <> 0 Then
        'ErrLog aofErrPolygonNoNodes, "No Vertrics!"
    End If
    
'    If ndsNum = 0 Then ' some freeforms have no Nodes, then read Vertices instead
        If VertNum = 0 Then
            'ErrLog aofErrNoNodes, "Polygon no vertices"
            Exit Sub
        End If
        
        HasVertices = True
        ReDim Vert(1 To VertNum) As aofNode
        
        With shp
            minx = .Vertices(1, 1)
            maxx = minx
            miny = .Vertices(1, 2)
            maxy = miny
            
            For i = 1 To VertNum    ' read the vertices and find the bounds of the vertices
                xx = .Vertices(i, 1)
                yy = .Vertices(i, 2)
                
                If xx < minx Then
                    minx = xx
                ElseIf xx > maxx Then
                    maxx = xx
                End If
                
                If yy < miny Then
                    miny = yy
                ElseIf yy > maxy Then
                    maxy = yy
                End If
                
                Vert(i).X = xx
                Vert(i).Y = yy
                Vert(i).SegType = .Nodes(i).SegmentType     ' error may raise here (harmless)
            Next
        End With
        
        Err.Clear       ' clear errors

        xx = maxx - minx        ' actual width
        yy = maxy - miny        ' actual height

        If Abs(xx) < 0.000001 Then
            ratw = 1
        Else
            ratw = shp.Width / xx
        End If
        If Abs(yy) < 0.000001 Then
            rath = 1
        Else
            rath = shp.Height / yy
        End If
        shftx = shp.Left - minx * ratw
        shfty = shp.Top - miny * rath

        If Abs(ratw - 1) > 0.0005 Or Abs(rath - 1) > 0.0005 _
            Or Abs(shftx) > 0.001 Or Abs(shfty) > 0.001 Then
            For i = 1 To VertNum
                Vert(i).X = Vert(i).X * ratw + shftx
                Vert(i).Y = Vert(i).Y * rath + shfty
            Next
        End If
        
        FlipNodes Vert, VertNum, shp
        'NodesRotate shp.Rotation    ' moved to setpolygon
'    Else
'       Read from Nodes in ver 2.095 ~ 2.096
'    End If

End Sub

Sub SetAsOval(shp As Shape)

    If shp.Rotation <> 0 Then
        SetAsImage shp
        SetNewAnchor shp
        Exit Sub
    End If
    
    ShapeType = aofShapeTypeCirc
    SetSize shp
    SetGraphmode shp
End Sub

Sub SetSize(shp As Shape)
    On Error GoTo SetSizeError
    X = shp.Left
    Y = shp.Top
    Width = shp.Width
    Height = shp.Height
    Exit Sub
SetSizeError:
    X = 0
    Y = 0
    Width = 0
    Height = 0
    Exit Sub
End Sub

Sub SetLineArt(shp As Shape, Optional DoNotUseArrow As Boolean = False)
    With shp
        LineColor = MLBColor(.Line.ForeColor)
        LineWidth = GetWBLineWidth(.Line.Weight)
        LineStyle = GetWBLineType(.Line)
        
'        If ShapeType = aofShapeTypeLine And Not DoNotUseArrow Then
        If Not DoNotUseArrow Then
            ArrowStyle = MLBArrowStyle(.Line)
            ArrowShape = MLBArrowShape(.Line)
        End If
    End With
        
End Sub
Private Function GetWBLineWidth(lw As Single) As Long
    If lw > 0 Then
        GetWBLineWidth = CLng(lw)
    Else
        GetWBLineWidth = 1
    End If
End Function

Private Function GetWBLineType(ln As LineFormat) As String
    GetWBLineType = MLBLineStyle(ln)
End Function

Private Function MLBArrowShape(ln As LineFormat) As String
    MLBArrowShape = "8 10 4"
End Function

Private Function MLBArrowStyle(ln As LineFormat) As String
    If ln.BeginArrowheadStyle <> msoArrowheadNone Then
        If ln.EndArrowheadStyle <> msoArrowheadNone Then
            MLBArrowStyle = "both"
        Else
            MLBArrowStyle = "first"
        End If
    Else
        If ln.EndArrowheadStyle <> msoArrowheadNone Then
            MLBArrowStyle = "last"
        Else
            MLBArrowStyle = "none"
        End If
    End If
End Function

Private Function MLBLineStyle(ln As LineFormat) As String
    Dim str As String
    Select Case ln.DashStyle
        Case MsoLineDashStyle.msoLineSolid
            str = " "
        Case MsoLineDashStyle.msoLineRoundDot
            str = "."
        Case MsoLineDashStyle.msoLineSquareDot
            str = ","
        Case MsoLineDashStyle.msoLineDash
            str = "-"
        Case MsoLineDashStyle.msoLineLongDash
            str = "_"
        Case MsoLineDashStyle.msoLineDashDot
            str = ".-"
        Case MsoLineDashStyle.msoLineDashDotDot
            str = "..-"
        Case MsoLineDashStyle.msoLineLongDashDot
            str = ".-"
'        Case MsoLineDashStyle.msoLineDashStyleMixed
'            str = " "
        Case Else
            str = " "
    End Select
    MLBLineStyle = str
End Function

Public Sub SetFillArt(shp As Shape)
    FillColor = MLBColor(shp.Fill.ForeColor)
End Sub

Private Function IsSolidFilled(shp As Shape) As Boolean
    On Error GoTo NoFillSetting
    If shp.Fill.Visible = msoFalse Then
        IsSolidFilled = True
        Exit Function
    End If
    
    If shp.Fill.Type = msoFillSolid Or shp.Fill.Type = msoFillBackground Then
        IsSolidFilled = True
    Else
        IsSolidFilled = False
    End If
    Exit Function
NoFillSetting:
    IsSolidFilled = False
    Exit Function
End Function

Private Sub SetVerticesCurvedDownArrow(shp As Shape)
    Dim r1 As Single
    Dim r2 As Single
    Dim r3 As Single
    Dim wstr As Double      ' width of the strip
    Dim xoff As Double      ' s offset of the strip
    
    Dim dest As aofNode, A As aofNode, b As aofNode, c As aofNode, d As aofNode, pntNum As Long, th As Long
    Dim i As Long, t As Double, aw As Single, j As Long
    Dim num1 As Long
        
    On Error Resume Next
    r1 = shp.Adjustments(1)     ' upper side of the arrow
    If Err.Number <> 0 Then
        r1 = 0.6
    End If
    r2 = shp.Adjustments(2)     ' bottom side of the arrow neck
    If Err.Number <> 0 Then
        r2 = 0.9
    End If
    r3 = shp.Adjustments(3)     ' arrow size
    If Err.Number <> 0 Then
        r3 = 0.3333333
    End If
    
    wstr = shp.Width * (2 * r2 - r1 - 1)
    xoff = shp.Width * (r1 - r2 + 1) / 2
    
    With shp            ' arrow part
        A.X = .Left + xoff + wstr
        A.Y = .Top
        b.X = A.X + xoff / 2
        b.Y = A.Y
        c.X = .Left + .Width * r2
        c.Y = .Top + .Height / 2
        d.X = c.X
        d.Y = .Top + .Height
        
        pntNum = IIf(.Height > xoff, xoff, .Height)
        ReDim v(1 To pntNum + 1, 1 To 2) As Double
        
        th = .Top + .Height * r3        ' top of arrow head
        aw = .Width * (1 - r2)         ' the width of arrow shoulder.
        For i = 1 To pntNum
            t = 1# * i / pntNum
            bezier dest, t, A, b, c, d
            If dest.Y > th Then
                j = i - 1               ' number of points
                Exit For
            Else
                v(i, 1) = dest.X
                v(i, 2) = dest.Y
            End If
        Next
                
        num1 = 2 * j + 6
        InitVertices num1 + 9
        
        Vert(1).X = .Left + xoff
        Vert(1).Y = .Top
        Vert(2).X = Vert(1).X + wstr
        Vert(2).Y = .Top
        
        For i = 1 To j             ' bottom edge of the strip
            Vert(i + 2).X = v(i, 1)
            Vert(i + 2).Y = v(i, 2)
        Next
        
        ' arrow
        Vert(j + 3).X = Vert(j + 2).X + aw
        Vert(j + 3).Y = Vert(j + 2).Y
        Vert(j + 4).X = .Left + .Width * (1 + r1) / 2
        Vert(j + 4).Y = .Top + .Height
        Vert(j + 5).X = Vert(j + 2).X - wstr - aw
        Vert(j + 5).Y = Vert(j + 2).Y
        
        For i = 1 To j             ' top edge of the strip
            Vert(j + 5 + i).X = v(j + 1 - i, 1) - wstr
            Vert(j + 5 + i).Y = v(j + 1 - i, 2)
        Next
        
        Vert(num1) = Vert(1)
        Erase v
   
        Vert(num1 + 1).X = .Left + xoff
        Vert(num1 + 1).Y = .Top
        Vert(num1 + 2).X = Vert(num1 + 1).X + wstr
        Vert(num1 + 2).Y = Vert(num1 + 1).Y
        Vert(num1 + 2).SegType = msoSegmentCurve
        Vert(num1 + 3).X = Vert(num1 + 2).X - xoff / 2
        Vert(num1 + 3).Y = Vert(num1 + 2).Y
        Vert(num1 + 3).SegType = msoSegmentCurve
        Vert(num1 + 4).X = .Left + wstr
        Vert(num1 + 4).Y = .Top + .Height / 2
        Vert(num1 + 4).SegType = msoSegmentCurve
        Vert(num1 + 5).X = Vert(num1 + 4).X
        Vert(num1 + 5).Y = .Top + .Height
        Vert(num1 + 6).X = .Left
        Vert(num1 + 6).Y = .Top + .Height
        Vert(num1 + 6).SegType = msoSegmentCurve
        Vert(num1 + 7).X = .Left
        Vert(num1 + 7).Y = Vert(num1 + 4).Y
        Vert(num1 + 7).SegType = msoSegmentCurve
        Vert(num1 + 8).X = .Left + xoff / 2
        Vert(num1 + 8).Y = .Top
        Vert(num1 + 8).SegType = msoSegmentCurve
        Vert(num1 + 9) = Vert(num1 + 1)
   End With
   
End Sub

Private Sub ParseCurvedDownArrow(shp As Shape)
    ParseCurvedRightArrow shp
End Sub
Private Sub SetVerticesCurvedUpArrow(shp As Shape)
    Dim r1 As Single
    Dim r2 As Single
    Dim r3 As Single
    Dim wstr As Double      ' width of the strip
    Dim xoff As Double      ' s offset of the strip
    Dim dest As aofNode, A As aofNode, b As aofNode, c As aofNode, d As aofNode, pntNum As Long, th As Long
    Dim i As Long, t As Double, aw As Single, j As Long
    Dim num1 As Long
    
    On Error Resume Next
    r1 = shp.Adjustments(1)     ' upper side of the arrow
    If Err.Number <> 0 Then
        r1 = 0.6
    End If
    r2 = shp.Adjustments(2)     ' bottom side of the arrow neck
    If Err.Number <> 0 Then
        r2 = 0.9
    End If
    r3 = shp.Adjustments(3)     ' arrow size
    If Err.Number <> 0 Then
        r3 = 0.3333333
    End If
    
    wstr = shp.Width * (2 * r2 - r1 - 1)
    xoff = shp.Width * (r1 - r2 + 1) / 2
        
    With shp            ' arrow part
        A.X = .Left + xoff + wstr
        A.Y = .Top + .Height
        b.X = A.X + xoff / 2
        b.Y = A.Y
        c.X = .Left + .Width * r2
        c.Y = .Top + .Height / 2
        d.X = c.X
        d.Y = .Top
        
        pntNum = IIf(.Height > xoff, xoff, .Height)
        ReDim v(1 To pntNum + 1, 1 To 2) As Double
        
        th = .Top + .Height * r3        ' bottom of arrow head
        aw = .Width * (1 - r2)         ' the width of arrow shoulder.
        For i = 1 To pntNum
            t = 1# * i / pntNum
            bezier dest, t, A, b, c, d
            If dest.Y < th Then
                j = i - 1               ' number of points
                Exit For
            Else
                v(i, 1) = dest.X
                v(i, 2) = dest.Y
            End If
        Next
                
        num1 = 2 * j + 6
        InitVertices num1 + 9
        
        Vert(1).X = .Left + xoff
        Vert(1).Y = .Top + .Height
        Vert(2).X = Vert(1).X + wstr
        Vert(2).Y = .Top + .Height
        
        For i = 1 To j             ' bottom edge of the strip
            Vert(i + 2).X = v(i, 1)
            Vert(i + 2).Y = v(i, 2)
        Next
        
        ' arrow
        Vert(j + 3).X = Vert(j + 2).X + aw
        Vert(j + 3).Y = Vert(j + 2).Y
        Vert(j + 4).X = .Left + .Width * (1 + r1) / 2
        Vert(j + 4).Y = .Top
        Vert(j + 5).X = Vert(j + 2).X - wstr - aw
        Vert(j + 5).Y = Vert(j + 2).Y
        
        For i = 1 To j             ' top edge of the strip
            Vert(j + 5 + i).X = v(j + 1 - i, 1) - wstr
            Vert(j + 5 + i).Y = v(j + 1 - i, 2)
        Next
        
        Vert(num1) = Vert(1)
        Erase v
   
        Vert(num1 + 1).X = .Left + xoff
        Vert(num1 + 1).Y = .Top + .Height
        Vert(num1 + 2).X = Vert(num1 + 1).X + wstr
        Vert(num1 + 2).Y = Vert(num1 + 1).Y
        Vert(num1 + 2).SegType = msoSegmentCurve
        Vert(num1 + 3).X = Vert(num1 + 2).X - xoff / 2
        Vert(num1 + 3).Y = Vert(num1 + 2).Y
        Vert(num1 + 3).SegType = msoSegmentCurve
        Vert(num1 + 4).X = .Left + wstr
        Vert(num1 + 4).Y = .Top + .Height / 2
        Vert(num1 + 4).SegType = msoSegmentCurve
        Vert(num1 + 5).X = Vert(num1 + 4).X
        Vert(num1 + 5).Y = .Top
        Vert(num1 + 6).X = .Left
        Vert(num1 + 6).Y = .Top
        Vert(num1 + 6).SegType = msoSegmentCurve
        Vert(num1 + 7).X = .Left
        Vert(num1 + 7).Y = Vert(4).Y
        Vert(num1 + 7).SegType = msoSegmentCurve
        Vert(num1 + 8).X = .Left + xoff / 2
        Vert(num1 + 8).Y = .Top + .Height
        Vert(num1 + 8).SegType = msoSegmentCurve
        Vert(num1 + 9) = Vert(num1 + 1)
   End With
End Sub

Private Sub ParseCurvedUpArrow(shp As Shape)
    ParseCurvedLeftArrow shp
End Sub

Private Sub SetVerticesCurvedLeftArrow(shp As Shape)
    Dim r1 As Single
    Dim r2 As Single
    Dim r3 As Single
    Dim wstr As Double      ' width of the strip
    Dim yoff As Double      ' y offset of the strip
    
    Dim dest As aofNode, A As aofNode, b As aofNode, c As aofNode, d As aofNode, pntNum As Long, th As Long
    Dim i As Long, t As Double, aw As Single, j As Long
    Dim num1 As Long
    
    On Error Resume Next
    r1 = shp.Adjustments(1)     ' upper side of the arrow
    If Err.Number <> 0 Then
        r1 = 0.6
    End If
    r2 = shp.Adjustments(2)     ' bottom side of the arrow neck
    If Err.Number <> 0 Then
        r2 = 0.9
    End If
    r3 = shp.Adjustments(3)     ' arrow size
    If Err.Number <> 0 Then
        r3 = 0.3333333
    End If
    
    wstr = shp.Height * (2 * r2 - r1 - 1)
    yoff = shp.Height * (r1 - r2 + 1) / 2
    
    With shp            ' arrow part
        A.X = .Left + .Width
        A.Y = .Top + yoff + wstr
        b.X = .Left + .Width
        b.Y = A.Y + yoff / 2
        c.X = .Left + .Width / 2
        c.Y = .Top + .Height * r2
        d.X = .Left
        d.Y = c.Y
        
        pntNum = IIf(.Width > yoff, yoff, .Width)
        ReDim v(1 To pntNum + 1, 1 To 2) As Double
        
        th = .Left + .Width * r3        ' right side of arrow head
        aw = .Height * (1 - r2)         ' the width of arrow shoulder.
        For i = 1 To pntNum
            t = 1# * i / pntNum
            bezier dest, t, A, b, c, d
            If dest.X < th Then
                j = i - 1               ' number of points
                Exit For
            Else
                v(i, 1) = dest.X
                v(i, 2) = dest.Y
            End If
        Next
                
        num1 = 2 * j + 6
        InitVertices num1 + 9

        Vert(1).X = .Left + .Width
        Vert(1).Y = .Top + yoff
        Vert(2).X = .Left + .Width
        Vert(2).Y = Vert(1).Y + wstr
        
        For i = 1 To j             ' bottom edge of the strip
            Vert(i + 2).X = v(i, 1)
            Vert(i + 2).Y = v(i, 2)
        Next
        
        ' arrow
        Vert(j + 3).X = Vert(j + 2).X
        Vert(j + 3).Y = Vert(j + 2).Y + aw
        Vert(j + 4).X = .Left
        Vert(j + 4).Y = .Top + .Height * (1 + r1) / 2
        Vert(j + 5).X = Vert(j + 3).X
        Vert(j + 5).Y = Vert(j + 2).Y - wstr - aw
        
        For i = 1 To j             ' top edge of the strip
            Vert(j + 5 + i).X = v(j + 1 - i, 1)
            Vert(j + 5 + i).Y = v(j + 1 - i, 2) - wstr
        Next
        
        Vert(num1) = Vert(1)
        Erase v
        
        ' darker part of the strip
        Vert(num1 + 1).X = .Left + .Width
        Vert(num1 + 1).Y = .Top + yoff
        Vert(num1 + 2).X = Vert(num1 + 1).X
        Vert(num1 + 2).Y = Vert(num1 + 1).Y + wstr
        Vert(num1 + 2).SegType = msoSegmentCurve
        Vert(num1 + 3).X = Vert(num1 + 2).X
        Vert(num1 + 3).Y = Vert(num1 + 2).Y - yoff / 2
        Vert(num1 + 3).SegType = msoSegmentCurve
        Vert(num1 + 4).X = .Left + .Width / 2
        Vert(num1 + 4).Y = .Top + wstr
        Vert(num1 + 4).SegType = msoSegmentCurve
        Vert(num1 + 5).X = .Left
        Vert(num1 + 5).Y = Vert(num1 + 4).Y
        Vert(num1 + 6).X = Vert(num1 + 5).X
        Vert(num1 + 6).Y = .Top
        Vert(num1 + 6).SegType = msoSegmentCurve
        Vert(num1 + 7).X = Vert(num1 + 4).X
        Vert(num1 + 7).Y = .Top
        Vert(num1 + 7).SegType = msoSegmentCurve
        Vert(num1 + 8).X = .Left + .Width
        Vert(num1 + 8).Y = .Top + yoff / 2
        Vert(num1 + 8).SegType = msoSegmentCurve
        Vert(num1 + 9) = Vert(num1 + 1)
   End With
End Sub
Private Sub ParseCurvedLeftArrow(shp As Shape)
    Dim colorDark As String ' color of the darker part of the strip
    Dim colorNormal As String
    Dim colorDumm As String
    
    NewRotateNodes shp
    SetGraphstyle shp
    
    If GraphStyle > aofGraphStyleOutline Then
        SetRelatedColors shp.Fill.ForeColor, colorDumm, colorDumm, colorDark, colorDumm
        colorNormal = MLBColor(shp.Fill.ForeColor)
    Else
        colorDark = "none"
        colorNormal = "none"
    End If
    
    AddGroupItem    ' the arrow part
    With GroupItems(GroupItemNum)
        .ShapeType = aofShapeTypePolygon
        .SetGraphstyle shp
        .FillColor = colorNormal
        .InitVerts 1, VertNum - 9, Vert, True
        .PrintPointsString
    End With
    
    AddGroupItem    ' darker part of the strip, the last 9 vertices
    With GroupItems(GroupItemNum)
        .ShapeType = aofShapeTypePolygon
        .SetGraphstyle shp
        .FillColor = colorDark
        .InitVerts VertNum - 8, 9, Vert, True
        .PrintPointsString
    End With
    
    ShapeType = aofShapeTypeUserDefinedGroup
    
End Sub

Private Sub SetVerticesCurvedRightArrow(shp As Shape)
    Dim r1 As Single
    Dim r2 As Single
    Dim r3 As Single
    Dim wstr As Double      ' width of the strip
    Dim yoff As Double      ' y offset of the strip
    Dim dest As aofNode, A As aofNode, b As aofNode, c As aofNode, d As aofNode, pntNum As Long, th As Long
    Dim i As Long, t As Double, aw As Single, j As Long
    Dim num1 As Long
    
    On Error Resume Next
    r1 = shp.Adjustments(1)     ' upper side of the arrow
    If Err.Number <> 0 Then
        r1 = 0.6
    End If
    r2 = shp.Adjustments(2)     ' bottom side of the arrow neck
    If Err.Number <> 0 Then
        r2 = 0.9
    End If
    r3 = shp.Adjustments(3)     ' arrow size
    If Err.Number <> 0 Then
        r3 = 0.6666667
    End If
    
    wstr = shp.Height * (2 * r2 - r1 - 1)
    yoff = shp.Height * (r1 - r2 + 1) / 2
    
    With shp            ' arrow part
        A.X = .Left
        A.Y = .Top + yoff + wstr
        b.X = .Left
        b.Y = A.Y + yoff / 2
        c.X = .Left + .Width / 2
        c.Y = .Top + .Height * r2
        d.X = .Left + .Width
        d.Y = c.Y
        
        pntNum = IIf(.Width > yoff, yoff, .Width)
        ReDim v(1 To pntNum + 1, 1 To 2) As Double
        
        th = .Left + .Width * r3        ' left side of arrow head
        aw = .Height * (1 - r2)         ' the width of arrow shoulder.
        For i = 1 To pntNum
            t = 1# * i / pntNum
            bezier dest, t, A, b, c, d
            If dest.X > th Then
                j = i - 1
                Exit For
            Else
                v(i, 1) = dest.X
                v(i, 2) = dest.Y
            End If
        Next
                
        ' The arrow part has 2*j+6 vertices, the dark strip part has 9 vertices.
        num1 = 2 * j + 6
        ' IMPORTANT:
        ' In fact, the dark strip part is beneath the arrow part.
        ' So, in ParseCurvedRightArrow(), the last 9 vertices should be assigned
        ' to the first groupitem, the leading others should be assigned to the
        ' second.
        InitVertices num1 + 9
        
        Vert(1).X = .Left
        Vert(1).Y = .Top + yoff
        Vert(2).X = .Left
        Vert(2).Y = Vert(1).Y + wstr
        
        For i = 1 To j             ' bottom edge of the strip
            Vert(i + 2).X = v(i, 1)
            Vert(i + 2).Y = v(i, 2)
        Next
        
        ' arrow
        Vert(j + 3).X = Vert(j + 2).X
        Vert(j + 3).Y = Vert(j + 2).Y + aw
        Vert(j + 4).X = .Left + .Width
        Vert(j + 4).Y = .Top + .Height * (1 + r1) / 2
        Vert(j + 5).X = Vert(j + 3).X
        Vert(j + 5).Y = Vert(j + 2).Y - wstr - aw
        
        For i = 1 To j             ' top edge of the strip
            Vert(j + 5 + i).X = v(j + 1 - i, 1)
            Vert(j + 5 + i).Y = v(j + 1 - i, 2) - wstr
        Next
        
        Vert(num1) = Vert(1)
        Erase v
        
        ' darker part of the strip has 9 vertices
        Vert(num1 + 1).X = .Left
        Vert(num1 + 1).Y = .Top + yoff
        Vert(num1 + 2).X = .Left
        Vert(num1 + 2).Y = Vert(num1 + 1).Y + wstr
        Vert(num1 + 2).SegType = msoSegmentCurve
        Vert(num1 + 3).X = .Left
        Vert(num1 + 3).Y = Vert(num1 + 2).Y - yoff / 2
        Vert(num1 + 3).SegType = msoSegmentCurve
        Vert(num1 + 4).X = .Left + .Width / 2
        Vert(num1 + 4).Y = .Top + wstr
        Vert(num1 + 4).SegType = msoSegmentCurve
        Vert(num1 + 5).X = .Left + .Width
        Vert(num1 + 5).Y = Vert(num1 + 4).Y
        Vert(num1 + 6).X = Vert(num1 + 5).X
        Vert(num1 + 6).Y = .Top
        Vert(num1 + 6).SegType = msoSegmentCurve
        Vert(num1 + 7).X = Vert(num1 + 4).X
        Vert(num1 + 7).Y = .Top
        Vert(num1 + 7).SegType = msoSegmentCurve
        Vert(num1 + 8).X = .Left
        Vert(num1 + 8).Y = .Top + yoff / 2
        Vert(num1 + 8).SegType = msoSegmentCurve
        Vert(num1 + 9) = Vert(num1 + 1)
   End With

End Sub
Private Sub ParseCurvedRightArrow(shp As Shape)
    Dim colorDark As String ' color of the darker part of the strip
    Dim colorNormal As String
    Dim colorDumm As String
    
    NewRotateNodes shp
    SetGraphstyle shp
    
    If GraphStyle > aofGraphStyleOutline Then
        SetRelatedColors shp.Fill.ForeColor, colorDumm, colorDumm, colorDark, colorDumm
        colorNormal = MLBColor(shp.Fill.ForeColor)
    Else
        colorDark = "none"
        colorNormal = "none"
    End If
    
    AddGroupItem    ' darker part of the strip, the last 9 vertices
    With GroupItems(GroupItemNum)
        .ShapeType = aofShapeTypePolygon
        .SetGraphstyle shp
        .FillColor = colorDark
        .InitVerts VertNum - 8, 9, Vert, True
        .PrintPointsString
    End With
    
    AddGroupItem    ' the arrow part
    With GroupItems(GroupItemNum)
        .ShapeType = aofShapeTypePolygon
        .SetGraphstyle shp
        .FillColor = colorNormal
        .InitVerts 1, VertNum - 9, Vert, True
        .PrintPointsString
    End With
    
    ShapeType = aofShapeTypeUserDefinedGroup
    
End Sub

Private Sub SetVerticesMoon(shp As Shape)
    Dim ratio As Single
    
    InitVertices 13
    With shp
        On Error Resume Next
        ratio = shp.Adjustments(1)
        If Err.Number <> 0 Then
            ratio = 0.5
        End If
        Vert(1).X = .Left + .Width
        Vert(1).Y = .Top
        Vert(1).SegType = msoSegmentCurve
        Vert(2).X = .Left + .Width / 2
        Vert(2).Y = .Top
        Vert(2).SegType = msoSegmentCurve
        Vert(3).X = .Left
        Vert(3).Y = .Top + .Height / 4
        Vert(3).SegType = msoSegmentCurve
        Vert(4).X = .Left
        Vert(4).Y = .Top + .Height / 2
        Vert(4).SegType = msoSegmentCurve
        Vert(5).X = .Left
        Vert(5).Y = .Top + .Height * 0.75
        Vert(5).SegType = msoSegmentCurve
        Vert(6).X = Vert(2).X
        Vert(6).Y = .Top + .Height
        
        Vert(7).X = Vert(1).X
        Vert(7).Y = Vert(6).Y
        Vert(7).SegType = msoSegmentCurve
        Vert(8).X = .Left + (1 + ratio) * .Width / 2
        Vert(8).Y = .Top + .Height * (1 - ratio / 4)
        Vert(8).SegType = msoSegmentCurve
        Vert(9).X = .Left + .Width * ratio
        Vert(9).Y = Vert(5).Y
        Vert(9).SegType = msoSegmentCurve
        Vert(10).X = Vert(9).X
        Vert(10).Y = Vert(4).Y
        Vert(10).SegType = msoSegmentCurve
        Vert(11).X = Vert(10).X
        Vert(11).Y = Vert(3).Y
        Vert(11).SegType = msoSegmentCurve
        Vert(12).X = Vert(8).X
        Vert(12).Y = .Top + .Height * ratio / 4
        Vert(12).SegType = msoSegmentCurve
        Vert(13) = Vert(1)
    End With
End Sub

Private Sub SetVerticesLightningBolt(shp As Shape)
    InitVertices 12
    With shp
        Vert(1).X = .Left
        Vert(1).Y = .Top + .Height * 0.18
        Vert(2).X = .Left + .Width * 0.395
        Vert(2).Y = .Top
        Vert(3).X = .Left + .Width * 0.6
        Vert(3).Y = .Top + .Height * 0.285
        Vert(4).X = .Left + .Width * 0.514
        Vert(4).Y = .Top + .Height * 0.3185
        Vert(5).X = .Left + .Width * 0.77
        Vert(5).Y = .Top + .Height * 0.5575
        Vert(6).X = .Left + .Width * 0.6875
        Vert(6).Y = .Top + .Height * 0.602
        Vert(7).X = .Left + .Width
        Vert(7).Y = .Top + .Height
        Vert(8).X = .Left + .Width * 0.465
        Vert(8).Y = .Top + .Height * 0.695
        Vert(9).X = .Left + .Width * 0.567
        Vert(9).Y = .Top + .Height * 0.644
        Vert(10).X = .Left + .Width * 0.236
        Vert(10).Y = .Top + .Height * 0.452
        Vert(11).X = .Left + .Width * 0.353
        Vert(11).Y = .Top + .Height * 0.39
        Vert(12) = Vert(1)
    End With
End Sub
Private Sub SetVerticesSmileyFace(shp As Shape)
    Dim n As Long
    Dim ratio   As Single
    Dim ratioMouth As Single
    
    On Error Resume Next
    ratioMouth = 0.7645833
    ratio = shp.Adjustments(1)
    If Err.Number <> 0 Then
        ratio = 0.81111111
    End If
        
    SetVerticesOval shp
    n = VertNum
        
    ' draw the mouth
    VertNum = n + 7
    ReDim Preserve Vert(1 To VertNum) As aofNode
    Vert(n + 1).X = shp.Left + shp.Width * 0.23
    Vert(n + 1).Y = shp.Top + shp.Height * (ratioMouth * 2 - ratio)
    Vert(n + 1).SegType = msoSegmentCurve
    Vert(n + 2).X = shp.Left + shp.Width * 0.3125
    Vert(n + 2).Y = shp.Top + shp.Height * ratioMouth
    Vert(n + 2).SegType = msoSegmentCurve
    Vert(n + 3).X = shp.Left + shp.Width * 0.41
    Vert(n + 3).Y = shp.Top + shp.Height * ratio
    Vert(n + 3).SegType = msoSegmentCurve
    Vert(n + 4).X = shp.Left + shp.Width / 2
    Vert(n + 4).Y = Vert(n + 3).Y
    Vert(n + 4).SegType = msoSegmentCurve
    
    Vert(n + 5).X = shp.Left + shp.Width * 0.59
    Vert(n + 5).Y = Vert(n + 3).Y
    Vert(n + 5).SegType = msoSegmentLine
    Vert(n + 6).X = shp.Left + shp.Width * 0.6875
    Vert(n + 6).Y = Vert(n + 2).Y
    Vert(n + 6).SegType = msoSegmentLine
    Vert(n + 7).X = shp.Left + shp.Width * 0.77
    Vert(n + 7).Y = Vert(n + 1).Y
    Vert(n + 7).SegType = msoSegmentLine
    
End Sub

Private Sub ParseSmileyFace(shp As Shape)
    Dim colorDumm As String
    Dim colorEyes As String
'
'    ' bacause Assistant doesnot support rotated ellipse,
'    ' and neither does converter. So, the rotated face
'    ' should be exported as image.
'    ' this might be supported by Assistant or converter.
'    If shp.Rotation <> 0 Then
'        SetAsImage shp
'        SetNewAnchor shp
'        Exit Sub
'    End If
    
    NewRotateNodes shp
    SetGraphstyle shp
    
    If GraphStyle > aofGraphStyleOutline Then
        SetRelatedColors shp.Fill.ForeColor, colorDumm, colorDumm, colorEyes, colorDumm
    Else
        colorEyes = "none"
    End If
    
    AddGroupItem
    With GroupItems(GroupItemNum)      ' face background
        .SetGraphstyle shp
        .InitVerts 1, 13, Vert, True
        .PrintPointsString
        .ShapeType = aofShapeTypePolygon
    End With
    
    AddGroupItem
    With GroupItems(GroupItemNum)      ' left eye
        .SetVerticesOval shp, True, _
            (shp.Left + shp.Width * 0.29), _
            (shp.Top + shp.Height * 0.3), _
            shp.Width * 0.105, _
            shp.Height * 0.105
        .NewRotateNodes shp
        .SetGraphstyle shp
        .FillColor = colorEyes
        .PrintPointsString
        .ShapeType = aofShapeTypePolygon
    End With
    
    AddGroupItem
    With GroupItems(GroupItemNum)      ' right eye
        .SetVerticesOval shp, True, _
            (shp.Left + shp.Width * 0.605 - .Width), _
            (shp.Top + shp.Height * 0.3), _
            shp.Width * 0.105, _
            shp.Height * 0.105
        .NewRotateNodes shp
        .SetGraphstyle shp
        .FillColor = colorEyes
        .PrintPointsString
        .ShapeType = aofShapeTypePolygon
    End With
    
    AddGroupItem
    With GroupItems(GroupItemNum)      ' mouth
        .SetGraphstyle shp
        If .GraphStyle <> aofGraphStyleNone Then
            .GraphStyle = aofGraphStyleOutline
        End If
        .InitVerts 14, 7, Vert, False
        .PrintPointsString
        .ShapeType = aofShapeTypePolygon
    End With
    
    ShapeType = aofShapeTypeUserDefinedGroup
    
End Sub

Public Sub SetPointsString(str As String)
    PointsString = str
End Sub

Private Sub SetVerticesRoundedRectangularCallout(shp As Shape, Optional bRotateNodes As Boolean = True)

    Dim ratio   As Single
    Dim ratio1  As Single
    Dim ratio2  As Single
    
    Dim cirRatio    As Single
    Dim shftx   As Long
    Dim shfty   As Long
    Dim shftx1   As Long
    Dim shftx2   As Long
    Dim shfty1   As Long
    Dim shfty2   As Long
        
    Dim shftx3   As Long
    Dim shfty3   As Long
    
    Dim InsertIdx   As Long
    
    InitVertices 41
    
    With shp
        cirRatio = 0.2
        ratio = 0.12
        shfty = .Height * ratio * (1 - cirRatio * 2)
        shftx = .Width * ratio * (1 - cirRatio * 2)
         
        On Error Resume Next
        ratio1 = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio1 = 0.0625
            Err.Clear
        End If
        ratio2 = .Adjustments(2)
        If Err.Number <> 0 Then
            ratio2 = 1.2
        End If
        On Error GoTo 0
        
        ' the callout point
        shftx3 = .Width * ratio1
        shfty3 = .Height * ratio2
        
        shftx1 = .Width * 0.17
        shftx2 = .Width * 0.42
        shfty1 = .Height * 0.17
        shfty2 = .Height * 0.42
       
       'top left corner
        Vert(1).X = .Left
        Vert(1).Y = .Top + shfty + shfty
        Vert(1).SegType = msoSegmentCurve
        Vert(2).X = .Left
        Vert(2).Y = .Top + shfty
        Vert(2).SegType = msoSegmentCurve
        Vert(3).X = .Left + shftx
        Vert(3).Y = .Top
        Vert(3).SegType = msoSegmentCurve
        Vert(4).X = .Left + shftx + shftx
        Vert(4).Y = .Top
        
        'top
        Vert(5).X = .Left + shftx1
        Vert(5).Y = .Top
        Vert(6) = Vert(5)
        Vert(7).X = .Left + shftx2
        Vert(7).Y = .Top
        Vert(8).X = .Left + .Width - shftx2
        Vert(8).Y = .Top
        Vert(9) = Vert(8)
        Vert(10).X = .Left + .Width - shftx1
        Vert(10).Y = .Top
        
        ' top right corner
        Vert(11).X = .Left + .Width - shftx - shftx
        Vert(11).Y = .Top
        Vert(11).SegType = msoSegmentCurve
        Vert(12).X = .Left + .Width - shftx
        Vert(12).Y = .Top
        Vert(12).SegType = msoSegmentCurve
        Vert(13).X = .Left + .Width
        Vert(13).Y = .Top + shfty
        Vert(13).SegType = msoSegmentCurve
        Vert(14).X = .Left + .Width
        Vert(14).Y = .Top + shfty + shfty
        
        'right
        Vert(15).X = .Left + .Width
        Vert(15).Y = .Top + shfty1
        Vert(16) = Vert(15)
        Vert(17).X = Vert(15).X
        Vert(17).Y = .Top + shfty2
        Vert(18).X = Vert(15).X
        Vert(18).Y = .Top + .Height - shfty2
        Vert(19) = Vert(18)
        Vert(20).X = Vert(15).X
        Vert(20).Y = .Top + .Height - shfty1
        
        ' right bottom corner
        Vert(21).X = .Left + .Width
        Vert(21).Y = .Top + .Height - shfty - shfty
        Vert(21).SegType = msoSegmentCurve
        Vert(22).X = Vert(21).X
        Vert(22).Y = .Top + .Height - shfty
        Vert(22).SegType = msoSegmentCurve
        Vert(23).X = Vert(12).X
        Vert(23).Y = .Top + .Height
        Vert(23).SegType = msoSegmentCurve
        Vert(24).X = Vert(11).X
        Vert(24).Y = .Top + .Height
        
        'bottom
        Vert(25).X = Vert(10).X
        Vert(25).Y = .Top + .Height
        Vert(26) = Vert(25)
        Vert(27).X = Vert(8).X
        Vert(27).Y = Vert(25).Y
        Vert(28).X = Vert(7).X
        Vert(28).Y = Vert(25).Y
        Vert(29) = Vert(28)
        Vert(30).X = Vert(5).X
        Vert(30).Y = Vert(25).Y
        
        ' left bottom corner
        Vert(31).X = Vert(4).X
        Vert(31).Y = .Top + .Height
        Vert(31).SegType = msoSegmentCurve
        Vert(32).X = Vert(3).X
        Vert(32).Y = Vert(31).Y
        Vert(31).SegType = msoSegmentCurve
        Vert(33).X = .Left
        Vert(33).Y = .Top + .Height - shfty
        Vert(33).SegType = msoSegmentCurve
        Vert(34).X = .Left
        Vert(34).Y = Vert(21).Y
        
        ' left
        Vert(35).X = .Left
        Vert(35).Y = Vert(20).Y
        Vert(36) = Vert(35)
        Vert(37).X = .Left
        Vert(37).Y = Vert(18).Y
        Vert(38).X = .Left
        Vert(38).Y = Vert(17).Y
        Vert(39) = Vert(38)
        Vert(40).X = .Left
        Vert(40).Y = Vert(15).Y
        Vert(41) = Vert(1)
        
        
        Dim r1 As Single
        Dim r2 As Single
        Dim dv As Single
        
        r1 = ratio1 - 0.5       ' move the coordinate origin to (0.5, 0.5)
        r2 = ratio2 - 0.5
        
        ' the point in the rect should be ignored.
        If Abs(r1) > 0.5 Or Abs(r2) > 0.5 Then
            If r2 = 0 Then
                If r1 > 0 Then
                    InsertIdx = 19
                Else
                    InsertIdx = 36
                End If
            Else
                dv = r1 / r2
                If r2 > 0 Then
                    If dv < -1 Then
                        InsertIdx = 36
                    ElseIf dv < 0 Then
                        InsertIdx = 29
                    ElseIf dv <= 1 Then
                        InsertIdx = 26
                    ElseIf dv > 1 Then
                        InsertIdx = 19
                    End If
                Else
                    If dv <= -1 Then
                        InsertIdx = 16
                    ElseIf dv <= 0 Then
                        InsertIdx = 9
                    ElseIf dv < 1 Then
                        InsertIdx = 6
                    ElseIf dv >= 1 Then
                        InsertIdx = 39
                    End If
                End If
            End If
            Vert(InsertIdx).X = .Left + shftx3
            Vert(InsertIdx).Y = .Top + shfty3
        End If
               
    End With
End Sub

Public Sub SetRectangleCalloutPoint(shp As Shape)
    Dim ratio1      As Single
    Dim ratio2      As Single
    
    VertNum = 1
    ReDim Vert(1 To 1) As aofNode
    
    With shp
        On Error Resume Next
        ratio1 = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio1 = 0.0625
            Err.Clear
        End If
        ratio2 = .Adjustments(2)
        If Err.Number <> 0 Then
            ratio2 = 1.2
        End If
        On Error GoTo 0
    
        Vert(1).X = .Left + .Width * ratio1
        Vert(1).Y = .Top + .Height * ratio2
    End With
End Sub

Private Sub SetVerticesRectangularCallout(shp As Shape)
    Dim ratio1      As Single
    Dim ratio2      As Single
    Dim shftx       As Long
    Dim shfty       As Long
    Dim shftx1      As Long
    Dim shftx2      As Long
    Dim shfty1      As Long
    Dim shfty2      As Long
    Dim InsertIdx   As Long
    
    InitVertices 29
    
    With shp
        On Error Resume Next
        ratio1 = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio1 = 0.0625
            Err.Clear
        End If
        ratio2 = .Adjustments(2)
        If Err.Number <> 0 Then
            ratio2 = 1.2
        End If
        On Error GoTo 0
        
        shftx = .Width * ratio1
        shfty = .Height * ratio2
        
        shftx1 = .Width * 0.17
        shftx2 = .Width * 0.42
        shfty1 = .Height * 0.17
        shfty2 = .Height * 0.42
        
        ' top
        Vert(1).X = .Left
        Vert(1).Y = .Top
        Vert(2).X = .Left + shftx1
        Vert(2).Y = .Top
        Vert(3) = Vert(2)
        Vert(4).X = .Left + shftx2
        Vert(4).Y = .Top
        Vert(8).X = .Left + .Width
        Vert(8).Y = .Top
        Vert(5).X = Vert(8).X - shftx2
        Vert(5).Y = .Top
        Vert(6) = Vert(5)
        Vert(7).X = Vert(8).X - shftx1
        Vert(7).Y = .Top
        
        ' right
        Vert(9).X = Vert(8).X
        Vert(9).Y = .Top + shfty1
        Vert(10) = Vert(9)
        Vert(11).X = Vert(9).X
        Vert(11).Y = .Top + shfty2
        Vert(15).X = Vert(9).X
        Vert(15).Y = .Top + .Height
        Vert(12).X = Vert(9).X
        Vert(12).Y = Vert(15).Y - shfty2
        Vert(13) = Vert(12)
        Vert(14).X = Vert(9).X
        Vert(14).Y = Vert(15).Y - shfty1
        
        'bottom
        Vert(16).X = Vert(7).X
        Vert(16).Y = Vert(15).Y
        Vert(17) = Vert(16)
        Vert(18).X = Vert(5).X
        Vert(18).Y = Vert(15).Y
        Vert(22).X = Vert(1).X
        Vert(22).Y = Vert(15).Y
        Vert(19).X = Vert(4).X
        Vert(19).Y = Vert(15).Y
        Vert(20) = Vert(19)
        Vert(21).X = Vert(2).X
        Vert(21).Y = Vert(15).Y
        
        'left
        Vert(23).X = .Left
        Vert(23).Y = Vert(14).Y
        Vert(24) = Vert(23)
        Vert(25).X = .Left
        Vert(25).Y = Vert(12).Y
        Vert(26).X = .Left
        Vert(26).Y = Vert(11).Y
        Vert(27) = Vert(26)
        Vert(28).X = .Left
        Vert(28).Y = Vert(9).Y
        Vert(29) = Vert(1)
        
        ' calculate the insert index
        Dim r1 As Single
        Dim r2 As Single
        Dim dv As Single
        
        r1 = ratio1 - 0.5       ' move the coordinate origin to (0.5, 0.5)
        r2 = ratio2 - 0.5
        
        ' the point in the rect should be ignored.
        If Abs(r1) > 0.5 Or Abs(r2) > 0.5 Then
            If r2 = 0 Then
                If r1 > 0 Then
                    InsertIdx = 13
                Else
                    InsertIdx = 24
                End If
            Else
                dv = r1 / r2
                If r2 > 0 Then
                    If dv < -1 Then
                        InsertIdx = 24
                    ElseIf dv < 0 Then
                        InsertIdx = 20
                    ElseIf dv <= 1 Then
                        InsertIdx = 17
                    ElseIf dv > 1 Then
                        InsertIdx = 13
                    End If
                Else
                    If dv <= -1 Then
                        InsertIdx = 10
                    ElseIf dv <= 0 Then
                        InsertIdx = 6
                    ElseIf dv < 1 Then
                        InsertIdx = 3
                    ElseIf dv >= 1 Then
                        InsertIdx = 27
                    End If
                End If
            End If
            Vert(InsertIdx).X = .Left + shftx
            Vert(InsertIdx).Y = .Top + shfty
        End If
        
    End With
End Sub

Private Sub SetVertices8pointStar(shp As Shape)
    Dim ratio1      As Single
    Dim ratio2      As Single
    Dim shftx1       As Long
    Dim shftx2       As Long
    Dim shftx3       As Long
    Dim shfty1       As Long
    Dim shfty2       As Long
    Dim shfty3       As Long
    
    InitVertices 17
    With shp
        On Error Resume Next
        ratio1 = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio1 = 0.1173
        End If
        ratio2 = 0.3087 + 0.3827 * ratio1        ' 1/2 - (1/2 - ratio1) * sin(PI/8)
        ratio1 = 0.0381 + 0.9239 * ratio1        ' 1/2 - (1/2 - ratio1) * cos(PI/8)
        
        shftx1 = .Width * ratio1
        shftx2 = .Width * 0.1464                ' 1/2 - cos(PI/4) / 2
        shftx3 = .Width * ratio2
        shfty1 = .Height * ratio1
        shfty2 = .Height * 0.1464
        shfty3 = .Height * ratio2
        
        Vert(1).X = .Left
        Vert(1).Y = .Top + .Height / 2
        Vert(2).X = .Left + shftx1
        Vert(2).Y = .Top + shfty3
        Vert(3).X = .Left + shftx2
        Vert(3).Y = .Top + shfty2
        Vert(4).X = .Left + shftx3
        Vert(4).Y = .Top + shfty1
        Vert(5).X = .Left + .Width / 2
        Vert(5).Y = .Top
        Vert(6).X = .Left + .Width - shftx3
        Vert(6).Y = Vert(4).Y
        Vert(7).X = .Left + .Width - shftx2
        Vert(7).Y = Vert(3).Y
        Vert(8).X = .Left + .Width - shftx1
        Vert(8).Y = Vert(2).Y
        
        Vert(9).X = .Left + .Width
        Vert(9).Y = Vert(1).Y
        Vert(10).X = Vert(8).X
        Vert(10).Y = .Top + .Height - shfty3
        Vert(11).X = Vert(7).X
        Vert(11).Y = .Top + .Height - shfty2
        Vert(12).X = Vert(6).X
        Vert(12).Y = .Top + .Height - shfty1
        Vert(13).X = Vert(5).X
        Vert(13).Y = .Top + .Height
        Vert(14).X = Vert(4).X
        Vert(14).Y = Vert(12).Y
        Vert(15).X = Vert(3).X
        Vert(15).Y = Vert(11).Y
        Vert(16).X = Vert(2).X
        Vert(16).Y = Vert(10).Y
        
        Vert(17) = Vert(1)
        
    End With
End Sub

Private Sub SetVertices5pointStar(shp As Shape)
    Dim shftx1       As Long
    Dim shftx2       As Long
    Dim shftx3       As Long
    Dim shfty1       As Long
    Dim shfty2       As Long
    Dim shfty3       As Long
    
    InitVertices 11
    With shp
        shftx1 = .Width * 0.191
        shftx2 = .Width * 0.309
        shftx3 = .Width * 0.382
        shfty1 = .Height * 0.382
        shfty2 = .Height - shfty1
        shfty3 = .Height * 0.764
        
        Vert(1).X = .Left
        Vert(1).Y = .Top + shfty1
        Vert(2).X = .Left + shftx3
        Vert(2).Y = Vert(1).Y
        Vert(3).X = .Left + .Width / 2
        Vert(3).Y = .Top
        Vert(4).X = .Left + .Width - shftx3
        Vert(4).Y = Vert(2).Y
        Vert(5).X = .Left + .Width
        Vert(5).Y = Vert(2).Y
        Vert(6).X = .Left + .Width - shftx2
        Vert(6).Y = .Top + shfty2
        Vert(7).X = .Left + .Width - shftx1
        Vert(7).Y = .Top + .Height
        Vert(8).X = Vert(3).X
        Vert(8).Y = .Top + shfty3
        Vert(9).X = .Left + shftx1
        Vert(9).Y = Vert(7).Y
        Vert(10).X = .Left + shftx2
        Vert(10).Y = Vert(6).Y
        
        Vert(11) = Vert(1)
        
    End With
End Sub

Private Sub SetVertices4pointStar(shp As Shape)
    Dim ratio       As Single
    Dim shftx       As Long
    Dim shfty       As Long
    
    InitVertices 9
    With shp
        On Error Resume Next
        ratio = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio = 0.375
        End If
        ratio = 0.5 - (0.25 - 0.5 * ratio) * Sqr(2)
        shftx = .Width * ratio
        shfty = .Height * ratio
        
        Vert(1).X = .Left
        Vert(1).Y = .Top + .Height / 2
        Vert(2).X = .Left + shftx
        Vert(2).Y = .Top + shfty
        Vert(3).X = .Left + .Width / 2
        Vert(3).Y = .Top
        Vert(4).X = .Left + .Width - shftx
        Vert(4).Y = Vert(2).Y
        Vert(5).X = .Left + .Width
        Vert(5).Y = Vert(1).Y
        Vert(6).X = Vert(4).X
        Vert(6).Y = .Top + .Height - shfty
        Vert(7).X = Vert(3).X
        Vert(7).Y = .Top + .Height
        Vert(8).X = Vert(2).X
        Vert(8).Y = Vert(6).Y
        
        Vert(9) = Vert(1)
    End With
End Sub

Private Sub SetVerticesExplosion2(shp As Shape)
    
    InitVertices 29
    With shp
        
        Vert(1).X = .Left
        Vert(1).Y = .Top + .Height * 0.598
        Vert(7).X = .Left + .Width * 0.451
        Vert(7).Y = .Top + .Height * 0.089
        Vert(13).X = .Left + .Width
        Vert(13).Y = .Top + .Height * 0.311
        Vert(21).X = .Left + .Width * 0.538
        Vert(21).Y = .Top + .Height * 0.873
        
        Vert(2).X = .Left + .Width * 0.183
        Vert(3).X = .Left + .Width * 0.055
        Vert(4).X = .Left + .Width * 0.249
        Vert(5).X = .Left + .Width * 0.207
        Vert(6).X = .Left + .Width * 0.397
        Vert(8).X = .Left + .Width * 0.53
        Vert(9).X = .Left + .Width * 0.684
        Vert(10).X = .Left + .Width * 0.673
        Vert(11).X = .Left + .Width * 0.837
        Vert(12).X = .Left + .Width * 0.759
        Vert(14).X = .Left + .Width * 0.787
        Vert(15).X = .Left + .Width * 0.846
        Vert(16).X = .Left + .Width * 0.76
        Vert(17).X = .Left + .Width * 0.875
        Vert(18).X = .Left + .Width * 0.679
        Vert(19).X = .Left + .Width * 0.692
        Vert(20).X = .Left + .Width * 0.567
        Vert(22).X = .Left + .Width * 0.458
        Vert(23).X = .Left + .Width * 0.403
        Vert(24).X = .Left + .Width * 0.35
        Vert(25).X = .Left + .Width * 0.228
        Vert(26).X = .Left + .Width * 0.222
        Vert(27).X = .Left + .Width * 0.057
        Vert(28).X = .Left + .Width * 0.154
        
        Vert(2).Y = .Top + .Height * 0.541
        Vert(3).Y = .Top + .Height * 0.384
        Vert(4).Y = .Top + .Height * 0.364
        Vert(5).Y = .Top + .Height * 0.17
        Vert(6).Y = .Top + .Height * 0.295
        Vert(8).Y = .Top + .Height * 0.2
        Vert(9).Y = .Top
        Vert(10).Y = .Top + .Height * 0.266
        Vert(11).Y = .Top + .Height * 0.148
        Vert(12).Y = .Top + .Height * 0.305
        Vert(14).Y = .Top + .Height * 0.436
        Vert(15).Y = .Top + .Height * 0.523
        Vert(16).Y = .Top + .Height * 0.57
        Vert(17).Y = .Top + .Height * 0.725
        Vert(18).Y = .Top + .Height * 0.668
        Vert(19).Y = .Top + .Height * 0.807
        Vert(20).Y = .Top + .Height * 0.739
        Vert(22).Y = .Top + .Height * 0.807
        Vert(23).Y = .Top + .Height * 0.911
        Vert(24).Y = .Top + .Height * 0.839
        Vert(25).Y = .Top + .Height
        Vert(26).Y = .Top + .Height * 0.845
        Vert(27).Y = .Top + .Height * 0.825
        Vert(28).Y = .Top + .Height * 0.714
        
        Vert(29) = Vert(1)
        
    End With
End Sub
Private Sub SetVerticesExplosion1(shp As Shape)
    
    InitVertices 25
    With shp
        
        Vert(1).X = .Left
        Vert(1).Y = .Top + .Height * 0.397
        Vert(7).X = .Left + .Width * 0.672
        Vert(7).Y = .Top
        Vert(13).X = .Left + .Width
        Vert(13).Y = .Top + .Height * 0.614
        Vert(19).X = .Left + .Width * 0.394
        Vert(19).Y = .Top + .Height
        
        Vert(2).X = .Left + .Width * 0.217
        Vert(3).X = .Left + .Width * 0.021
        Vert(4).X = .Left + .Width * 0.34
        Vert(5).X = .Left + .Width * 0.389
        Vert(6).X = .Left + .Width * 0.502
        Vert(8).X = .Left + .Width * 0.656
        Vert(9).X = .Left + .Width * 0.854
        Vert(10).X = .Left + .Width * 0.781
        Vert(11).X = .Left + .Width * 0.979
        Vert(12).X = .Left + .Width * 0.814
        Vert(14).X = .Left + .Width * 0.781
        Vert(15).X = .Left + .Width * 0.84
        Vert(16).X = .Left + .Width * 0.651
        Vert(17).X = .Left + .Width * 0.616
        Vert(18).X = .Left + .Width * 0.488
        Vert(20).X = .Left + .Width * 0.358
        Vert(21).X = .Left + .Width * 0.224
        Vert(22).X = .Left + .Width * 0.264
        Vert(23).X = .Left + .Width * 0.012
        Vert(24).X = .Left + .Width * 0.172
        
        Vert(2).Y = .Top + .Height * 0.35
        Vert(3).Y = .Top + .Height * 0.107
        Vert(4).Y = .Top + .Height * 0.29
        Vert(5).Y = .Top + .Height * 0.105
        Vert(6).Y = .Top + .Height * 0.266
        Vert(8).Y = .Top + .Height * 0.25
        Vert(9).Y = .Top + .Height * 0.208
        Vert(10).Y = .Top + .Height * 0.339
        Vert(11).Y = .Top + .Height * 0.379
        Vert(12).Y = .Top + .Height * 0.481
        Vert(14).Y = .Top + .Height * 0.603
        Vert(15).Y = .Top + .Height * 0.836
        Vert(16).Y = .Top + .Height * 0.673
        Vert(17).Y = .Top + .Height * 0.916
        Vert(18).Y = .Top + .Height * 0.694
        Vert(20).Y = .Top + .Height * 0.727
        Vert(21).Y = .Top + .Height * 0.818
        Vert(22).Y = .Top + .Height * 0.645
        Vert(23).Y = .Top + .Height * 0.675
        Vert(24).Y = .Top + .Height * 0.547
        
        Vert(25) = Vert(1)
        
    End With
End Sub

Private Sub SetVerticesConnectorCurve(shp As Shape)
    Dim ratio1          As Single
    Dim ratio2          As Single
    Dim ratio3          As Single
    Dim ratNum          As Long
    
    On Error Resume Next
    ratio1 = shp.Adjustments(1)
    If Err.Number <> 0 Then     ' no adjustments
        VertNum = 6     ' two more to display the line arrow
        ' now the polylines support arrow, so the two more vertices are no more
        ' necessary, but to avoid mistakes, they are maintained.
        
        ratNum = 0
        Err.Clear
    Else
        ratio2 = shp.Adjustments(2)
        If Err.Number <> 0 Then
            VertNum = 9
            ratNum = 1
            Err.Clear
        Else
            ratio3 = shp.Adjustments(3)
            If Err.Number <> 0 Then
                VertNum = 12
                ratNum = 2
                Err.Clear
            Else
                VertNum = 15
                ratNum = 3
            End If
        End If
    End If

    ReDim Vert(1 To VertNum) As aofNode
    
    Vert(1).X = shp.Left
    Vert(1).Y = shp.Top
    Vert(VertNum).X = shp.Left + shp.Width
    Vert(VertNum).Y = shp.Top + shp.Height
    
    Dim arrh    As Boolean
    Dim arre    As Boolean
    Dim numOfArrow  As Long
    
    Dim connw    As Single
    Dim connh   As Single
    
    connw = Vert(VertNum).X - Vert(1).X
    connh = Vert(VertNum).Y - Vert(1).Y
    
    If connw = 0 Then
        connw = 0.1
    End If
    If connh = 0 Then
        connh = 0.1
    End If
    
    Select Case ratNum
        Case 0
            Vert(2).X = Vert(1).X '+ 1    ' same to v(1)
            Vert(2).Y = Vert(1).Y
            Vert(2).SegType = msoSegmentCurve
            Vert(5).X = Vert(VertNum).X
            Vert(5).Y = Vert(VertNum).Y '- 1  ' same to v(6)
            Vert(5).SegType = msoSegmentLine
            Vert(3).X = (Vert(1).X + Vert(VertNum).X) / 2
            Vert(3).Y = Vert(1).Y
            Vert(4).X = Vert(VertNum).X
            Vert(4).Y = (Vert(1).Y + Vert(VertNum).Y) / 2
        Case 1
            Vert(2).X = Vert(1).X '+ 1
            Vert(2).Y = Vert(1).Y
            Vert(2).SegType = msoSegmentCurve
            Vert(8).X = Vert(VertNum).X
            Vert(8).Y = Vert(VertNum).Y '- 1
            Vert(8).SegType = msoSegmentLine
            Vert(5).X = Vert(1).X + connw * ratio1
            Vert(5).Y = (Vert(1).Y + Vert(VertNum).Y) / 2
            Vert(5).SegType = msoSegmentCurve
            Vert(3).X = (Vert(1).X + Vert(5).X) / 2
            Vert(3).Y = Vert(1).Y
            Vert(4).X = Vert(5).X
            Vert(4).Y = (Vert(1).Y + Vert(5).Y) / 2
            
            Vert(6).X = Vert(5).X
            Vert(6).Y = (Vert(5).Y + Vert(VertNum).Y) / 2
            Vert(7).X = (Vert(5).X + Vert(VertNum).X) / 2
            Vert(7).Y = Vert(VertNum).Y
        Case 2
            Vert(2).X = Vert(1).X '+ 1
            Vert(2).Y = Vert(1).Y
            Vert(2).SegType = msoSegmentCurve
            Vert(11).X = Vert(VertNum).X
            Vert(11).Y = Vert(VertNum).Y '- 1
            
            Vert(5).X = Vert(1).X + connw * ratio1
            Vert(8).Y = Vert(1).Y + connh * ratio2
            Vert(5).Y = (Vert(1).Y + Vert(8).Y) / 2
            Vert(8).X = (Vert(5).X + Vert(VertNum).X) / 2
            Vert(5).SegType = msoSegmentCurve
            Vert(8).SegType = msoSegmentCurve
            
            Vert(3).X = (Vert(1).X + Vert(5).X) / 2
            Vert(3).Y = Vert(1).X
            Vert(4).X = Vert(5).X
            Vert(4).Y = (Vert(1).Y + Vert(5).Y) / 2
            
            Vert(6).X = Vert(5).X
            Vert(6).Y = (Vert(5).Y + Vert(8).Y) / 2
            Vert(7).X = (Vert(5).X + Vert(8).X) / 2
            Vert(7).Y = Vert(8).Y
            
            Vert(9).X = (Vert(8).X + Vert(VertNum).X) / 2
            Vert(9).Y = Vert(8).Y
            Vert(10).X = Vert(VertNum).X
            Vert(10).Y = (Vert(8).Y + Vert(VertNum).Y) / 2
        Case 3
            Vert(2).X = Vert(1).X '+ 1
            Vert(2).Y = Vert(1).Y
            Vert(2).SegType = msoSegmentCurve
            Vert(14).X = Vert(VertNum).X '- 1
            Vert(14).Y = Vert(VertNum).Y
            
            Vert(5).X = Vert(1).X + connw * ratio1
            Vert(8).Y = Vert(1).Y + connh * ratio2
            Vert(11).X = Vert(1).X + connw * ratio3
            
            Vert(5).Y = (Vert(1).Y + Vert(8).Y) / 2
            Vert(8).X = (Vert(5).X + Vert(11).X) / 2
            Vert(11).Y = (Vert(8).Y + Vert(VertNum).Y) / 2
            Vert(5).SegType = msoSegmentCurve
            Vert(8).SegType = msoSegmentCurve
            Vert(11).SegType = msoSegmentCurve
            
            Vert(3).X = (Vert(1).X + Vert(5).X) / 2
            Vert(3).Y = Vert(1).Y
            Vert(4).X = Vert(5).X
            Vert(4).Y = (Vert(1).Y + Vert(5).Y) / 2
            
            Vert(6).X = Vert(5).X
            Vert(6).Y = (Vert(5).Y + Vert(8).Y) / 2
            Vert(7).X = (Vert(5).X + Vert(8).X) / 2
            Vert(7).Y = Vert(8).Y
            
            Vert(9).X = (Vert(8).X + Vert(11).X) / 2
            Vert(9).Y = Vert(8).Y
            Vert(10).X = Vert(11).X
            Vert(10).Y = (Vert(8).Y + Vert(11).Y) / 2
            
            Vert(12).X = Vert(11).X
            Vert(12).Y = (Vert(11).Y + Vert(VertNum).Y) / 2
            Vert(13).X = (Vert(11).X + Vert(VertNum).X) / 2
            Vert(13).Y = Vert(VertNum).Y
    End Select
End Sub

Private Sub ParseConnectorCurve(shp As Shape, Optional bRotateNodes As Boolean = True)
    
    ShapeType = aofShapeTypePolygon
    
    If SetGraphmode(shp) Then    ' lineart and fillart are set here
        'ErrLog aofErrInvisibleShape, "invisible Polygon"
        Exit Sub
    End If
    
    'SetLineArt shp
    
    NewFlipNodes shp
    NewRotateNodes shp
    PrintPointsString
End Sub

Private Sub SetVerticesConnectorElbow(shp As Shape)
    Dim ratio1          As Single
    Dim ratio2          As Single
    Dim ratio3          As Single
    Dim ratNum          As Long
    
    On Error Resume Next
    ratio1 = shp.Adjustments(1)
    If Err.Number <> 0 Then     ' no adjustments
        VertNum = 3
        ratNum = 0
        Err.Clear
    Else
        ratio2 = shp.Adjustments(2)
        If Err.Number <> 0 Then
            VertNum = 4
            ratNum = 1
            Err.Clear
        Else
            ratio3 = shp.Adjustments(3)
            If Err.Number <> 0 Then
                VertNum = 5
                ratNum = 2
                Err.Clear
            Else
                VertNum = 6
                ratNum = 3
            End If
        End If
    End If

    ReDim Vert(1 To VertNum) As aofNode
    
    Vert(1).X = shp.Left
    Vert(1).Y = shp.Top
    Vert(VertNum).X = shp.Left + shp.Width
    Vert(VertNum).Y = shp.Top + shp.Height
    
    Dim arrh    As Boolean
    Dim arre    As Boolean
    Dim numOfArrow  As Long
    
    Dim connw    As Single
    Dim connh   As Single
    
    connw = Vert(VertNum).X - Vert(1).X
    connh = Vert(VertNum).Y - Vert(1).Y
    
    If connw = 0 Then
        connw = 0.1
    End If
    If connh = 0 Then
        connh = 0.1
    End If
    
    Select Case ratNum
        Case 0
            Vert(2).X = Vert(3).X
            Vert(2).Y = Vert(1).Y
        Case 1
            Vert(2).X = Vert(1).X + connw * ratio1
            Vert(2).Y = Vert(1).Y
            Vert(3).X = Vert(2).X
            Vert(3).Y = Vert(4).Y
        Case 2
            Vert(2).X = Vert(1).X + connw * ratio1
            Vert(2).Y = Vert(1).Y
            Vert(3).X = Vert(2).X
            Vert(3).Y = Vert(1).Y + connh * ratio2
            Vert(4).X = Vert(5).X
            Vert(4).Y = Vert(3).Y
        Case 3
            Vert(2).X = Vert(1).X + connw * ratio1
            Vert(2).Y = Vert(1).Y
            Vert(3).X = Vert(2).X
            Vert(3).Y = Vert(1).Y + connh * ratio2
            Vert(4).X = Vert(1).X + connw * ratio3
            Vert(4).Y = Vert(3).Y
            Vert(5).X = Vert(4).X
            Vert(5).Y = Vert(6).Y
    End Select

End Sub

Private Sub ParseConnectorElbow(shp As Shape, Optional bRotateNodes As Boolean = True)
    
    ShapeType = aofShapeTypePolygon
    
    If SetGraphmode(shp) Then    ' lineart and fillart are set here
        'ErrLog aofErrInvisibleShape, "invisible Polygon"
        Exit Sub
    End If
    
'    SetLineArt shp
    
    'NewFlipNodes shp
    NewRotateNodes shp
    
    PrintPointsString
End Sub

Private Sub SetVerticesConnectorStraight(shp As Shape)
    Dim arrhead As Boolean
    Dim arrend   As Boolean
    
    InitVertices 2
    
    With shp
        Vert(2).X = .Left + .Width
        Vert(1).X = .Left
        Vert(2).Y = .Top + .Height
        Vert(1).Y = .Top
    End With
End Sub

Private Sub ParseConnectorStraight(shp As Shape, Optional bRotateNodes As Boolean = True)
    Dim arrhead As Boolean
    Dim arrend   As Boolean
    
    SetLineArt shp
    
    If shp.Line.BeginArrowheadStyle <> msoArrowheadNone Then
        arrhead = True
    End If
    If shp.Line.EndArrowheadStyle <> msoArrowheadNone Then
        arrend = True
    End If
    
    NewFlipNodes shp
    NewRotateNodes shp
    
    ShapeType = aofShapeTypeLine
    BuildLineWithVert arrhead, arrend
End Sub

Sub FlipNodes(ByRef v() As aofNode, num As Long, shp As Shape)
    Dim midline     As Long
    Dim i           As Long
    
    If shp.VerticalFlip = msoTrue Then
        'midline = v(1).y + v(num).y
        midline = shp.Top * 2 + shp.Height
        For i = 1 To num
            v(i).Y = midline - v(i).Y
        Next
    End If
    If shp.HorizontalFlip = msoTrue Then
        'midline = v(1).x + v(num).x
        midline = shp.Left * 2 + shp.Width
        For i = 1 To num
            v(i).X = midline - v(i).X
        Next
    End If
End Sub


Sub SetVerts(v() As aofNode, beginNum As Long, num As Long)
    HasVertices = True
    VertNum = num
    ReDim Vert(1 To VertNum) As aofNode
    
    Dim i   As Long
    For i = 1 To VertNum
        Vert(i) = v(i + beginNum - 1)
    Next
End Sub

Sub BuildLineWithVert(arrhead As Boolean, arrend As Boolean)
    ShapeType = aofShapeTypeLine
    If arrhead Then
        If arrend Then
            ArrowStyle = "both"
        Else
            ArrowStyle = "first"
        End If
    Else
        If arrend Then
            ArrowStyle = "last"
        Else
            ArrowStyle = "none"
        End If
    End If
    
    X = Vert(1).X
    Y = Vert(1).Y
    
    Width = Vert(2).X - Vert(1).X
    Height = Vert(2).Y - Vert(1).Y
    
End Sub
Private Sub SetVerticesRightBrace(shp As Shape)
    Dim shfty   As Long
    Dim shftp   As Long
    
    InitVertices 15
    With shp
        On Error Resume Next
        shfty = .Height * .Adjustments(1)
        If Err.Number <> 0 Then
            shfty = .Height * 0.08333334
            Err.Clear
        End If
        shftp = .Height * .Adjustments(2)
        If Err.Number <> 0 Then
            shftp = .Height / 2
        End If
        
        Vert(1).X = .Left
        Vert(1).Y = .Top
        Vert(1).SegType = msoSegmentCurve
        Vert(2).X = .Left + .Width / 4
        Vert(2).Y = .Top
        Vert(2).SegType = msoSegmentCurve
        Vert(3).X = .Left + .Width / 2
        Vert(3).Y = .Top + shfty / 2
        Vert(3).SegType = msoSegmentCurve
        Vert(4).X = Vert(3).X
        Vert(4).Y = .Top + shfty
        
        Vert(8).X = .Left + .Width
        Vert(8).Y = .Top + shftp
        Vert(8).SegType = msoSegmentCurve
        
        Vert(5).X = Vert(4).X
        Vert(5).Y = Vert(8).Y - shfty
        Vert(5).SegType = msoSegmentCurve
        Vert(6).X = Vert(5).X
        Vert(6).Y = Vert(5).Y + shfty / 2
        Vert(6).SegType = msoSegmentCurve
        Vert(7).X = Vert(8).X - .Width / 4
        Vert(7).Y = Vert(8).Y
        Vert(7).SegType = msoSegmentCurve
        
        Vert(9) = Vert(7)
        Vert(11).X = Vert(5).X
        Vert(11).Y = Vert(8).Y + shfty
        Vert(10).X = Vert(11).X
        Vert(10).Y = Vert(11).Y - shfty / 2
        Vert(10).SegType = msoSegmentCurve
        
        Vert(12).X = Vert(11).X
        Vert(12).Y = .Top + .Height - shfty
        Vert(12).SegType = msoSegmentCurve
        Vert(13).X = Vert(12).X
        Vert(13).Y = Vert(12).Y + shfty / 2
        Vert(13).SegType = msoSegmentCurve
        Vert(14).X = Vert(2).X
        Vert(14).Y = .Top + .Height
        Vert(14).SegType = msoSegmentCurve
        Vert(15).X = Vert(1).X
        Vert(15).Y = Vert(14).Y
    End With
End Sub

Private Sub SetVerticesLeftBrace(shp As Shape)
    Dim shfty   As Long
    Dim shftp   As Long
    
    InitVertices 15
    With shp
        On Error Resume Next
        shfty = .Height * .Adjustments(1)
        If Err.Number <> 0 Then
            shfty = .Height * 0.08333334
            Err.Clear
        End If
        shftp = .Height * .Adjustments(2)
        If Err.Number <> 0 Then
            shftp = .Height / 2
        End If
        
        Vert(1).X = .Left + .Width
        Vert(1).Y = .Top
        Vert(1).SegType = msoSegmentCurve
        Vert(2).X = .Left + .Width * 3 / 4
        Vert(2).Y = .Top
        Vert(2).SegType = msoSegmentCurve
        Vert(3).X = .Left + .Width / 2
        Vert(3).Y = .Top + shfty / 2
        Vert(3).SegType = msoSegmentCurve
        Vert(4).X = Vert(3).X
        Vert(4).Y = .Top + shfty
        
        Vert(8).X = .Left
        Vert(8).Y = .Top + shftp
        Vert(8).SegType = msoSegmentCurve
        
        Vert(5).X = Vert(4).X
        Vert(5).Y = Vert(8).Y - shfty
        Vert(5).SegType = msoSegmentCurve
        Vert(6).X = Vert(5).X
        Vert(6).Y = Vert(5).Y + shfty / 2
        Vert(6).SegType = msoSegmentCurve
        Vert(7).X = Vert(8).X + .Width / 4
        Vert(7).Y = Vert(8).Y
        Vert(7).SegType = msoSegmentCurve
        
        Vert(9) = Vert(7)
        Vert(11).X = Vert(5).X
        Vert(11).Y = Vert(8).Y + shfty
        Vert(10).X = Vert(11).X
        Vert(10).Y = Vert(11).Y - shfty / 2
        Vert(10).SegType = msoSegmentCurve
        
        Vert(12).X = Vert(11).X
        Vert(12).Y = .Top + .Height - shfty
        Vert(12).SegType = msoSegmentCurve
        Vert(13).X = Vert(12).X
        Vert(13).Y = Vert(12).Y + shfty / 2
        Vert(13).SegType = msoSegmentCurve
        Vert(14).X = Vert(2).X
        Vert(14).Y = .Top + .Height
        Vert(14).SegType = msoSegmentCurve
        Vert(15).X = Vert(1).X
        Vert(15).Y = Vert(14).Y
        
    End With
End Sub
Private Sub SetVerticesRightBrackt(shp As Shape)
    Dim shft    As Long
        
    InitVertices 8
    With shp
        On Error Resume Next
        shft = .Height * .Adjustments(1)
        If Err.Number <> 0 Then
            shft = .Height * 0.08333334
        End If
        
        Vert(1).X = .Left
        Vert(1).Y = .Top
        Vert(1).SegType = msoSegmentCurve
        Vert(2).X = .Left + .Width / 2
        Vert(2).Y = .Top
        Vert(2).SegType = msoSegmentCurve
        Vert(3).X = .Left + .Width
        Vert(3).Y = .Top + shft / 2
        Vert(3).SegType = msoSegmentCurve
        Vert(4).X = Vert(3).X
        Vert(4).Y = .Top + shft
        
        Vert(5).X = Vert(3).X
        Vert(5).Y = .Top + .Height - shft
        Vert(5).SegType = msoSegmentCurve
        Vert(6).X = Vert(3).X
        Vert(6).Y = .Top + .Height - shft / 2
        Vert(6).SegType = msoSegmentCurve
        Vert(7).X = Vert(2).X
        Vert(7).Y = .Top + .Height
        Vert(7).SegType = msoSegmentCurve
        Vert(8).X = Vert(1).X
        Vert(8).Y = .Top + .Height
        
    End With
End Sub

Private Sub SetVerticesLeftBrackt(shp As Shape)
    Dim shft    As Long
    InitVertices 8
    With shp
        On Error Resume Next
        shft = .Height * .Adjustments(1)
        If Err.Number <> 0 Then
            shft = .Height * 0.08333334
        End If
        
        Vert(1).X = .Left + .Width
        Vert(1).Y = .Top
        Vert(1).SegType = msoSegmentCurve
        Vert(2).X = .Left + .Width / 2
        Vert(2).Y = .Top
        Vert(2).SegType = msoSegmentCurve
        Vert(3).X = .Left
        Vert(3).Y = .Top + shft / 2
        Vert(3).SegType = msoSegmentCurve
        Vert(4).X = Vert(3).X
        Vert(4).Y = .Top + shft
        
        Vert(5).X = Vert(3).X
        Vert(5).Y = .Top + .Height - shft
        Vert(5).SegType = msoSegmentCurve
        Vert(6).X = Vert(3).X
        Vert(6).Y = .Top + .Height - shft / 2
        Vert(6).SegType = msoSegmentCurve
        Vert(7).X = Vert(2).X
        Vert(7).Y = .Top + .Height
        Vert(7).SegType = msoSegmentCurve
        Vert(8).X = Vert(1).X
        Vert(8).Y = .Top + .Height
    End With
End Sub

Private Sub SetVerticesUTurnArrow(shp As Shape)
    Dim NeckW   As Long
    Dim ArrW    As Long
    Dim ArrP    As Long
    Dim NeckL   As Long
    Dim BowHfL    As Long
    Dim BowHfR      As Long
    Dim BowWdL      As Long
    Dim BowWdR      As Long
    
    InitVertices 20
    With shp
        NeckW = .Width * 0.2834
        NeckL = .Height * 0.615      '0.63
        ArrW = .Width * 0.551       '0.5833
        ArrP = .Height * 0.66
        
        Vert(1).X = .Left
        Vert(1).Y = .Top + .Height
        
        Vert(2).X = .Left
        Vert(2).Y = .Top + .Height - NeckL
        Vert(2).SegType = msoSegmentCurve
        
        Vert(9).X = .Left + .Width
        Vert(9).Y = Vert(2).Y
        
        Vert(11).X = Vert(9).X - ArrW
        Vert(11).Y = Vert(9).Y
        
        Vert(10).X = (Vert(9).X + Vert(11).X) / 2
        Vert(10).Y = .Top + ArrP
        
        Vert(8).X = Vert(9).X - (ArrW - NeckW) / 2
        Vert(8).Y = Vert(9).Y
        
        Vert(12).X = Vert(8).X - NeckW
        Vert(12).Y = Vert(8).Y
        Vert(12).SegType = msoSegmentCurve
        
        Vert(18).X = .Left + NeckW
        Vert(18).Y = Vert(2).Y
        
        BowHfL = (Vert(8).X - Vert(2).X) / 2
        BowHfR = (Vert(12).X - Vert(18).X) / 2
        
        Vert(5).X = Vert(2).X + BowHfL
        Vert(5).Y = .Top
        Vert(5).SegType = msoSegmentCurve
        
        BowWdL = Vert(2).Y - Vert(5).Y
        BowWdR = BowWdL * BowHfR / BowHfL
        
        Vert(15).X = Vert(5).X
        Vert(15).Y = Vert(18).Y - BowWdR
        Vert(15).SegType = msoSegmentCurve
        
        Vert(3).X = Vert(2).X
        Vert(3).Y = Vert(2).Y - BowWdL / 2
        Vert(3).SegType = msoSegmentCurve
        
        Vert(4).X = Vert(5).X - BowHfL / 2
        Vert(4).Y = Vert(5).Y
        Vert(4).SegType = msoSegmentCurve
        Vert(6).X = Vert(5).X + BowHfL / 2
        Vert(6).Y = Vert(5).Y
        Vert(6).SegType = msoSegmentCurve
        
        Vert(7).X = Vert(8).X
        Vert(7).Y = Vert(3).Y
        Vert(7).SegType = msoSegmentCurve
        
        Vert(13).X = Vert(12).X
        Vert(13).Y = Vert(12).Y - BowWdR / 2
        Vert(13).SegType = msoSegmentCurve
        Vert(14).X = Vert(15).X + BowHfR / 2
        Vert(14).Y = Vert(15).Y
        Vert(14).SegType = msoSegmentCurve
        Vert(16).X = Vert(15).X - BowHfR / 2
        Vert(16).Y = Vert(15).Y
        Vert(16).SegType = msoSegmentCurve
        Vert(17).X = Vert(18).X
        Vert(17).Y = Vert(13).Y
        Vert(17).SegType = msoSegmentCurve
        
        Vert(19).X = Vert(18).X
        Vert(19).Y = Vert(1).Y
        Vert(20) = Vert(1)
        
    End With
End Sub

Private Sub SetVerticesBentArrow(shp As Shape)
    Dim ratiox      As Single
    Dim ratioy      As Single
    Dim bzrRatio    As Single
    Dim ArrP        As Long
    Dim NeckW       As Long
    Dim ShdL        As Long
    Dim ShdR        As Long
    
    InitVertices 16
    With shp
        On Error Resume Next
        ratiox = .Adjustments(1)
        If Err.Number <> 0 Then
            ratiox = 0.7002778
            Err.Clear
        End If
        ratioy = .Adjustments(2)
        If Err.Number <> 0 Then
            ratioy = 0.1348148
        End If
        
        ArrP = .Height * 0.2814352
        ShdL = .Height * ratioy
        ShdR = ArrP * 2 - ShdL
        NeckW = .Width * (0.5753241 - 0.5753241 * ratioy / 0.2814352)
        
        bzrRatio = 0.5
        
        Vert(1).X = .Left
        Vert(1).Y = .Top + .Height
        
        Vert(2).X = .Left
        Vert(2).Y = .Top + ArrP * 2
        Vert(2).SegType = msoSegmentCurve
        Vert(5).X = .Left + .Width * 0.5753241
        Vert(5).Y = .Top + ShdL
        Vert(3).X = Vert(2).X
        Vert(3).Y = Vert(2).Y - (Vert(2).Y - Vert(5).Y) * bzrRatio
        Vert(3).SegType = msoSegmentCurve
        Vert(4).X = Vert(5).X - (Vert(5).X - Vert(2).X) * bzrRatio
        Vert(4).Y = Vert(5).Y
        Vert(4).SegType = msoSegmentCurve
        
        Vert(6).X = .Left + .Width * ratiox
        Vert(6).Y = Vert(5).Y
        Vert(7).X = Vert(6).X
        Vert(7).Y = .Top
        Vert(8).X = .Left + .Width
        Vert(8).Y = .Top + ArrP
        Vert(9).X = Vert(7).X
        Vert(9).Y = Vert(2).Y
        Vert(10).X = Vert(6).X
        Vert(10).Y = .Top + ShdR
        
        Vert(11).X = Vert(5).X
        Vert(11).Y = Vert(10).Y
        Vert(11).SegType = msoSegmentCurve
        Vert(14).X = .Left + NeckW
        Vert(14).Y = Vert(2).Y
        Vert(12).X = Vert(11).X - (Vert(11).X - Vert(14).X) * bzrRatio
        Vert(12).Y = Vert(11).Y
        Vert(12).SegType = msoSegmentCurve
        Vert(13).X = Vert(14).X
        Vert(13).Y = Vert(14).Y - (Vert(14).Y - Vert(11).Y) * bzrRatio
        Vert(13).SegType = msoSegmentCurve
        
        Vert(15).X = Vert(14).X
        Vert(15).Y = .Top + .Height
        
        Vert(16) = Vert(1)
    End With
End Sub

Private Sub SetVerticesFoldedCorner(shp As Shape)
    Dim i           As Long
    Dim ratio        As Single
    Dim curveH        As Single
    Dim shftx       As Long
    Dim shfty   As Long
    
    With shp
        InitVertices 10
        
        On Error Resume Next
        ratio = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio = 0.875
        End If
        
        shftx = .Width * ratio
        shfty = .Height * ratio
        
        ' the paper
        Vert(1).X = .Left + shftx
        Vert(1).Y = .Top + .Height
        Vert(2).X = .Left
        Vert(2).Y = .Top + .Height
        Vert(3).X = .Left
        Vert(3).Y = .Top
        Vert(4).X = .Left + .Width
        Vert(4).Y = .Top
        Vert(5).X = .Left + .Width
        Vert(5).Y = .Top + shfty
        Vert(6) = Vert(1)
        
        ' the folded corner
        curveH = 0.16
        Dim rx As Single
        Dim ry As Single
        
        rx = 0.73 * ratio + 0.27
        ry = 0.96 * ratio + 0.04
        
        Vert(7).X = .Left + .Width * rx
        Vert(7).Y = .Top + .Height * ry
        Vert(7).SegType = msoSegmentCurve
        Vert(8).X = .Left + .Width * (0.2 + 0.8 * rx)
        Vert(8).Y = .Top + .Height * (ratio + curveH * (1 - ratio))
        'Vert(8).SegType = msoSegmentCurve
        Vert(9).X = .Left + .Width * (0.5 + 0.5 * rx)
        Vert(9).Y = Vert(8).Y
        'Vert(9).SegType=msoSegmentCurve
        Vert(10) = Vert(5)
        
     End With

End Sub

Private Sub ParseFoldedCorner(shp As Shape)
    Dim i           As Long
    Dim ratio        As Single
    Dim curveH        As Single
    Dim shftx       As Long
    Dim shfty   As Long
    
    NewRotateNodes shp
    
    AddGroupItem
    With GroupItems(GroupItemNum)
        .ShapeType = aofShapeTypePolygon
        .SetGraphstyle shp
        .InitVerts 1, 6, Vert, True
        .PrintPointsString
    End With
    
    Dim bSolidFilled As Boolean
    Dim colorCorner  As String
    Dim colorDumm  As String
    
    If shp.Fill.Visible = msoTrue Then
        bSolidFilled = True
        SetRelatedColors shp.Fill.ForeColor.RGB, colorDumm, colorDumm, colorCorner, colorDumm
    Else
        bSolidFilled = False
    End If
    
    AddGroupItem
    With GroupItems(GroupItemNum)
        .ShapeType = aofShapeTypePolygon
        .SetGraphstyle shp
        .FillColor = colorCorner
        .InitVerts 5, 6, Vert, True
        .PrintPointsString
    End With
    
    ShapeType = aofShapeTypeUserDefinedGroup
End Sub

Private Sub SetVerticesPlaque(shp As Shape)
    Dim cirRatio    As Single
    Dim ratio   As Single
    Dim shftx   As Long
    Dim shfty   As Long
    Dim shft    As Long
    
    InitVertices 17
    With shp
        cirRatio = 0.28
        On Error Resume Next
        ratio = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio = 0.1666667
        End If
        
        If .Width < .Height Then
            shft = .Width * ratio
        Else
            shft = .Height * ratio
        End If
        shftx = shft * cirRatio * 2
        shfty = shftx
        
        Vert(1).X = .Left
        Vert(1).Y = .Top + shft
        Vert(1).SegType = msoSegmentCurve
        Vert(2).X = Vert(1).X + shftx
        Vert(2).Y = Vert(1).Y
        Vert(2).SegType = msoSegmentCurve
        Vert(4).X = .Left + shft
        Vert(4).Y = .Top
        Vert(3).X = Vert(4).X
        Vert(3).Y = Vert(4).Y + shfty
        Vert(3).SegType = msoSegmentCurve
        
        Vert(5).X = .Left + .Width - shft
        Vert(5).Y = .Top
        Vert(5).SegType = msoSegmentCurve
        Vert(6).X = Vert(5).X
        Vert(6).Y = Vert(3).Y
        Vert(6).SegType = msoSegmentCurve
        Vert(8).X = .Left + .Width
        Vert(8).Y = Vert(1).Y
        Vert(7).X = Vert(8).X - shftx
        Vert(7).Y = Vert(8).Y
        Vert(7).SegType = msoSegmentCurve
        
        Vert(9).X = .Left + .Width
        Vert(9).Y = .Top + .Height - shft
        Vert(9).SegType = msoSegmentCurve
        Vert(10).X = Vert(7).X
        Vert(10).Y = Vert(9).Y
        Vert(10).SegType = msoSegmentCurve
        Vert(12).X = Vert(5).X
        Vert(12).Y = .Top + .Height
        Vert(11).X = Vert(12).X
        Vert(11).Y = Vert(12).Y - shfty
        Vert(11).SegType = msoSegmentCurve
        
        Vert(13).X = Vert(4).X
        Vert(13).Y = .Top + .Height
        Vert(13).SegType = msoSegmentCurve
        Vert(14).X = Vert(13).X
        Vert(14).Y = Vert(11).Y
        Vert(14).SegType = msoSegmentCurve
        Vert(16).X = Vert(1).X
        Vert(16).Y = Vert(9).Y
        Vert(15).X = Vert(2).X
        Vert(15).Y = Vert(10).Y
        Vert(15).SegType = msoSegmentCurve
        
        Vert(17) = Vert(1)
    End With
End Sub

Private Sub SetVerticesDoubleBrace(shp As Shape)
    Dim i           As Long
    Dim cirRatio    As Single
    Dim ratio       As Single
    Dim shft        As Long
    Dim shftx       As Long
    Dim shfty       As Long
    
    With shp
        InitVertices 30
        
        On Error Resume Next
        cirRatio = 0.28
        ratio = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio = 0.08333334
        End If
        
        If .Width < .Height Then
            shft = .Width * ratio
            shftx = shft * cirRatio * 2
        Else
            shft = .Height * ratio
            shftx = shft * cirRatio * 2
        End If
        shfty = shftx
        
        'left brace
        
        Vert(1).X = .Left + shft * 2
        Vert(1).Y = .Top
        Vert(1).SegType = msoSegmentCurve
        Vert(2).X = Vert(1).X - shftx
        Vert(2).Y = Vert(1).Y
        Vert(4).X = .Left + shft
        Vert(4).Y = .Top + shft
        Vert(3).X = Vert(4).X
        Vert(3).Y = Vert(4).Y - shfty
        
        Vert(5).X = Vert(4).X
        Vert(5).Y = .Top + .Height / 2 - shft
        Vert(5).SegType = msoSegmentCurve
        Vert(6).X = Vert(5).X
        Vert(6).Y = Vert(5).Y + shfty
        Vert(8).X = .Left
        Vert(8).Y = .Top + .Height / 2
        Vert(8).SegType = msoSegmentCurve
        Vert(7).X = Vert(8).X + shftx
        Vert(7).Y = Vert(8).Y
        
        Vert(9).X = Vert(7).X
        Vert(9).Y = Vert(7).Y
        Vert(11).X = Vert(5).X
        Vert(11).Y = Vert(8).Y + shft
        Vert(10).X = Vert(11).X
        Vert(10).Y = Vert(11).Y - shfty
        
        Vert(12).X = Vert(11).X
        Vert(12).Y = .Top + .Height - shft
        Vert(12).SegType = msoSegmentCurve
        Vert(13).X = Vert(12).X
        Vert(13).Y = Vert(12).Y + shfty
        Vert(15).X = Vert(1).X
        Vert(15).Y = .Top + .Height
        Vert(14).X = Vert(2).X
        Vert(14).Y = Vert(15).Y
        
        ' right brace
        For i = 1 To 15
            Vert(31 - i).Y = Vert(i).Y
        Next
        
        Vert(16).X = .Left + .Width - shft * 2
        Vert(16).SegType = msoSegmentCurve
        Vert(17).X = Vert(16).X + shftx
        Vert(19).X = .Left + .Width - shft
        Vert(18).X = Vert(19).X
        
        Vert(20).X = Vert(19).X
        Vert(20).SegType = msoSegmentCurve
        Vert(21).X = Vert(20).X
        Vert(23).X = .Left + .Width
        Vert(23).SegType = msoSegmentCurve
        Vert(22).X = Vert(23).X - shftx
        
        Vert(24) = Vert(22)
        Vert(26).X = Vert(20).X
        Vert(25).X = Vert(26).X
        
        Vert(27).X = Vert(26).X
        Vert(27).SegType = msoSegmentCurve
        Vert(28).X = Vert(27).X
        Vert(30).X = Vert(16).X
        Vert(29).X = Vert(17).X
        
    End With

End Sub

Private Sub ParseDoubleBrace(shp As Shape, Optional bRotateNodes As Boolean = True)
    Dim i           As Long
    
    SetGraphmode shp
    NewRotateNodes shp
    
    If GraphStyle = aofGraphStyleFilled Or GraphStyle = aofGraphStyleFilledOutline Then
        AddGroupItem
        With GroupItems(GroupItemNum)
            .ShapeType = aofShapeTypePolygon
            .GraphStyle = aofGraphStyleFilled
            .LineColor = FillColor
            .LineWidth = LineWidth
            .FillColor = FillColor
            .InitVerts 1, VertNum, Vert, True
            .PrintPointsString
        End With
    End If
        
    AddGroupItem        ' left bracket
    With GroupItems(GroupItemNum)
        .ShapeType = aofShapeTypePolygon
        .GraphStyle = aofGraphStyleOutline
        .LineColor = LineColor
        .LineStyle = LineStyle
        .LineWidth = LineWidth
        .InitVerts 1, 15, Vert
    End With
    
    AddGroupItem        ' right bracket
    With GroupItems(GroupItemNum)
        .ShapeType = aofShapeTypePolygon
        .GraphStyle = aofGraphStyleOutline
        .LineColor = LineColor
        .LineStyle = LineStyle
        .LineWidth = LineWidth
        .InitVerts 16, 15, Vert
    End With
    
    ShapeType = aofShapeTypeUserDefinedGroup
    
End Sub

Private Sub SetVerticesDoubleBracket(shp As Shape, Optional bRotateNodes As Boolean = True)
    Dim i           As Long
    Dim cirRatio    As Single
    Dim ratio        As Single
    Dim shft        As Long
    Dim shftx       As Long
    Dim shfty   As Long
    
    With shp
        InitVertices 16
        
        On Error Resume Next
        cirRatio = 0.28
        ratio = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio = 0.1666667
        End If
        
        If .Width < .Height Then
            shft = .Width * ratio
        Else
            shft = .Height * ratio
        End If
        shftx = shft * cirRatio * 2
        shfty = shftx
        
        'left bracket
        Vert(1).X = .Left + shft
        Vert(1).Y = .Top
        Vert(1).SegType = msoSegmentCurve
        Vert(2).X = Vert(1).X - shftx
        Vert(2).Y = Vert(1).Y
        Vert(4).X = .Left
        Vert(4).Y = .Top + shft
        Vert(3).X = Vert(4).X
        Vert(3).Y = Vert(4).Y - shfty
        
        Vert(5).X = .Left
        Vert(5).Y = .Top + .Height - shft
        Vert(5).SegType = msoSegmentCurve
        Vert(6).X = Vert(5).X
        Vert(6).Y = Vert(5).Y + shfty
        Vert(8).X = Vert(1).X
        Vert(8).Y = .Top + .Height
        Vert(7).X = Vert(2).X
        Vert(7).Y = Vert(8).Y
        
        ' right bracket
        For i = 1 To 8
            Vert(17 - i).Y = Vert(i).Y
        Next
        
        Vert(9).X = .Left + .Width - shft
        Vert(9).SegType = msoSegmentCurve
        Vert(10).X = Vert(9).X + shftx
        Vert(12).X = .Left + .Width
        Vert(11).X = Vert(12).X
        
        Vert(13).X = .Left + .Width
        Vert(13).SegType = msoSegmentCurve
        Vert(14).X = Vert(13).X
        Vert(16).X = Vert(9).X
        Vert(15).X = Vert(10).X
        
    End With

End Sub

Private Sub ParseDoubleBracket(shp As Shape, Optional bRotateNodes As Boolean = True)
    Dim i           As Long
    
    SetGraphmode shp
    NewRotateNodes shp
    
    If GraphStyle = aofGraphStyleFilled Or GraphStyle = aofGraphStyleFilledOutline Then
        AddGroupItem
        With GroupItems(GroupItemNum)
            .ShapeType = aofShapeTypePolygon
            .GraphStyle = aofGraphStyleFilled
            .LineColor = FillColor
            .LineWidth = LineWidth
            .FillColor = FillColor
            .InitVerts 1, VertNum, Vert, True
            .PrintPointsString
        End With
    End If
        
    AddGroupItem        ' left bracket
    With GroupItems(GroupItemNum)
        .ShapeType = aofShapeTypePolygon
        .GraphStyle = aofGraphStyleOutline
        .LineColor = LineColor
        .LineStyle = LineStyle
        .LineWidth = LineWidth
        .InitVerts 1, 8, Vert
    End With
    
    AddGroupItem        ' right bracket
    With GroupItems(GroupItemNum)
        .ShapeType = aofShapeTypePolygon
        .GraphStyle = aofGraphStyleOutline
        .LineColor = LineColor
        .LineStyle = LineStyle
        .LineWidth = LineWidth
        .InitVerts 9, 8, Vert
    End With
    
    ShapeType = aofShapeTypeUserDefinedGroup

End Sub

Private Sub SetVerticesCross(shp As Shape)
    Dim ratio As Single
    Dim shftx As Long
    Dim shfty As Long
    
    InitVertices 13
    With shp
        On Error Resume Next
        ratio = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio = 0.25
        End If
        
        shftx = .Width * ratio
        shfty = .Height * ratio
        
        Vert(1).X = .Left
        Vert(1).Y = .Top + shfty
        Vert(2).X = .Left + shftx
        Vert(2).Y = Vert(1).Y
        Vert(3).X = Vert(2).X
        Vert(3).Y = .Top
        Vert(4).X = .Left + .Width - shftx
        Vert(4).Y = .Top
        Vert(5).X = Vert(4).X
        Vert(5).Y = Vert(2).Y
        
        Vert(6).X = .Left + .Width
        Vert(6).Y = Vert(5).Y
        Vert(7).X = Vert(6).X
        Vert(7).Y = .Top + .Height - shfty
        Vert(8).X = Vert(5).X
        Vert(8).Y = Vert(7).Y
        Vert(9).X = Vert(8).X
        Vert(9).Y = .Top + .Height
        Vert(10).X = Vert(3).X
        Vert(10).Y = Vert(9).Y
        Vert(11).X = Vert(10).X
        Vert(11).Y = Vert(8).Y
        Vert(12).X = Vert(1).X
        Vert(12).Y = Vert(11).Y
        
        Vert(13) = Vert(1)
    End With
End Sub

Private Sub SetVerticesBevel(shp As Shape)
    Dim i           As Long
    Dim ratio       As Single
    Dim shft        As Long
    
    With shp
        InitVertices 8
        
        On Error Resume Next
        ratio = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio = 0.125
        End If
        
        If .Width < .Height Then
            shft = .Width * ratio
        Else
            shft = .Height * ratio
        End If
        
        Vert(1).X = .Left
        Vert(1).Y = .Top
        Vert(2).X = .Left + .Width
        Vert(2).Y = .Top
        Vert(3).X = .Left + shft
        Vert(3).Y = .Top + shft
        Vert(4).X = .Left + .Width - shft
        Vert(4).Y = .Top + shft
        
        Vert(5).X = Vert(3).X
        Vert(5).Y = .Top + .Height - shft
        Vert(6).X = Vert(4).X
        Vert(6).Y = Vert(5).Y
        Vert(7).X = .Left
        Vert(7).Y = .Top + .Height
        Vert(8).X = .Left + .Width
        Vert(8).Y = .Top + .Height
    End With
End Sub

Private Sub ParseBevel(shp As Shape)
    Dim i           As Long
    Dim ratio       As Single
    Dim shft        As Long
    
    NewRotateNodes shp
    
    HasGroupItem = True
    GroupItemNum = 5
    ReDim GroupItems(1 To GroupItemNum) As aofShape
    
    With shp
        If .Fill.Visible = msoTrue Then
            GraphStyle = aofGraphStyleFilled
            SetFillArt shp
        End If
        If .Line.Visible = msoTrue Then
            GraphStyle = GraphStyle + aofGraphStyleOutline
            SetLineArt shp
        End If
    End With
    
    For i = 1 To GroupItemNum
        Set GroupItems(i) = New aofShape
        With GroupItems(i)
            .ShapeType = aofShapeTypePolygon
            .ReDimVert 5
            .GraphStyle = GraphStyle
            .LineColor = LineColor
            .LineStyle = LineStyle
            .LineWidth = LineWidth
            .FillColor = FillColor
        End With
    Next
    
    With shp
        'NodesRotate .Rotation
        
        Dim bSolidFilled As Boolean
        Dim colorLeft As String
        Dim colorUpper As String
        Dim colorBottom  As String
        Dim colorRight  As String
        
        If .Fill.Visible = msoTrue Then
            bSolidFilled = True
            SetRelatedColors .Fill.ForeColor.RGB, colorLeft, colorUpper, colorBottom, colorRight
        Else
            bSolidFilled = False
        End If
        
        With GroupItems(1)      ' north
            .Set5Vert Vert, 1, 2, 4, 3
            .PrintPointsString
            .FillColor = colorUpper
        End With
        
        With GroupItems(2)      ' east
            .Set5Vert Vert, 1, 3, 5, 7
            .PrintPointsString
            .FillColor = colorLeft
        End With
        
        With GroupItems(3)      ' south
            .Set5Vert Vert, 5, 6, 8, 7
            .PrintPointsString
            .FillColor = colorBottom
        End With
        
        With GroupItems(4)      ' west
            .Set5Vert Vert, 2, 4, 6, 8
            .PrintPointsString
            .FillColor = colorRight
        End With
        
        With GroupItems(5)      ' middle
            .Set5Vert Vert, 3, 4, 6, 5
            .PrintPointsString
        End With
    End With
    
    ShapeType = aofShapeTypeUserDefinedGroup
End Sub

Sub Set5Vert(v() As aofNode, n1 As Long, n2 As Long, n3 As Long, n4 As Long)
    ReDimVert 5
    Vert(1) = v(n1)
    Vert(2) = v(n2)
    Vert(3) = v(n3)
    Vert(4) = v(n4)
    Vert(5) = v(n1)
End Sub

Sub ReDimVert(vn As Long)
    If vn < 1 Then
        Exit Sub
    End If
    HasVertices = True
    VertNum = vn
    ReDim Vert(1 To VertNum) As aofNode
End Sub

Private Sub SetVerticesFlowchartDisplay(shp As Shape)
    Dim cirRatio    As Single
    Dim ratio   As Single
    Dim shftx   As Long
    Dim shfty   As Long
    
    InitVertices 11
    With shp
        cirRatio = 0.28
        ratio = 0.1684
        shftx = .Width * ratio * cirRatio * 2
        shfty = .Height * cirRatio
        
        Vert(1).X = .Left + .Width * (1 - ratio)
        Vert(1).Y = .Top
        Vert(1).SegType = msoSegmentCurve
        Vert(2).X = Vert(1).X + shftx
        Vert(2).Y = Vert(1).Y
        Vert(2).SegType = msoSegmentCurve
        Vert(4).X = .Left + .Width
        Vert(4).Y = .Top + .Height / 2
        Vert(4).SegType = msoSegmentCurve
        Vert(3).X = Vert(4).X
        Vert(3).Y = Vert(4).Y - shfty
        Vert(3).SegType = msoSegmentCurve
        Vert(5).X = Vert(4).X
        Vert(5).Y = Vert(4).Y + shfty
        Vert(5).SegType = msoSegmentCurve
        Vert(7).X = Vert(1).X
        Vert(7).Y = .Top + .Height
        Vert(6).X = Vert(2).X
        Vert(6).Y = Vert(7).Y
        Vert(6).SegType = msoSegmentCurve
        
        Vert(8).X = .Left + .Width * ratio
        Vert(8).Y = Vert(7).Y
        Vert(9).X = .Left
        Vert(9).Y = .Top + .Height / 2
        Vert(10).X = Vert(8).X
        Vert(10).Y = .Top
        
        Vert(11) = Vert(1)
        
    End With
End Sub

Private Sub SetVerticesFlowchartDirectAccessStorage(shp As Shape)
    Dim cirRatio    As Single
    Dim ratio   As Single
    Dim shftx   As Long
    Dim shfty   As Long
    
    InitVertices 27
    With shp
        cirRatio = 0.28
        ratio = 0.333
        shftx = .Width * ratio * cirRatio
        shfty = .Height * cirRatio
        
        Vert(1).X = .Left + .Width * (1 - ratio / 2)
        Vert(1).Y = .Top
        Vert(1).SegType = msoSegmentCurve
        Vert(2).X = Vert(1).X + shftx
        Vert(2).Y = Vert(1).Y
        Vert(2).SegType = msoSegmentCurve
        Vert(4).X = .Left + .Width
        Vert(4).Y = .Top + .Height / 2
        Vert(4).SegType = msoSegmentCurve
        Vert(3).X = Vert(4).X
        Vert(3).Y = Vert(4).Y - shfty
        Vert(3).SegType = msoSegmentCurve
        Vert(5).X = Vert(4).X
        Vert(5).Y = Vert(4).Y + shfty
        Vert(5).SegType = msoSegmentCurve
        Vert(7).X = Vert(1).X
        Vert(7).Y = .Top + .Height
        Vert(7).SegType = msoSegmentCurve
        Vert(6).X = Vert(2).X
        Vert(6).Y = Vert(7).Y
        Vert(6).SegType = msoSegmentCurve
        
        Vert(8).X = Vert(7).X - shftx
        Vert(8).Y = Vert(7).Y
        Vert(8).SegType = msoSegmentCurve
        Vert(10).X = .Left + .Width * (1 - ratio)
        Vert(10).Y = Vert(4).Y
        Vert(10).SegType = msoSegmentCurve
        Vert(9).X = Vert(10).X
        Vert(9).Y = Vert(5).Y
        Vert(9).SegType = msoSegmentCurve
        Vert(11).X = Vert(10).X
        Vert(11).Y = Vert(3).Y
        Vert(11).SegType = msoSegmentCurve
        Vert(12).X = Vert(1).X - shftx
        Vert(12).Y = Vert(1).Y
        Vert(12).SegType = msoSegmentCurve
        Vert(13).X = Vert(1).X
        Vert(13).Y = Vert(1).Y
        
        Vert(14).X = .Left + .Width * ratio / 2
        Vert(14).Y = .Top
        Vert(14).SegType = msoSegmentCurve
        Vert(15).X = Vert(14).X - shftx
        Vert(15).Y = Vert(14).Y
        Vert(15).SegType = msoSegmentCurve
        Vert(17).X = .Left
        Vert(17).Y = Vert(10).Y
        Vert(17).SegType = msoSegmentCurve
        Vert(16).X = Vert(17).X
        Vert(16).Y = Vert(11).Y
        Vert(16).SegType = msoSegmentCurve
        Vert(18).X = Vert(17).X
        Vert(18).Y = Vert(9).Y
        Vert(18).SegType = msoSegmentCurve
        Vert(20).X = Vert(14).X
        Vert(20).Y = Vert(7).Y
        Vert(19).X = Vert(15).X
        Vert(19).Y = Vert(20).Y
        Vert(19).SegType = msoSegmentCurve
        
        Vert(21) = Vert(7)
        Vert(22) = Vert(8)
        Vert(23) = Vert(9)
        Vert(24) = Vert(10)
        Vert(25) = Vert(11)
        Vert(26) = Vert(12)
        Vert(27) = Vert(13)
    End With
End Sub

Private Sub SetVerticesFlowchartSequentialAccessStorage(shp As Shape)
    Dim shftx   As Long
    Dim shfty   As Long
    Dim cirRatio    As Single
    Dim ratio   As Single
    Dim Tailw   As Single
    Dim tailL   As Single
    
    InitVertices 16
    With shp
        cirRatio = 0.28
        shftx = .Width * cirRatio
        shfty = .Height * cirRatio
        Tailw = 0.16
        tailL = 0.5 - Sqr(0.25 - 0.34 * 0.34)
        
        Vert(1).X = .Left
        Vert(1).Y = .Top + .Height / 2
        Vert(1).SegType = msoSegmentCurve
        Vert(2).X = Vert(1).X
        Vert(2).Y = Vert(1).Y - shfty
        Vert(2).SegType = msoSegmentCurve
        Vert(4).X = .Left + .Width / 2
        Vert(4).Y = .Top
        Vert(4).SegType = msoSegmentCurve
        Vert(3).X = Vert(4).X - shftx
        Vert(3).Y = Vert(4).Y
        Vert(3).SegType = msoSegmentCurve
        Vert(5).X = Vert(4).X + shftx
        Vert(5).Y = Vert(4).Y
        Vert(5).SegType = msoSegmentCurve
        Vert(7).X = .Left + .Width
        Vert(7).Y = Vert(1).Y
        Vert(7).SegType = msoSegmentCurve
        Vert(6).X = Vert(7).X
        Vert(6).Y = Vert(2).Y
        Vert(6).SegType = msoSegmentCurve
        
        Vert(8).X = Vert(7).X
        Vert(8).Y = Vert(7).Y + shfty * 0.8
        Vert(8).SegType = msoSegmentCurve
        Vert(11).X = .Left + .Width
        Vert(11).Y = .Top + .Height * (1 - Tailw)
        Vert(10).X = .Left + .Width * (1 - tailL)
        Vert(10).Y = Vert(11).Y
        '!!!
        ratio = 0.35
        Vert(9).X = Vert(10).X + .Width * tailL * ratio
        Vert(9).Y = Vert(10).Y - .Height * Tailw * ratio
        Vert(9).SegType = msoSegmentCurve
        
        Vert(12).X = Vert(11).X
        Vert(12).Y = .Top + .Height
        
        Vert(13).X = Vert(4).X
        Vert(13).Y = .Top + .Height
        Vert(13).SegType = msoSegmentCurve
        Vert(14).X = Vert(3).X
        Vert(14).Y = Vert(13).Y
        Vert(14).SegType = msoSegmentCurve
        
        Vert(16) = Vert(1)
        
        Vert(15).X = Vert(16).X
        Vert(15).Y = Vert(16).Y + shfty
        Vert(15).SegType = msoSegmentCurve
    End With
End Sub

Private Sub SetVerticesFlowchartDelay(shp As Shape)
    Dim shftx   As Long
    Dim shfty   As Long
    
    InitVertices 10
    With shp
        shftx = .Width / 4
        shfty = .Height / 4
        
        Vert(1).X = .Left
        Vert(1).Y = .Top
        
        Vert(2).X = .Left + .Width / 2
        Vert(2).Y = Vert(1).Y
        Vert(2).SegType = msoSegmentCurve
        Vert(3).X = Vert(2).X + shftx
        Vert(3).Y = .Top
        Vert(3).SegType = msoSegmentCurve
        Vert(5).X = .Left + .Width
        Vert(5).Y = .Top + .Height / 2
        Vert(5).SegType = msoSegmentCurve
        Vert(4).X = Vert(5).X
        Vert(4).Y = Vert(5).Y - shfty
        Vert(4).SegType = msoSegmentCurve
        Vert(6).X = Vert(5).X
        Vert(6).Y = Vert(5).Y + shfty
        Vert(6).SegType = msoSegmentCurve
        Vert(8).X = Vert(2).X
        Vert(8).Y = .Top + .Height
        Vert(7).X = Vert(3).X
        Vert(7).Y = Vert(8).Y
        Vert(7).SegType = msoSegmentCurve
        
        Vert(9).X = Vert(1).X
        Vert(9).Y = .Top + .Height
        
        Vert(10) = Vert(1)
    End With
End Sub

Private Sub SetVerticesCan(shp As Shape)
    Dim ratio   As Single
    Dim shftx   As Long
    Dim shfty   As Long
    Dim i       As Long
    
    InitVertices 27
    With shp
        On Error Resume Next
        ratio = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio = 0.25
        End If
        
        shftx = .Width / 4
        shfty = .Height * ratio / 4
        
        Vert(1).X = .Left
        Vert(1).Y = .Top + .Height * ratio / 2
        Vert(1).SegType = msoSegmentCurve
        Vert(2).X = .Left
        Vert(2).Y = Vert(1).Y - shfty
        Vert(2).SegType = msoSegmentCurve
        Vert(4).X = .Left + .Width / 2
        Vert(4).Y = .Top
        Vert(4).SegType = msoSegmentCurve
        Vert(3).X = Vert(4).X - shftx
        Vert(3).Y = Vert(4).Y
        Vert(3).SegType = msoSegmentCurve
        Vert(5).X = Vert(4).X + shftx
        Vert(5).Y = Vert(4).Y
        Vert(5).SegType = msoSegmentCurve
        Vert(7).X = .Left + .Width
        Vert(7).Y = Vert(1).Y
        Vert(7).SegType = msoSegmentCurve
        Vert(6).X = Vert(7).X
        Vert(6).Y = Vert(7).Y - shfty
        Vert(6).SegType = msoSegmentCurve
        
        Vert(8).X = Vert(7).X
        Vert(8).Y = Vert(7).Y + shfty
        Vert(8).SegType = msoSegmentCurve
        Vert(10).X = Vert(4).X
        Vert(10).Y = .Top + .Height * ratio
        Vert(10).SegType = msoSegmentCurve
        Vert(9).X = Vert(5).X
        Vert(9).Y = Vert(10).Y
        Vert(9).SegType = msoSegmentCurve
        Vert(11).X = Vert(3).X
        Vert(11).Y = Vert(10).Y
        Vert(11).SegType = msoSegmentCurve
        Vert(12).X = Vert(1).X
        Vert(12).Y = Vert(8).Y
        Vert(12).SegType = msoSegmentCurve
        Vert(13).X = Vert(1).X
        Vert(13).Y = Vert(1).Y
        
        Vert(14).X = Vert(1).X
        Vert(14).Y = .Top + .Height * (1 - ratio / 2)
        Vert(14).SegType = msoSegmentCurve
        Vert(15).X = Vert(14).X
        Vert(15).Y = Vert(14).Y + shfty
        Vert(15).SegType = msoSegmentCurve
        Vert(17).X = Vert(10).X
        Vert(17).Y = .Top + .Height
        Vert(17).SegType = msoSegmentCurve
        Vert(16).X = Vert(11).X
        Vert(16).Y = Vert(17).Y
        Vert(16).SegType = msoSegmentCurve
        Vert(18).X = Vert(9).X
        Vert(18).Y = Vert(17).Y
        Vert(18).SegType = msoSegmentCurve
        Vert(20).X = Vert(7).X
        Vert(20).Y = Vert(14).Y
        Vert(19).X = Vert(20).X
        Vert(19).Y = Vert(15).Y
        Vert(19).SegType = msoSegmentCurve
        
        Vert(21) = Vert(7)
        Vert(22) = Vert(8)
        Vert(23) = Vert(9)
        Vert(24) = Vert(10)
        Vert(25) = Vert(11)
        Vert(26) = Vert(12)
        Vert(27) = Vert(13)
        
    End With
End Sub

Private Sub ParseCan(shp As Shape)
    Dim i       As Long
        
    NewRotateNodes shp
    
    HasGroupItem = True
    GroupItemNum = 2
    ReDim GroupItems(1 To GroupItemNum) As aofShape
    
    If shp.Fill.Visible = msoTrue Then
        GraphStyle = aofGraphStyleFilled
        SetFillArt shp
    End If
    If shp.Line.Visible = msoTrue Then
        GraphStyle = GraphStyle + aofGraphStyleOutline
        SetLineArt shp
    End If
        
    For i = 1 To GroupItemNum
        Set GroupItems(i) = New aofShape
        With GroupItems(i)
            .ShapeType = aofShapeTypePolygon
            .ReDimVert 5
            .GraphStyle = GraphStyle
            .LineColor = LineColor
            .LineStyle = LineStyle
            .LineWidth = LineWidth
            .FillColor = FillColor
        End With
    Next
    
    Dim bSolidFilled As Boolean
    Dim colorUpper As String
    Dim colorDumm  As String
    
    If shp.Fill.Visible = msoTrue Then
        bSolidFilled = True
        SetRelatedColors shp.Fill.ForeColor.RGB, colorDumm, colorUpper, colorDumm, colorDumm
    Else
        bSolidFilled = False
    End If
    
    With GroupItems(1)      ' upper
        .SetVerts Vert, 1, 13
        .PrintPointsString
        If bSolidFilled And shp.AutoShapeType <> msoShapeFlowchartMagneticDisk Then
            .FillColor = colorUpper
        End If
    End With
    
    With GroupItems(2)      ' front
        .SetVerts Vert, 13, 15
        .PrintPointsString
    End With
    
    'SetAsPolygon shp, True
    ShapeType = aofShapeTypeUserDefinedGroup
End Sub

Private Sub SetVerticesFlowchartOr(shp As Shape)
    SetVerticesOval shp
End Sub
Private Sub ParseFlowchartOr(shp As Shape)
    Dim i           As Long
    Dim ratio       As Single
    
    SetGraphstyle shp
    
    ' circle
    If shp.Rotation = 0 Then
        AddGroupItem
        GroupItems(GroupItemNum).SetAsOval shp
    Else
        NewRotateNodes shp
        AddGroupItem
        With GroupItems(GroupItemNum)
            .ShapeType = aofShapeTypePolygon
            .GraphStyle = GraphStyle
            .FillColor = FillColor
            .LineColor = LineColor
            .InitVerts 1, VertNum, Vert, True
            .PrintPointsString
        End With
    End If
        
    If GraphStyle = aofGraphStyleOutline Or GraphStyle = aofGraphStyleFilledOutline Then
        Dim vtmp(1 To 4) As aofNode
        vtmp(1).X = shp.Left
        vtmp(1).Y = shp.Top + shp.Height / 2
        vtmp(2).X = shp.Left + shp.Width
        vtmp(2).Y = vtmp(1).Y
        vtmp(3).X = shp.Left + shp.Width / 2
        vtmp(3).Y = shp.Top
        vtmp(4).X = vtmp(3).X
        vtmp(4).Y = shp.Top + shp.Height
        AddGroupItem
        With GroupItems(GroupItemNum)
            .SetVerts vtmp, 1, 2
            .NewRotateNodes shp
            .BuildLineWithVert False, False     ' without arrow
'            .ShapeType = aofShapeTypeLine
'            .x = shp.Left + shp.Width * ratio
'            .y = shp.Top + shp.Height * ratio
'            .Width = shp.Width * (1 - ratio * 2)
'            .Height = shp.Height * (1 - ratio * 2)
            .SetLineArt shp, True
        End With
        
        AddGroupItem
        With GroupItems(GroupItemNum)
            .SetVerts vtmp, 3, 2
            .NewRotateNodes shp
            .BuildLineWithVert False, False     ' without arrow
'            .ShapeType = aofShapeTypeLine
'            .x = shp.Left + shp.Width * (1 - ratio)
'            .y = shp.Top + shp.Height * ratio
'            .Width = -shp.Width * (1 - ratio * 2)
'            .Height = shp.Height * (1 - ratio * 2)
            .SetLineArt shp, True
        End With
        Erase vtmp
    End If
    
    ShapeType = aofShapeTypeUserDefinedGroup
End Sub

Private Sub SetVerticesFlowchartSummingJunction(shp As Shape)
    SetVerticesOval shp
End Sub

Private Sub ParseFlowchartSummingJunction(shp As Shape)
    
    NewRotateNodes shp
    SetGraphstyle shp
    
    AddGroupItem
    With GroupItems(GroupItemNum)   ' circle
        .ShapeType = aofShapeTypePolygon
        .SetGraphstyle shp
        .InitVerts 1, VertNum, Vert, True
        .PrintPointsString
    End With
        
    ' CANNOT use Line object. otherwise the shadow may be incorrect!!!
    If GraphStyle <> aofGraphStyleNone Or GraphStyle <> aofGraphStyleFilled Then
        Dim i           As Long
        Dim ratio       As Single
        Dim vtmp(1 To 4) As aofNode
        
        ratio = 0.5 - Sqr(2) / 4
        vtmp(1).X = shp.Left + shp.Width * ratio
        vtmp(1).Y = shp.Top + shp.Height * ratio
        vtmp(2).X = vtmp(1).X + shp.Width * (1 - ratio * 2)
        vtmp(2).Y = vtmp(1).Y + shp.Height * (1 - ratio * 2)
        vtmp(3).X = vtmp(1).X
        vtmp(3).Y = vtmp(2).Y
        vtmp(4).X = vtmp(2).X
        vtmp(4).Y = vtmp(1).Y
        AddGroupItem
        With GroupItems(GroupItemNum)
            .SetVerts vtmp, 1, 2
            .NewRotateNodes shp
            .GraphStyle = GraphStyle
            .SetLineArt shp, True
            .PrintPointsString
            .ShapeType = aofShapeTypePolygon
        End With
        AddGroupItem
        With GroupItems(GroupItemNum)
            .SetVerts vtmp, 3, 2
            .NewRotateNodes shp
            .GraphStyle = GraphStyle
            .SetLineArt shp, True
            .PrintPointsString
            .ShapeType = aofShapeTypePolygon
        End With
        Erase vtmp
    End If
    
    ShapeType = aofShapeTypeUserDefinedGroup
End Sub

Private Sub SetVerticesFlowchartTerminator(shp As Shape)
    Dim shftx   As Long
    Dim shfty   As Long
    
    InitVertices 15
    With shp
        shftx = .Width * 0.08
        shfty = .Height * 0.25
        
        Vert(1).X = .Left + .Width * 0.15
        Vert(1).Y = .Top
        
        Vert(2).X = .Left + .Width * 0.85
        Vert(2).Y = .Top
        Vert(2).SegType = msoSegmentCurve
        Vert(3).X = .Left + .Width - shftx
        Vert(3).Y = .Top
        Vert(3).SegType = msoSegmentCurve
        Vert(4).X = .Left + .Width
        Vert(4).Y = .Top + shfty
        Vert(4).SegType = msoSegmentCurve
        Vert(5).X = .Left + .Width
        Vert(5).Y = .Top + .Height / 2
        Vert(5).SegType = msoSegmentCurve
        Vert(6).X = Vert(4).X
        Vert(6).Y = .Top + .Height - shfty
        Vert(6).SegType = msoSegmentCurve
        Vert(7).X = Vert(3).X
        Vert(7).Y = .Top + .Height
        Vert(7).SegType = msoSegmentCurve
        Vert(8).X = Vert(2).X
        Vert(8).Y = .Top + .Height
        
        
        Vert(9).X = Vert(1).X
        Vert(9).Y = Vert(8).Y
        Vert(9).SegType = msoSegmentCurve
        Vert(10).X = .Left + shftx
        Vert(10).Y = Vert(7).Y
        Vert(10).SegType = msoSegmentCurve
        Vert(11).X = .Left
        Vert(11).Y = Vert(6).Y
        Vert(11).SegType = msoSegmentCurve
        Vert(12).X = .Left
        Vert(12).Y = Vert(5).Y
        Vert(12).SegType = msoSegmentCurve
        Vert(13).X = Vert(11).X
        Vert(13).Y = Vert(4).Y
        Vert(13).SegType = msoSegmentCurve
        Vert(14).X = Vert(10).X
        Vert(14).Y = Vert(3).Y
        Vert(14).SegType = msoSegmentCurve
        
        Vert(15) = Vert(1)
        
    End With
End Sub

Private Sub SetVerticesFlowchartAlternateProcess(shp As Shape)
    Dim ratio   As Single
    Dim cirRatio    As Single
    Dim shftx   As Long
    Dim shfty   As Long
    
    InitVertices 17
    With shp
        cirRatio = 0.28
        On Error Resume Next
        ratio = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio = 0.12
        End If
        If .Width > .Height Then
            shftx = .Height * ratio * (1 - cirRatio * 2)
        Else
            shftx = .Width * ratio * (1 - cirRatio * 2)
        End If
        shfty = shftx
        
        Vert(1).X = .Left
        Vert(1).Y = .Top + shfty + shfty
        Vert(1).SegType = msoSegmentCurve
        Vert(2).X = .Left
        Vert(2).Y = .Top + shfty
        Vert(2).SegType = msoSegmentCurve
        Vert(3).X = .Left + shftx
        Vert(3).Y = .Top
        Vert(3).SegType = msoSegmentCurve
        Vert(4).X = .Left + shftx + shftx
        Vert(4).Y = .Top
        
        Vert(5).X = .Left + .Width - shftx - shftx
        Vert(5).Y = .Top
        Vert(5).SegType = msoSegmentCurve
        Vert(6).X = .Left + .Width - shftx
        Vert(6).Y = .Top
        Vert(6).SegType = msoSegmentCurve
        Vert(7).X = .Left + .Width
        Vert(7).Y = .Top + shfty
        Vert(7).SegType = msoSegmentCurve
        Vert(8).X = .Left + .Width
        Vert(8).Y = .Top + shfty + shfty
        
        Vert(9).X = Vert(8).X
        Vert(9).Y = .Top + .Height - shfty - shfty
        Vert(9).SegType = msoSegmentCurve
        Vert(10).X = Vert(9).X
        Vert(10).Y = .Top + .Height - shfty
        Vert(10).SegType = msoSegmentCurve
        Vert(11).X = Vert(6).X
        Vert(11).Y = .Top + .Height
        Vert(11).SegType = msoSegmentCurve
        Vert(12).X = Vert(5).X
        Vert(12).Y = .Top + .Height
        
        Vert(13).X = Vert(4).X
        Vert(13).Y = Vert(12).Y
        Vert(13).SegType = msoSegmentCurve
        Vert(14).X = Vert(3).X
        Vert(14).Y = Vert(13).Y
        Vert(14).SegType = msoSegmentCurve
        Vert(15).X = .Left
        Vert(15).Y = .Top + .Height - shfty
        Vert(15).SegType = msoSegmentCurve
        Vert(16).X = .Left
        Vert(16).Y = Vert(9).Y
        
        Vert(17).X = Vert(1).X
        Vert(17).Y = Vert(1).Y
    End With
End Sub
Private Sub SetVerticesFlowchartMultidocument(shp As Shape)
    InitVertices 22
    With shp
        
        Vert(1).X = .Left
        Vert(1).Y = .Top + .Height * 0.18
        Vert(2).X = .Left + .Width * 0.86
        Vert(2).Y = Vert(1).Y
        Vert(3).X = .Left + .Width * 0.07
        Vert(3).Y = Vert(1).Y
        Vert(4).X = Vert(3).X
        Vert(4).Y = .Top + .Height * 0.09
        Vert(5).X = .Left + .Width * 0.93
        Vert(5).Y = Vert(4).Y
        Vert(6).X = .Left + .Width * 0.14
        Vert(6).Y = Vert(5).Y
        Vert(7).X = Vert(6).X
        Vert(7).Y = .Top
        
        Vert(8).X = .Left + .Width
        Vert(8).Y = .Top
        Vert(9).X = Vert(8).X
        Vert(9).Y = .Top + .Height * 0.67
        Vert(10).X = Vert(5).X
        Vert(10).Y = Vert(9).Y
        Vert(11) = Vert(5)
        Vert(12).X = Vert(10).X
        Vert(12).Y = .Top + .Height * 0.75
        Vert(13).X = Vert(2).X
        Vert(13).Y = Vert(12).Y
        Vert(14) = Vert(2)
        
        Vert(15).X = Vert(13).X
        Vert(15).Y = .Top + .Height * 0.83
        Vert(15).SegType = msoSegmentCurve
        Vert(16).X = .Left + .Width * 0.55
        Vert(16).Y = Vert(15).Y
        Vert(16).SegType = msoSegmentCurve
        Vert(17).X = .Left + .Width * 0.45
        Vert(17).Y = .Top + .Height
        Vert(17).SegType = msoSegmentCurve
        Vert(18).X = .Left + .Width * 0.3
        Vert(18).Y = .Top + .Height
        Vert(18).SegType = msoSegmentCurve
        Vert(19).X = .Left + .Width * 0.15
        Vert(19).Y = .Top + .Height
        Vert(19).SegType = msoSegmentCurve
        Vert(20).X = .Left
        Vert(20).Y = .Top + .Height * 0.95
        Vert(21) = Vert(20)
        Vert(20).SegType = msoSegmentCurve
        
        Vert(22) = Vert(1)
    End With
End Sub

Private Sub ParseFlowchartMultidocument(shp As Shape, Optional bRotateNodes As Boolean = True)
    
    VertNum = 22
    
    ReDim Vert(1 To VertNum) As aofNode
    
    With shp
        
        Vert(1).X = .Left
        Vert(1).Y = .Top + .Height * 0.18
        Vert(2).X = .Left + .Width * 0.86
        Vert(2).Y = Vert(1).Y
        Vert(3).X = .Left + .Width * 0.07
        Vert(3).Y = Vert(1).Y
        Vert(4).X = Vert(3).X
        Vert(4).Y = .Top + .Height * 0.09
        Vert(5).X = .Left + .Width * 0.93
        Vert(5).Y = Vert(4).Y
        Vert(6).X = .Left + .Width * 0.14
        Vert(6).Y = Vert(5).Y
        Vert(7).X = Vert(6).X
        Vert(7).Y = .Top
        
        Vert(8).X = .Left + .Width
        Vert(8).Y = .Top
        Vert(9).X = Vert(8).X
        Vert(9).Y = .Top + .Height * 0.67
        Vert(10).X = Vert(5).X
        Vert(10).Y = Vert(9).Y
        Vert(11) = Vert(5)
        Vert(12).X = Vert(10).X
        Vert(12).Y = .Top + .Height * 0.75
        Vert(13).X = Vert(2).X
        Vert(13).Y = Vert(12).Y
        Vert(14) = Vert(2)
        
        Vert(15).X = Vert(13).X
        Vert(15).Y = .Top + .Height * 0.83
        Vert(15).SegType = msoSegmentCurve
        Vert(16).X = .Left + .Width * 0.55
        Vert(16).Y = Vert(15).Y
        Vert(16).SegType = msoSegmentCurve
        Vert(17).X = .Left + .Width * 0.45
        Vert(17).Y = .Top + .Height
        Vert(17).SegType = msoSegmentCurve
        Vert(18).X = .Left + .Width * 0.3
        Vert(18).Y = .Top + .Height
        Vert(18).SegType = msoSegmentCurve
        Vert(19).X = .Left + .Width * 0.15
        Vert(19).Y = .Top + .Height
        Vert(19).SegType = msoSegmentCurve
        Vert(20).X = .Left
        Vert(20).Y = .Top + .Height * 0.95
        Vert(21) = Vert(20)
        Vert(20).SegType = msoSegmentCurve
        
        Vert(22) = Vert(1)
        
        FlipNodes Vert, VertNum, shp
        If bRotateNodes Then
            NodesRotate .Rotation
        End If
    End With
    SetAsPolygon shp, True

End Sub

Private Sub SetVerticesFlowchartDocument(shp As Shape)
    
    InitVertices 10
    With shp
        Vert(1).X = .Left
        Vert(1).Y = .Top
        Vert(2).X = .Left + .Width
        Vert(2).Y = .Top
        Vert(3).X = Vert(2).X
        Vert(3).Y = .Top + .Height * 0.8
        Vert(3).SegType = msoSegmentCurve
        Vert(4).X = Vert(3).X - .Width / 4
        Vert(4).Y = Vert(3).Y
        Vert(4).SegType = msoSegmentCurve
        Vert(5).X = .Left + .Width * 0.375
        Vert(5).Y = .Top + .Height
        Vert(5).SegType = msoSegmentCurve
        Vert(6).X = .Left + .Width / 4
        Vert(6).Y = Vert(5).Y
        Vert(6).SegType = msoSegmentCurve
        Vert(7).X = .Left + .Width / 8
        Vert(7).Y = Vert(6).Y
        Vert(7).SegType = msoSegmentCurve
        
        Vert(8).X = .Left
        Vert(8).Y = .Top + .Height * 0.93
        Vert(9) = Vert(8)
        Vert(8).SegType = msoSegmentCurve
        Vert(10) = Vert(1)
    End With
End Sub

Private Sub SetVerticesFlowchartInternalStorage(shp As Shape)
    
    InitVertices 11
    With shp
        Vert(1).X = .Left
        Vert(1).Y = .Top
        Vert(2).X = .Left + .Width
        Vert(2).Y = .Top
        Vert(3).X = Vert(2).X
        Vert(3).Y = .Top + .Height
        Vert(4).X = .Left + .Width * 0.2
        Vert(4).Y = Vert(3).Y
        Vert(5).X = Vert(4).X
        Vert(5).Y = .Top
        Vert(6) = Vert(4)
        Vert(7).X = .Left
        Vert(7).Y = Vert(4).Y
        
        Vert(8).X = .Left
        Vert(8).Y = .Top + .Height * 0.2
        Vert(9).X = Vert(2).X
        Vert(9).Y = Vert(8).Y
        Vert(10) = Vert(8)
        Vert(11) = Vert(1)
    End With
End Sub

Private Sub SetVerticesFlowchartPredefinedProcess(shp As Shape)
    
    Dim shftx As Single
    
    InitVertices 11
    With shp
        shftx = .Width * 0.12
        
        Vert(1).X = .Left
        Vert(1).Y = .Top
        Vert(2).X = .Left + .Width
        Vert(2).Y = .Top
        Vert(3).X = Vert(2).X
        Vert(3).Y = .Top + .Height
        Vert(4).X = Vert(3).X - shftx
        Vert(4).Y = Vert(3).Y
        Vert(5).X = Vert(4).X
        Vert(5).Y = .Top
        Vert(6) = Vert(4)
        Vert(7).X = .Left + shftx
        Vert(7).Y = Vert(4).Y
        
        Vert(8).X = Vert(7).X
        Vert(8).Y = .Top
        Vert(9) = Vert(7)
        Vert(10).X = .Left
        Vert(10).Y = Vert(9).Y
        Vert(11) = Vert(1)
    End With
End Sub

Private Sub SetVerticesFlowchartPunchedTape(shp As Shape)
    
    Dim shftx As Long
    Dim shfty   As Long
    Dim ctrlshft As Long
    
    InitVertices 15
    With shp
        shftx = .Width * 0.1
        shfty = .Height * 0.1
        ctrlshft = .Width * 0.06
        
        Vert(1).X = .Left
        Vert(1).Y = .Top + shfty
        Vert(1).SegType = msoSegmentCurve
        Vert(2).X = .Left + ctrlshft
        Vert(2).Y = .Top + shfty + shfty
        Vert(2).SegType = msoSegmentCurve
        Vert(3).X = .Left + .Width / 2 - ctrlshft
        Vert(3).Y = Vert(2).Y
        Vert(3).SegType = msoSegmentCurve
        Vert(4).X = .Left + .Width / 2
        Vert(4).Y = Vert(1).Y
        Vert(4).SegType = msoSegmentCurve
        
        Vert(5).X = Vert(4).X + ctrlshft
        Vert(5).Y = .Top
        Vert(5).SegType = msoSegmentCurve
        Vert(6).X = .Left + .Width - ctrlshft
        Vert(6).Y = .Top
        Vert(6).SegType = msoSegmentCurve
        Vert(7).X = .Left + .Width
        Vert(7).Y = Vert(4).Y
        
        Vert(8).X = Vert(7).X
        Vert(8).Y = .Top + .Height - shfty
        Vert(8).SegType = msoSegmentCurve
        Vert(9).X = Vert(6).X
        Vert(9).Y = Vert(8).Y - shfty
        Vert(9).SegType = msoSegmentCurve
        Vert(10).X = Vert(5).X
        Vert(10).Y = Vert(9).Y
        Vert(10).SegType = msoSegmentCurve
        Vert(11).X = Vert(4).X
        Vert(11).Y = Vert(8).Y
        Vert(11).SegType = msoSegmentCurve
        
        Vert(12).X = Vert(3).X
        Vert(12).Y = .Top + .Height
        Vert(12).SegType = msoSegmentCurve
        Vert(13).X = Vert(2).X
        Vert(13).Y = Vert(12).Y
        Vert(13).SegType = msoSegmentCurve
        Vert(14).X = .Left
        Vert(14).Y = Vert(11).Y
        
        Vert(15) = Vert(1)
    End With
End Sub

Private Sub SetVerticesFlowchartStoredData(shp As Shape)
    
    Dim shftx As Long
    Dim shfty   As Long
    
    InitVertices 15
    With shp
        shftx = .Width * 0.1
        shfty = .Height * 0.1
        
        Vert(1).X = .Left + shftx * 2
        Vert(1).Y = .Top
        Vert(2).X = .Left + .Width
        Vert(2).Y = .Top
        Vert(2).SegType = msoSegmentCurve
        Vert(3).X = .Left + .Width - shftx
        Vert(3).Y = .Top + shfty / 2    '.Top + shfty
        Vert(3).SegType = msoSegmentCurve
        Vert(4).X = .Left + .Width - shftx * 2
        Vert(4).Y = .Top + .Height / 2 - shfty * 3 '2
        Vert(4).SegType = msoSegmentCurve
        Vert(5).X = Vert(4).X
        Vert(5).Y = .Top + .Height / 2
        Vert(5).SegType = msoSegmentCurve
        Vert(6).X = Vert(5).X
        Vert(6).Y = Vert(5).Y * 2 - Vert(4).Y
        Vert(6).SegType = msoSegmentCurve
        Vert(7).X = Vert(3).X
        Vert(7).Y = Vert(5).Y * 2 - Vert(3).Y
        Vert(7).SegType = msoSegmentCurve
        Vert(8).X = Vert(2).X
        Vert(8).Y = .Top + .Height
        
        Vert(9).X = Vert(1).X
        Vert(9).Y = Vert(8).Y
        Vert(9).SegType = msoSegmentCurve
        Vert(10).X = Vert(7).X + shftx * 2 - .Width
        Vert(10).Y = Vert(7).Y
        Vert(10).SegType = msoSegmentCurve
        Vert(11).X = .Left
        Vert(11).Y = Vert(6).Y
        Vert(11).SegType = msoSegmentCurve
        Vert(12).X = Vert(11).X
        Vert(12).Y = Vert(5).Y
        Vert(12).SegType = msoSegmentCurve
        Vert(13).X = Vert(12).X
        Vert(13).Y = Vert(4).Y
        Vert(13).SegType = msoSegmentCurve
        Vert(14).X = Vert(10).X
        Vert(14).Y = Vert(3).Y
        Vert(14).SegType = msoSegmentCurve
        Vert(15) = Vert(1)
    End With
End Sub

Private Sub SetVerticesFlowchartMerge(shp As Shape)
    
    InitVertices 4
    With shp
        Vert(1).X = .Left
        Vert(1).Y = .Top
        Vert(2).X = .Left + .Width / 2
        Vert(2).Y = .Top + .Height
        Vert(3).X = .Left + .Width
        Vert(3).Y = Vert(1).Y
        Vert(4) = Vert(1)
    End With
End Sub

Private Sub SetVerticesFlowchartExtract(shp As Shape)
    
    InitVertices 4
    With shp
        Vert(1).X = .Left
        Vert(1).Y = .Top + .Height
        Vert(2).X = .Left + .Width / 2
        Vert(2).Y = .Top
        Vert(3).X = .Left + .Width
        Vert(3).Y = Vert(1).Y
        Vert(4) = Vert(1)
    End With
End Sub

Private Sub SetVerticesFlowchartSort(shp As Shape)
    
    InitVertices 6
    With shp
        Vert(1).X = .Left
        Vert(1).Y = .Top + .Height / 2
        Vert(2).X = .Left + .Width / 2
        Vert(2).Y = .Top
        Vert(3).X = .Left + .Width
        Vert(3).Y = Vert(1).Y
        Vert(4).X = Vert(2).X
        Vert(4).Y = .Top + .Height
        
        Vert(5) = Vert(1)
        Vert(6) = Vert(3)
    End With
End Sub

Private Sub SetVerticesFlowchartCollate(shp As Shape)
    InitVertices 5
    With shp
        Vert(1).X = .Left
        Vert(1).Y = .Top
        Vert(2).X = .Left + .Width
        Vert(2).Y = .Top
        Vert(3).X = .Left
        Vert(3).Y = .Top + .Height
        Vert(4).X = .Left + .Width
        Vert(4).Y = .Top + .Height
        
        Vert(5) = Vert(1)
    End With
End Sub

Private Sub SetVerticesFlowchartCard(shp As Shape)
    
    InitVertices 6
    With shp
        
        Vert(1).X = .Left
        Vert(1).Y = .Top + .Height * 0.2
        Vert(2).X = .Left + .Width * 0.2
        Vert(2).Y = .Top
        Vert(3).X = .Left + .Width
        Vert(3).Y = .Top
        Vert(4).X = .Left + .Width
        Vert(4).Y = .Top + .Height
        Vert(5).X = .Left
        Vert(5).Y = .Top + .Height
        
        Vert(6) = Vert(1)
    End With
End Sub
    
Private Sub SetVerticesFlowchartManualInput(shp As Shape)
    
    InitVertices 5
    With shp
        Vert(1).X = .Left
        Vert(1).Y = .Top + .Height * 0.2
        Vert(2).X = .Left + .Width
        Vert(2).Y = .Top
        Vert(3).X = Vert(2).X
        Vert(3).Y = .Top + .Height
        Vert(4).X = .Left
        Vert(4).Y = .Top + .Height
        
        Vert(5) = Vert(1)
    End With
End Sub

Private Sub SetVerticesFlowchartOffpageConnector(shp As Shape)
    
    InitVertices 6
    With shp
        Vert(1).X = .Left
        Vert(1).Y = .Top
        Vert(2).X = .Left + .Width
        Vert(2).Y = .Top
        Vert(3).X = Vert(2).X
        Vert(3).Y = .Top + .Height * 0.8
        Vert(4).X = .Left + .Width / 2
        Vert(4).Y = .Top + .Height
        Vert(5).X = .Left
        Vert(5).Y = Vert(3).Y
        
        Vert(6) = Vert(1)
    End With
End Sub

Private Sub SetVerticesQuadArrow(shp As Shape)
    Dim shft3 As Single
    Dim shft1 As Single
    Dim shft2 As Single
    
    InitVertices 25
    
    With shp
        On Error Resume Next
        shft1 = 0.3
        shft2 = 0.4
        shft3 = 0.2
    
        shft1 = .Adjustments(1)
        shft2 = .Adjustments(2)
        shft3 = .Adjustments(3)
    
        Vert(1).X = .Left
        Vert(1).Y = .Top + .Height / 2
        Vert(2).X = .Left + .Width * shft3
        Vert(2).Y = .Top + .Height * shft1
        Vert(3).X = Vert(2).X
        Vert(3).Y = .Top + .Height * shft2
        Vert(4).X = .Left + .Width * shft2
        Vert(4).Y = Vert(3).Y
        Vert(5).X = Vert(4).X
        Vert(5).Y = .Top + .Height * shft3
        Vert(6).X = .Left + .Width * shft1
        Vert(6).Y = Vert(5).Y
        
        Vert(7).X = .Left + .Width / 2
        Vert(7).Y = .Top
        Vert(8).X = .Left + .Width * (1 - shft1)
        Vert(8).Y = Vert(6).Y
        Vert(9).X = .Left + .Width * (1 - shft2)
        Vert(9).Y = Vert(5).Y
        Vert(10).X = Vert(9).X
        Vert(10).Y = Vert(4).Y
        Vert(11).X = .Left + .Width * (1 - shft3)
        Vert(11).Y = Vert(4).Y
        Vert(12).X = Vert(11).X
        Vert(12).Y = Vert(2).Y
        
        Vert(13).X = .Left + .Width
        Vert(13).Y = Vert(1).Y
        Vert(14).X = Vert(11).X
        Vert(14).Y = .Top + .Height * (1 - shft1)
        Vert(15).X = Vert(14).X
        Vert(15).Y = .Top + .Height * (1 - shft2)
        Vert(16).X = Vert(10).X
        Vert(16).Y = Vert(15).Y
        Vert(17).X = Vert(16).X
        Vert(17).Y = .Top + .Height * (1 - shft3)
        Vert(18).X = Vert(8).X
        Vert(18).Y = Vert(17).Y
        
        Vert(19).X = Vert(7).X
        Vert(19).Y = .Top + .Height
        Vert(20).X = Vert(6).X
        Vert(20).Y = Vert(17).Y
        Vert(21).X = Vert(4).X
        Vert(21).Y = Vert(17).Y
        Vert(22).X = Vert(4).X
        Vert(22).Y = Vert(16).Y
        Vert(23).X = Vert(3).X
        Vert(23).Y = Vert(22).Y
        Vert(24).X = Vert(3).X
        Vert(24).Y = Vert(14).Y
        
        Vert(25) = Vert(1)
    End With
End Sub

Private Sub SetVerticesQuadArrowCallout(shp As Shape)
    Dim shftx1 As Single
    Dim shftx2 As Single
    Dim shfty1 As Single
    Dim shfty2 As Single
    Dim shftx3 As Single
    Dim shfty3 As Single
    Dim shftx4 As Single
    Dim shfty4 As Single
    
    Dim arrh    As Single
    Dim lArrB   As Single
    Dim lNeck   As Single
    Dim sqAng   As Single
    
    InitVertices 33
    With shp
        On Error Resume Next
        lArrB = 0.375
        lArrB = .Adjustments(2) '
        lNeck = 0.4375
        lNeck = .Adjustments(4) '
        arrh = 0.125
        arrh = .Adjustments(3)  '
        sqAng = 0.25
        sqAng = .Adjustments(1)
        
        shftx1 = .Width * arrh
        shfty1 = .Height * arrh
        shftx2 = .Width * sqAng
        shfty2 = .Height * sqAng
        shftx3 = .Width * lArrB
        shfty3 = .Height * lArrB
        shftx4 = .Width * lNeck
        shfty4 = .Height * lNeck
        
        Vert(1).X = .Left
        Vert(1).Y = .Top + .Height / 2
        Vert(2).X = .Left + shftx1
        Vert(2).Y = .Top + shfty3
        Vert(3).X = Vert(2).X
        Vert(3).Y = .Top + shfty4
        Vert(4).X = .Left + shftx2
        Vert(4).Y = Vert(3).Y
        Vert(5).X = Vert(4).X
        Vert(5).Y = .Top + shfty2
        Vert(6).X = .Left + shftx4
        Vert(6).Y = Vert(5).Y
        Vert(7).X = Vert(6).X
        Vert(7).Y = .Top + shfty1
        Vert(8).X = .Left + shftx3
        Vert(8).Y = Vert(7).Y
        
        Vert(9).X = .Left + .Width / 2
        Vert(9).Y = .Top
        Vert(10).X = .Left + .Width - shftx3
        Vert(10).Y = Vert(8).Y
        Vert(11).X = .Left + .Width - shftx4
        Vert(11).Y = Vert(10).Y
        Vert(12).X = Vert(11).X
        Vert(12).Y = Vert(6).Y
        Vert(13).X = .Left + .Width - shftx2
        Vert(13).Y = Vert(12).Y
        Vert(14).X = Vert(13).X
        Vert(14).Y = Vert(4).Y
        Vert(15).X = .Left + .Width - shftx1
        Vert(15).Y = Vert(14).Y
        Vert(16).X = Vert(15).X
        Vert(16).Y = Vert(2).Y
        
        Vert(17).X = .Left + .Width
        Vert(17).Y = Vert(1).Y
        Vert(18).X = Vert(16).X
        Vert(18).Y = .Top + .Height - shfty3
        Vert(19).X = Vert(18).X
        Vert(19).Y = .Top + .Height - shfty4
        Vert(20).X = Vert(14).X
        Vert(20).Y = Vert(19).Y
        Vert(21).X = Vert(20).X
        Vert(21).Y = .Top + .Height - shfty2
        Vert(22).X = Vert(12).X
        Vert(22).Y = Vert(21).Y
        Vert(23).X = Vert(22).X
        Vert(23).Y = .Top + .Height - shfty1
        Vert(24).X = Vert(10).X
        Vert(24).Y = Vert(23).Y
        
        Vert(25).X = Vert(9).X
        Vert(25).Y = .Top + .Height
        Vert(26).X = Vert(8).X
        Vert(26).Y = Vert(24).Y
        Vert(27).X = Vert(7).X
        Vert(27).Y = Vert(26).Y
        Vert(28).X = Vert(27).X
        Vert(28).Y = Vert(22).Y
        Vert(29).X = Vert(5).X
        Vert(29).Y = Vert(28).Y
        Vert(30).X = Vert(29).X
        Vert(30).Y = Vert(20).Y
        Vert(31).X = Vert(3).X
        Vert(31).Y = Vert(30).Y
        Vert(32).X = Vert(31).X
        Vert(32).Y = Vert(18).Y
        
        Vert(33) = Vert(1)
    End With
End Sub


Private Sub SetVerticesLeftRightArrowCallout(shp As Shape)
    Dim shftx1 As Single
    Dim shftx2 As Single
    Dim shfty1 As Single
    Dim shfty2 As Single
    
    InitVertices 19
    With shp
        On Error Resume Next
        shftx1 = .Width * 0.125
        shftx2 = .Width * 0.25
        shfty1 = .Height * 0.25
        shfty2 = .Height * 0.375
        
        shftx1 = .Width * .Adjustments(3)
        shftx2 = .Width * .Adjustments(1)
        shfty1 = .Height * .Adjustments(2)
        shfty2 = .Height * .Adjustments(4)
        
        Vert(1).X = .Left
        Vert(1).Y = .Top + .Height / 2
        Vert(2).X = .Left + shftx1
        Vert(2).Y = .Top + shfty1
        Vert(3).X = Vert(2).X
        Vert(3).Y = .Top + shfty2
        Vert(4).X = .Left + shftx2
        Vert(4).Y = Vert(3).Y
        Vert(5).X = Vert(4).X
        Vert(5).Y = .Top
        Vert(6).X = .Left + .Width - shftx2
        Vert(6).Y = Vert(5).Y
        Vert(7).X = Vert(6).X
        Vert(7).Y = Vert(4).Y
        Vert(8).X = .Left + .Width - shftx1
        Vert(8).Y = Vert(7).Y
        Vert(9).X = Vert(8).X
        Vert(9).Y = Vert(2).Y
        Vert(10).X = .Left + .Width
        Vert(10).Y = Vert(1).Y
        Vert(11).X = Vert(8).X
        Vert(11).Y = .Top + .Height - shfty1
        Vert(12).X = Vert(8).X
        Vert(12).Y = .Top + .Height - shfty2
        Vert(13).X = Vert(7).X
        Vert(13).Y = Vert(12).Y
        Vert(14).X = Vert(6).X
        Vert(14).Y = .Top + .Height
        Vert(15).X = Vert(5).X
        Vert(15).Y = Vert(14).Y
        Vert(16).X = Vert(4).X
        Vert(16).Y = Vert(13).Y
        Vert(17).X = Vert(3).X
        Vert(17).Y = Vert(16).Y
        Vert(18).X = Vert(17).X
        Vert(18).Y = Vert(11).Y
        
        Vert(19) = Vert(1)
    End With
End Sub

Private Sub SetVerticesDownArrowCallout(shp As Shape)
    Dim shftx1 As Single
    Dim shftx2 As Single
    Dim shfty1 As Single
    Dim shfty2 As Single
    
    InitVertices 12
    With shp
        On Error Resume Next
        shftx1 = .Width * 0.25
        shftx2 = .Width * 0.375
        shfty1 = .Height * 0.6666667
        shfty2 = .Height * 0.8333333
        
        shftx1 = .Width * .Adjustments(2)
        shftx2 = .Width * .Adjustments(4)
        shfty1 = .Height * .Adjustments(1)
        shfty2 = .Height * .Adjustments(3)
        
        Vert(1).X = .Left
        Vert(1).Y = .Top
        Vert(2).X = .Left + .Width
        Vert(2).Y = .Top
        Vert(3).X = Vert(2).X
        Vert(3).Y = .Top + shfty1
        Vert(4).X = .Left + .Width - shftx2
        Vert(4).Y = Vert(3).Y
        Vert(5).X = Vert(4).X
        Vert(5).Y = .Top + shfty2
        Vert(6).X = .Left + .Width - shftx1
        Vert(6).Y = Vert(5).Y
        Vert(7).X = .Left + .Width / 2
        Vert(7).Y = .Top + .Height
        Vert(8).X = .Left + shftx1
        Vert(8).Y = Vert(5).Y
        Vert(9).X = .Left + shftx2
        Vert(9).Y = Vert(8).Y
        Vert(10).X = Vert(9).X
        Vert(10).Y = Vert(4).Y
        Vert(11).X = .Left
        Vert(11).Y = Vert(10).Y
        
        Vert(12) = Vert(1)
    End With
End Sub

Private Sub SetVerticesUpArrowCallout(shp As Shape)
    Dim shftx1 As Single
    Dim shftx2 As Single
    Dim shfty1 As Single
    Dim shfty2 As Single
    
    InitVertices 12
    With shp
        On Error Resume Next
        shftx1 = .Width * 0.25
        shftx2 = .Width * 0.375
        shfty1 = .Height * 0.166667
        shfty2 = .Height * 0.333333
        
        shftx1 = .Width * .Adjustments(2)
        shftx2 = .Width * .Adjustments(4)
        shfty1 = .Height * .Adjustments(3)
        shfty2 = .Height * .Adjustments(1)
        
        Vert(1).X = .Left
        Vert(1).Y = .Top + shfty2
        Vert(2).X = .Left + shftx2
        Vert(2).Y = .Top + shfty2
        Vert(3).X = Vert(2).X
        Vert(3).Y = .Top + shfty1
        Vert(4).X = .Left + shftx1
        Vert(4).Y = Vert(3).Y
        Vert(5).X = .Left + .Width / 2
        Vert(5).Y = .Top
        Vert(6).X = .Left + .Width - shftx1
        Vert(6).Y = Vert(3).Y
        Vert(7).X = .Left + .Width - shftx2
        Vert(7).Y = Vert(3).Y
        Vert(8).X = Vert(7).X
        Vert(8).Y = .Top + shfty2
        Vert(9).X = .Left + .Width
        Vert(9).Y = Vert(8).Y
        Vert(10).X = Vert(9).X
        Vert(10).Y = .Top + .Height
        Vert(11).X = .Left
        Vert(11).Y = .Top + .Height
        Vert(12) = Vert(1)
    End With
End Sub

Private Sub SetVerticesLeftArrowCallout(shp As Shape)
    Dim shftx1 As Single
    Dim shftx2 As Single
    Dim shfty1 As Single
    Dim shfty2 As Single
    
    InitVertices 12
    With shp
        On Error Resume Next
        shftx1 = .Width * 0.1666667
        shftx2 = .Width * 0.3333333
        shfty1 = .Height * 0.25
        shfty2 = .Height * 0.375
        
        shftx1 = .Width * .Adjustments(3)
        shftx2 = .Width * .Adjustments(1)
        shfty1 = .Height * .Adjustments(2)
        shfty2 = .Height * .Adjustments(4)
        
        Vert(1).X = .Left
        Vert(1).Y = .Top + .Height / 2
        Vert(2).X = .Left + shftx1
        Vert(2).Y = .Top + shfty1
        Vert(3).X = Vert(2).X
        Vert(3).Y = .Top + shfty2
        Vert(4).X = .Left + shftx2
        Vert(4).Y = .Top + shfty2
        Vert(5).X = .Left + shftx2
        Vert(5).Y = .Top
        Vert(6).X = .Left + .Width
        Vert(6).Y = .Top
        Vert(7).X = .Left + .Width
        Vert(7).Y = .Top + .Height
        Vert(8).X = Vert(5).X
        Vert(8).Y = .Top + .Height
        Vert(9).X = Vert(8).X
        Vert(9).Y = .Top + .Height - shfty2
        Vert(10).X = Vert(3).X
        Vert(10).Y = Vert(9).Y
        Vert(11).X = Vert(10).X
        Vert(11).Y = .Top + .Height - shfty1
        Vert(12) = Vert(1)
    End With
End Sub

Private Sub SetVerticesRightArrowCallout(shp As Shape)
    Dim shftx1 As Single
    Dim shftx2 As Single
    Dim shfty1 As Single
    Dim shfty2 As Single
    
    InitVertices 12
    With shp
        On Error Resume Next
        shftx1 = .Width * 0.666667
        shftx2 = .Width * 0.833333
        shfty1 = .Height * 0.25
        shfty2 = .Height * 0.375
        
        shftx1 = .Width * .Adjustments(1)
        shftx2 = .Width * .Adjustments(3)
        shfty1 = .Height * .Adjustments(2)
        shfty2 = .Height * .Adjustments(4)
        
        Vert(1).X = .Left
        Vert(1).Y = .Top
        Vert(2).X = .Left + shftx1
        Vert(2).Y = .Top
        Vert(3).X = .Left + shftx1
        Vert(3).Y = .Top + shfty2
        Vert(4).X = .Left + shftx2
        Vert(4).Y = .Top + shfty2
        Vert(5).X = .Left + shftx2
        Vert(5).Y = .Top + shfty1
        Vert(6).X = .Left + .Width
        Vert(6).Y = .Top + .Height / 2
        Vert(7).X = .Left + shftx2
        Vert(7).Y = .Top + .Height - shfty1
        Vert(8).X = .Left + shftx2
        Vert(8).Y = .Top + .Height - shfty2
        Vert(9).X = .Left + shftx1
        Vert(9).Y = Vert(8).Y
        Vert(10).X = Vert(9).X
        Vert(10).Y = .Top + .Height
        Vert(11).X = .Left
        Vert(11).Y = .Top + .Height
        Vert(12) = Vert(1)
    End With
End Sub

Private Sub SetVerticesChevron(shp As Shape)
    Dim shftx As Single
    InitVertices 7
    With shp
        On Error Resume Next
        shftx = .Width * 0.75
        shftx = .Width * .Adjustments(1)
        
        Vert(1).X = .Left
        Vert(1).Y = .Top
        Vert(2).X = .Left + shftx
        Vert(2).Y = .Top
        Vert(3).X = .Left + .Width
        Vert(3).Y = .Top + .Height / 2
        Vert(4).X = Vert(2).X
        Vert(4).Y = .Top + .Height
        Vert(5).X = .Left
        Vert(5).Y = .Top + .Height
        Vert(6).X = .Left + .Width - shftx
        Vert(6).Y = Vert(3).Y
        Vert(7) = Vert(1)
    End With
End Sub

Private Sub SetVerticesPentagon(shp As Shape)
    InitVertices 6
    With shp
        On Error Resume Next
        Vert(1).X = .Left
        Vert(1).Y = .Top
        Vert(2).X = .Left + .Width * .Adjustments(1)
        If Err.Number <> 0 Then
            Vert(2).X = .Left + .Width * 0.75   ' use default value
            Err.Clear
        End If
        Vert(2).Y = .Top
        Vert(3).X = .Left + .Width
        Vert(3).Y = .Top + .Height / 2
        Vert(4).X = Vert(2).X
        Vert(4).Y = .Top + .Height
        Vert(5).X = .Left
        Vert(5).Y = .Top + .Height
        Vert(6) = Vert(1)
    End With
End Sub

Private Sub SetVerticesNotchedRightArrow(shp As Shape)
    Dim ratio1 As Single
    Dim ratio2 As Single
    Dim shfty As Single
    Dim shftx As Single
    
    InitVertices 9
    With shp
        On Error Resume Next
        ratio1 = 0.75
        ratio2 = 0.25
        
        ratio1 = .Adjustments(1)
        ratio2 = .Adjustments(2)
        shftx = .Width * ratio1     '.Adjustments(1)
        shfty = .Height * ratio2    '.Adjustments(2)
    
        Vert(1).X = .Left
        Vert(1).Y = .Top + shfty
        Vert(2).X = .Left + shftx
        Vert(2).Y = .Top + shfty
        Vert(3).X = Vert(2).X
        Vert(3).Y = .Top
        Vert(4).X = .Left + .Width
        Vert(4).Y = .Top + .Height / 2
        Vert(5).X = Vert(2).X
        Vert(5).Y = .Top + .Height
        Vert(6).X = Vert(2).X
        Vert(6).Y = .Top + .Height - shfty
        Vert(7).X = .Left
        Vert(7).Y = Vert(6).Y
        
'        Vert(8).x = .Left + .Width * (1 - .Adjustments(1)) * (1 - 2 * .Adjustments(2))
        Vert(8).X = .Left + .Width * (1 - ratio1) * (1 - 2 * ratio2)
        Vert(8).Y = .Top + .Height / 2
        Vert(9) = Vert(1)
    End With
End Sub

Private Sub SetVerticesStripeRightArrow(shp As Shape, Optional bRotateNodes As Boolean = True)
    Dim bFilled     As Boolean
    Dim bOutline    As Boolean
    Dim i           As Long
    Dim shftx        As Single
    Dim shfty           As Single
    
    With shp
        On Error Resume Next
        shftx = .Width * .Adjustments(1)
        If Err.Number <> 0 Then
            shftx = .Width * 0.75
            Err.Clear
        End If
        shfty = .Height * .Adjustments(2)
        If Err.Number <> 0 Then
            shfty = .Height * 0.25
            Err.Clear
        End If
        
        InitVertices 15
        
        'rectangle 1
        Vert(1).X = .Left
        Vert(1).Y = .Top + shfty
        Vert(2).X = .Left + .Width * 0.033
        Vert(2).Y = .Top + shfty
        Vert(3).X = Vert(2).X
        Vert(3).Y = .Top + .Height - shfty
        Vert(4).X = .Left
        Vert(4).Y = Vert(3).Y
        
        ' rectangle 2
        Vert(5).X = .Left + .Width * 0.066
        Vert(5).Y = Vert(1).Y
        Vert(6).X = .Left + .Width * 0.13
        Vert(6).Y = Vert(2).Y
        Vert(7).X = Vert(6).X
        Vert(7).Y = Vert(3).Y
        Vert(8).X = Vert(5).X
        Vert(8).Y = Vert(4).Y
        
        ' arrow
        Vert(9).X = .Left + .Width * 0.15625
        Vert(9).Y = Vert(1).Y
        Vert(10).X = .Left + shftx
        Vert(10).Y = Vert(9).Y
        Vert(11).X = Vert(10).X
        Vert(11).Y = .Top
        Vert(12).X = .Left + .Width
        Vert(12).Y = .Top + .Height / 2
        Vert(13).X = Vert(11).X
        Vert(13).Y = .Top + .Height
        Vert(14).X = Vert(13).X
        Vert(14).Y = .Top + .Height - shfty
        Vert(15).X = Vert(9).X
        Vert(15).Y = Vert(14).Y
        
    End With
End Sub

Private Sub ParseStripeRightArrow(shp As Shape, Optional bRotateNodes As Boolean = True)
    ShapeType = aofShapeTypeUserDefinedGroup
    
    ' This shape should be converted to 3 objects (Polygons)
    HasGroupItem = True
    
    ' flip and rotate the vertices.
    NewFlipNodes shp
    NewRotateNodes shp
    
    ' the left most rect
    AddGroupItem
    With GroupItems(GroupItemNum)
        .ShapeType = aofShapeTypePolygon
        .SetGraphmode shp
        .InitVerts 1, 4, Vert, True
        .PrintPointsString
    End With
    
    ' the second rect
    AddGroupItem
    With GroupItems(GroupItemNum)
        .ShapeType = aofShapeTypePolygon
        .SetGraphmode shp
        .InitVerts 5, 4, Vert, True
        .PrintPointsString
    End With
    
    ' the arrow
    AddGroupItem
    With GroupItems(GroupItemNum)
        .ShapeType = aofShapeTypePolygon
        .SetGraphmode shp
        .InitVerts 9, 7, Vert, True
        .PrintPointsString
    End With
End Sub

Private Sub SetVerticesBentUpArrow(shp As Shape)
    Dim shft3 As Single
    Dim shft1 As Single
    Dim shft2 As Single
    Dim Tailw   As Single
    
    InitVertices 10
    
    With shp
        On Error Resume Next
        shft1 = 0.4285648
        shft2 = 0.8571296
        shft3 = 0.3333333
        
        shft1 = .Adjustments(1)
        shft2 = .Adjustments(2)
        shft3 = .Adjustments(3)
        
        Tailw = 2 * shft2 - shft1 - 1
        Dim A As Single
        Dim b As Single
        Dim d As Single
        
        d = (1 + shft1) / 2
        
        d = d * 8.9 / 10
        
        A = (1 - shft1) / (Sqr(1 - d) - Sqr((1 + shft1) / 2 - d))
        b = -A * Sqr((1 + shft1) / 2 - d)
              
        Tailw = A * Sqr(shft2 - d) + b
        
        Vert(1).X = .Left + .Width * shft2
        Vert(1).Y = .Top + .Height
        Vert(2).X = .Left
        Vert(2).Y = .Top + .Height
        Vert(3).X = .Left
        Vert(3).Y = .Top + .Height * (1 - Tailw)
        Vert(4).X = .Left + .Width * (1 + shft1 - shft2)
        Vert(4).Y = Vert(3).Y
        Vert(5).X = Vert(4).X
        Vert(5).Y = .Top + .Height * shft3
        Vert(6).X = .Left + .Width * shft1
        Vert(6).Y = Vert(5).Y
        
        Vert(7).X = .Left + .Width * (1 + shft1) / 2
        Vert(7).Y = .Top
        Vert(8).X = .Left + .Width
        Vert(8).Y = Vert(6).Y
        Vert(9).X = Vert(1).X
        Vert(9).Y = Vert(5).Y
        Vert(10) = Vert(1)
    End With
End Sub

Private Sub SetVerticesLeftUpArrow(shp As Shape)
    Dim shft3 As Single
    Dim shft1 As Single
    Dim shft2 As Single
    
    InitVertices 13
    With shp
        On Error Resume Next
        shft1 = 0.4285648
        shft2 = 0.8571296
        shft3 = 0.2856945
        
        shft1 = .Adjustments(1)
        shft2 = .Adjustments(2)
        shft3 = .Adjustments(3)
        
        Vert(1).X = .Left
        Vert(1).Y = .Top + .Height * (1 + shft1) / 2
        Vert(2).X = .Left + .Width * shft3
        Vert(2).Y = .Top + .Height * shft1
        Vert(3).X = Vert(2).X
        Vert(3).Y = .Top + .Height * (1 + shft1 - shft2)
        Vert(4).X = .Left + .Width * (1 + shft1 - shft2)
        Vert(4).Y = Vert(3).Y
        Vert(5).X = Vert(4).X
        Vert(5).Y = .Top + .Height * shft3
        Vert(6).X = .Left + .Width * shft1
        Vert(6).Y = Vert(5).Y
        
        Vert(7).X = .Left + .Width * (1 + shft1) / 2
        Vert(7).Y = .Top
        Vert(8).X = .Left + .Width
        Vert(8).Y = Vert(6).Y
        Vert(9).X = .Left + .Width * shft2
        Vert(9).Y = Vert(5).Y
        Vert(10).X = Vert(9).X
        Vert(10).Y = .Top + .Height * shft2
        Vert(11).X = Vert(3).X
        Vert(11).Y = Vert(10).Y
        Vert(12).X = Vert(11).X
        Vert(12).Y = .Top + .Height
        Vert(13) = Vert(1)
    End With
End Sub

' the powerpoint has a bug in this shape, sometime it gives
' wrong adjustments.
Private Sub SetVerticesLeftRightUpArrow(shp As Shape)
    Dim shftx1 As Single
    Dim shftx2 As Single
    Dim shfty As Single
    Dim lArrW As Single
    Dim lNeckW As Single
    Dim lArrH   As Single
    
    InitVertices 18
    With shp
        On Error Resume Next
        shftx1 = 0.3
        shftx2 = 0.4
        shfty = 0.2856945
        
        shftx1 = .Adjustments(1)
        shftx2 = .Adjustments(2)
        shfty = .Adjustments(3)
        
        lArrW = .Height * (1 - shftx1 - shftx1) / (2 - shftx1 - shftx1)
        lNeckW = .Height * (shftx2 - shftx1) / (1 - shftx1)
        lArrH = .Width * shfty * (1 - shftx1) * 2 / (3 - 4 * shftx1)
        
        Vert(1).X = .Left
        Vert(1).Y = .Top + .Height - lArrW
        Vert(2).X = .Left + lArrH
        Vert(2).Y = Vert(1).Y - lArrW
        Vert(3).X = Vert(2).X
        Vert(3).Y = Vert(2).Y + lNeckW
        Vert(4).X = .Left + .Width * shftx2
        Vert(4).Y = Vert(3).Y
        Vert(5).X = Vert(4).X
        Vert(5).Y = .Top + .Height * shfty
        Vert(6).X = .Left + .Width * shftx1
        Vert(6).Y = Vert(5).Y

        Vert(7).X = .Left + .Width / 2
        Vert(7).Y = .Top
        Vert(8).X = .Left + .Width * (1 - shftx1)
        Vert(8).Y = Vert(6).Y
        Vert(9).X = .Left + .Width * (1 - shftx2)
        Vert(9).Y = Vert(5).Y
        Vert(10).X = Vert(9).X
        Vert(10).Y = Vert(4).Y
        Vert(11).X = .Left + .Width - lArrH
        Vert(11).Y = Vert(4).Y
        Vert(12).X = Vert(11).X
        Vert(12).Y = Vert(2).Y
        
        Vert(13).X = .Left + .Width
        Vert(13).Y = Vert(1).Y
        Vert(14).X = Vert(11).X
        Vert(14).Y = .Top + .Height
        Vert(15).X = Vert(14).X
        Vert(15).Y = .Top + .Height - lNeckW
        Vert(16).X = Vert(3).X
        Vert(16).Y = Vert(15).Y
        Vert(17).X = Vert(16).X
        Vert(17).Y = Vert(14).Y
        Vert(18) = Vert(1)
        
    End With
End Sub


Private Sub SetVerticesUpDownArrow(shp As Shape)
    Dim shfty As Single
    Dim shftx As Single
    
    InitVertices 11
    With shp
        On Error Resume Next
        shftx = .Width * 0.25
        shfty = .Height * 0.2
        
        shftx = .Width * .Adjustments(1)
        shfty = .Height * .Adjustments(2)
    
        Vert(1).X = .Left
        Vert(1).Y = .Top + shfty
        Vert(2).X = .Left + .Width / 2
        Vert(2).Y = .Top
        Vert(3).X = .Left + .Width
        Vert(3).Y = Vert(1).Y
        Vert(4).X = .Left + .Width - shftx
        Vert(4).Y = Vert(3).Y
        Vert(5).X = Vert(4).X
        Vert(5).Y = .Top + .Height - shfty
        Vert(6).X = .Left + .Width
        Vert(6).Y = Vert(5).Y
        Vert(7).X = Vert(2).X
        Vert(7).Y = .Top + .Height
        Vert(8).X = .Left
        Vert(8).Y = Vert(5).Y
        Vert(9).X = .Left + shftx
        Vert(9).Y = Vert(5).Y
        Vert(10).X = Vert(9).X
        Vert(10).Y = Vert(1).Y
        
        Vert(11) = Vert(1)
    End With
End Sub

Private Sub SetVerticesCube(shp As Shape)
    Dim bFilled     As Boolean
    Dim bOutline    As Boolean
    Dim i           As Long
    Dim shft        As Single
    
    With shp
        On Error Resume Next
        If .Height > .Width Then
            shft = .Width * 0.25
            shft = .Width * .Adjustments(1)
        Else
            shft = .Height * 0.25
            shft = .Height * .Adjustments(1)
        End If
        
        InitVertices 7
        ' the upper side
        Vert(1).X = .Left + shft
        Vert(1).Y = .Top
        Vert(2).X = .Left + .Width
        Vert(2).Y = .Top
        Vert(3).X = .Left
        Vert(3).Y = .Top + shft
        Vert(4).X = .Left + .Width - shft
        Vert(4).Y = .Top + shft
        
        ' the bottom
        Vert(5).X = .Left + .Width
        Vert(5).Y = .Top + .Height - shft
        Vert(6).X = .Left
        Vert(6).Y = .Top + .Height
        Vert(7).X = .Left + .Width - shft
        Vert(7).Y = .Top + .Height
    End With
End Sub

Private Sub ParseCube(shp As Shape)
    
    SetGraphstyle shp
    'NewFlipNodes shp
    NewRotateNodes shp
    
    With shp
        
        Dim bSolidFilled As Boolean
        Dim colorUpper As String
        Dim colorSide  As String
        Dim colorDumm  As String
        
        If .Fill.Visible = msoTrue Then
            bSolidFilled = True
            SetRelatedColors .Fill.ForeColor.RGB, colorDumm, colorUpper, colorSide, colorDumm
        Else
            bSolidFilled = False
        End If
        
        AddGroupItem
        With GroupItems(GroupItemNum)      ' upper
            .ShapeType = aofShapeTypePolygon
            .SetGraphmode shp
            .Set5Vert Vert, 1, 2, 4, 3
            .PrintPointsString
            .FillColor = colorUpper
        End With
        
        AddGroupItem
        With GroupItems(GroupItemNum)      ' front
            .ShapeType = aofShapeTypePolygon
            .SetGraphmode shp
            .Set5Vert Vert, 3, 4, 7, 6
            .PrintPointsString
            .FillColor = FillColor
        End With
        
        AddGroupItem
        With GroupItems(GroupItemNum)      ' side
            .ShapeType = aofShapeTypePolygon
            .SetGraphmode shp
            .Set5Vert Vert, 2, 4, 7, 5
            .PrintPointsString
            .FillColor = colorSide
       End With
        
    End With
    
    ShapeType = aofShapeTypeUserDefinedGroup
End Sub

Private Sub SetRelatedColors(fc As Long, ByRef c1 As String, ByRef c2 As String, ByRef c3 As String, ByRef c4 As String)
    Dim r As Long, g As Long, b As Long
    Dim rt As Long, gt As Long, bt As Long
    Dim a2 As Double, a1 As Double
    
    a1 = 153# / 255#
    a2 = 205# / 255#
    
    r = fc Mod 256
    g = CLng(fc / 256 - 0.5) Mod 256
    b = CLng(fc / 65536 - 0.5)
    
    ' right side color of bevel                             ' c4 = a1 * c
    rt = a1 * r
    gt = a1 * g
    bt = a1 * b
    c4 = GetHexColor(rt, gt, bt)
    
    ' left side color of bevel                              , c1 = a1 * c + 102
    c1 = GetHexColor(rt + 102, gt + 102, bt + 102)
    
    ' right side color of cube, bottom side color of bevel  , c3 = a2 * c
    rt = a2 * r
    gt = a2 * g
    bt = a2 * b
    c3 = GetHexColor(rt, gt, bt)
    
    ' upper color of cube, cylinder and bevel               , c2 = a2 * c + 50
    c2 = GetHexColor(rt + 50, gt + 50, bt + 50)
    
End Sub

Private Function GetHexColor(r As Long, g As Long, b As Long) As String
    Dim rs As String, gs As String, bs As String
    rs = Hex$(r)
    gs = Hex$(g)
    bs = Hex$(b)
    
    If Len(rs) < 2 Then
        rs = "0" & rs
    End If
    If Len(gs) < 2 Then
        gs = "0" & gs
    End If
    If Len(bs) < 2 Then
        bs = "0" & bs
    End If
    
    GetHexColor = "#" & rs & gs & bs
End Function

Sub InitVerts(begin As Long, num As Long, v() As aofNode, Optional bClosed As Boolean = False)
    If bClosed Then
        VertNum = num + 1
    Else
        VertNum = num
    End If
    ReDim Vert(1 To VertNum) As aofNode
    
    Dim i       As Long
    
    For i = 1 To num
        Vert(i) = v(begin + i - 1)
    Next
    
    If bClosed Then
        Vert(VertNum) = v(begin)
    End If
    
    'PrintPointsString
End Sub

Private Function Has3DEffect(shp As Shape) As Boolean
    Dim d As Single
    On Error Resume Next
    If shp.ThreeD.Visible = msoFalse Then
        Has3DEffect = False
        Exit Function
    End If
    d = shp.ThreeD.Depth       ' determine 3D effect
    If Err.Number <> 0 Then
        'MsgBox "This shape has no 3D effect."
        Err.Clear
        Has3DEffect = False
        Exit Function
    Else
        Has3DEffect = True
        Exit Function
    End If
End Function
Private Sub Set3DRectBondaryPoints(shp As Shape, vnum As Long)
    With shp
        vnum = 8 ' callout line points and vertices.
        
        ReDim v(1 To vnum, 1 To 3) As Double    ' coordinates before transform
        
        v(1, 1) = .Left
        v(1, 2) = .Top
        v(2, 1) = .Left + .Width
        v(2, 2) = .Top
        v(3, 1) = .Left
        v(3, 2) = .Top + .Height
        v(4, 1) = .Left + .Width
        v(4, 2) = .Top + .Height
    End With
End Sub

Private Sub FlipV(shp As Shape, vnum)
    Dim i As Long
    
    With shp
        If .HorizontalFlip = msoTrue Then
            For i = 1 To vnum / 2
                v(i, 1) = .Left * 2 + .Width - v(i, 1)
            Next
         End If
        If .VerticalFlip = msoTrue Then
            For i = 1 To vnum / 2
                v(i, 2) = .Top * 2 + .Height - v(i, 2)
            Next
        End If
    End With
End Sub

' Initialize the Vert() array, if ReDim failed, returns -1, otherwise returns VertNum.
Private Function InitVertices(vnum As Long) As Long
    On Error Resume Next
    ' clear the old Vert()
    If HasVertices And VertNum > 0 Then
        Erase Vert
        HasVertices = False
        VertNum = 0
    End If
    ' Init
    Err.Clear
    If vnum > 0 Then
        ReDim Vert(1 To vnum) As aofNode
        If Err.Number <> 0 Then     ' ReDim failed.
            InitVertices = -1
            Err.Clear
            Exit Function
        End If
        VertNum = vnum
        HasVertices = True
    End If
    
    InitVertices = VertNum
End Function

Private Sub DelVertices()
    If HasVertices Then
        If VertNum > 0 Then
            Erase Vert
            VertNum = 0
        End If
    End If
End Sub

Public Sub SetVerticesRect(shp As Shape)
    If InitVertices(5) < 1 Then     ' init Vert() failed
        Exit Sub
    End If
    
    With shp
        Vert(1).X = .Left
        Vert(1).Y = .Top
        Vert(2).X = .Left + .Width
        Vert(2).Y = .Top
        Vert(3).X = .Left + .Width
        Vert(3).Y = .Top + .Height
        Vert(4).X = .Left
        Vert(4).Y = .Top + .Height
        Vert(5) = Vert(1)
    End With
End Sub

Private Sub SetVerticesRightTriangle(shp As Shape)
    InitVertices 4
    
    With shp
        Vert(1).X = .Left
        Vert(1).Y = .Top
        Vert(3).X = .Left
        Vert(3).Y = .Top + .Height
        Vert(2).X = .Left + .Width
        Vert(2).Y = .Top + .Height
        
        Vert(4) = Vert(1)
    End With
End Sub

Private Sub SetVerticesIsoscelesTriangle(shp As Shape)
    Dim shft    As Single
    
    On Error Resume Next

    InitVertices 4
    
    With shp
        shft = .Adjustments(1)
        If Err.Number <> 0 Then
            shft = 0.5
        End If
        Vert(1).X = .Left + .Width * shft
        Vert(2).X = .Left + .Width
        Vert(3).X = .Left
        Vert(1).Y = .Top
        Vert(2).Y = .Top + .Height
        Vert(3).Y = .Top + .Height
        Vert(4) = Vert(1)
    End With
End Sub

Private Sub SetVerticesParallelogram(shp As Shape)
    Dim shft    As Single
    
    InitVertices 5
    With shp
        On Error Resume Next
        shft = .Width * .Adjustments(1)
        If Err.Number <> 0 Then
            shft = .Width * 0.25
        End If

        Vert(1).X = .Left + shft
        Vert(2).X = .Left + .Width
        Vert(3).X = Vert(2).X - shft
        Vert(4).X = .Left
        Vert(1).Y = .Top
        Vert(2).Y = .Top
        Vert(3).Y = .Top + .Height
        Vert(4).Y = Vert(3).Y
        
        Vert(5) = Vert(1)
    End With
End Sub

Private Sub SetVerticesTrapezoid(shp As Shape)
    Dim shft        As Single
        
    InitVertices 5
    With shp
        On Error Resume Next
        shft = CLng(.Width * .Adjustments(1))
        
        If (Err.Number <> 0) Then       '"Der Index in der angegebenen Sammlung ist außerhalb des zulässigen Bereichs."
            shft = CLng(.Width * 0.2)
            Err.Clear
        End If
        
        Vert(1).X = .Left
        Vert(2).X = .Left + .Width
        Vert(3).X = Vert(2).X - shft
        Vert(4).X = .Left + shft
        Vert(1).Y = .Top
        Vert(2).Y = .Top
        Vert(3).Y = .Top + .Height
        Vert(4).Y = Vert(3).Y
        
        Vert(5) = Vert(1)
    End With
    
End Sub

Private Sub SetVerticesDiamond(shp As Shape)
    InitVertices 5
    
    With shp
        Vert(1).X = .Left + (.Width / 2)
        Vert(1).Y = .Top
        Vert(2).X = .Left + .Width
        Vert(2).Y = .Top + (.Height / 2)
        Vert(3).X = Vert(1).X
        Vert(3).Y = .Top + .Height
        Vert(4).X = .Left
        Vert(4).Y = Vert(2).Y
        
        Vert(5) = Vert(1)
    End With
End Sub

Private Sub SetVerticesOctagon(shp As Shape)
    Dim shft    As Single
    
    InitVertices 9
    With shp
        On Error Resume Next
        If .Width < .Height Then
            shft = (.Width * 0.293)
            shft = (.Width * .Adjustments(1))
        Else
            shft = (.Height * 0.293)
            shft = (.Height * .Adjustments(1))
        End If
        Vert(1).X = .Left + shft
        Vert(1).Y = .Top
        Vert(2).X = .Left + .Width - shft
        Vert(2).Y = .Top
        Vert(3).X = .Left + .Width
        Vert(3).Y = .Top + shft
        Vert(4).X = Vert(3).X
        Vert(4).Y = .Top + .Height - shft
        Vert(5).X = Vert(2).X
        Vert(5).Y = .Top + .Height
        Vert(6).X = Vert(1).X
        Vert(6).Y = Vert(5).Y
        Vert(7).X = .Left
        Vert(7).Y = Vert(4).Y
        Vert(8).X = .Left
        Vert(8).Y = Vert(3).Y
        
        Vert(9) = Vert(1)
    End With
End Sub

Private Sub SetVerticesHexagon(shp As Shape)
    Dim shft    As Single
    
    InitVertices 7
    With shp
        On Error Resume Next
        shft = .Adjustments(1)
        If Err.Number <> 0 Then
            shft = 0.2
        End If
        
        If .Width > .Height Then
            shft = (.Width * shft)
        Else
            shft = (.Height * shft)
        End If
        Vert(1).X = .Left + shft
        Vert(1).Y = .Top
        Vert(2).X = .Left + .Width - shft
        Vert(2).Y = .Top
        Vert(3).X = .Left + .Width
        Vert(3).Y = .Top + (.Height / 2)
        Vert(4).X = Vert(2).X
        Vert(4).Y = .Top + .Height
        Vert(5).X = Vert(1).X
        Vert(5).Y = Vert(4).Y
        Vert(6).X = .Left
        Vert(6).Y = Vert(3).Y
            
        Vert(7) = Vert(1)
End With
End Sub

Private Sub SetVerticesRegularPentagon(shp As Shape)
    Dim shft    As Single
    Dim ratio       As Single
    
    InitVertices 6
    With shp
        ratio = 0.363271     ' tan(PI/5) / 2
        Vert(1).X = .Left + (.Width / 2)
        Vert(1).Y = .Top
        Vert(2).X = .Left + .Width
        Vert(2).Y = .Top + (.Height * ratio)
        ratio = 0.2068857       ' ( 1 - tan(PI/5)/2 ) * tan(PI/10)
        shft = (.Width * ratio)
        Vert(3).X = .Left + .Width - shft
        Vert(3).Y = .Top + .Height
        Vert(4).X = .Left + shft
        Vert(4).Y = Vert(3).Y
        Vert(5).X = .Left
        Vert(5).Y = Vert(2).Y
        Vert(6) = Vert(1)
    End With
End Sub

Private Sub SetVerticesRightArrow(shp As Shape)
    Dim shfty As Single
    Dim shftx As Single
    
    InitVertices 8
    
    With shp
        On Error Resume Next
        shfty = .Height * 0.25
        shfty = .Height * .Adjustments(2)
        shftx = .Width * 0.75
        shftx = .Width * .Adjustments(1)
    
        Vert(1).X = .Left
        Vert(1).Y = .Top + shfty
        Vert(2).X = .Left + shftx
        Vert(2).Y = .Top + shfty
        Vert(3).X = Vert(2).X
        Vert(3).Y = .Top
        Vert(4).X = .Left + .Width
        Vert(4).Y = .Top + .Height / 2
        Vert(5).X = Vert(2).X
        Vert(5).Y = .Top + .Height
        Vert(6).X = Vert(2).X
        Vert(6).Y = .Top + .Height - shfty
        Vert(7).X = .Left
        Vert(7).Y = Vert(6).Y
        
        Vert(8) = Vert(1)
    End With
End Sub

Private Sub SetVerticesLeftArrow(shp As Shape)
    Dim shfty As Single
    Dim shftx As Single
    
    InitVertices 8
    With shp
        On Error Resume Next
        shfty = .Height * 0.25
        shftx = .Width * 0.25
        
        shfty = .Height * .Adjustments(1)
        shftx = .Width * .Adjustments(2)
    
        Vert(1).X = .Left
        Vert(1).Y = .Top + .Height / 2
        Vert(2).X = .Left + shftx
        Vert(2).Y = .Top
        Vert(3).X = Vert(2).X
        Vert(3).Y = .Top + shfty
        Vert(4).X = .Left + .Width
        Vert(4).Y = Vert(3).Y
        Vert(5).X = .Left + .Width
        Vert(5).Y = .Top + .Height - shfty
        Vert(6).X = Vert(2).X
        Vert(6).Y = Vert(5).Y
        Vert(7).X = Vert(2).X
        Vert(7).Y = .Top + .Height
        Vert(8) = Vert(1)
    End With
End Sub

Private Sub SetVerticesUpArrow(shp As Shape)
    Dim shfty As Single
    Dim shftx As Single
    
    InitVertices 8
    With shp
        On Error Resume Next
        shfty = .Height * 0.25
        shftx = .Width * 0.25
        
        shfty = .Height * .Adjustments(1)
        shftx = .Width * .Adjustments(2)
    
        Vert(1).X = .Left
        Vert(1).Y = .Top + shfty
        Vert(2).X = .Left + .Width / 2
        Vert(2).Y = .Top
        Vert(3).X = .Left + .Width
        Vert(3).Y = Vert(1).Y
        Vert(4).X = .Left + .Width - shftx
        Vert(4).Y = Vert(1).Y
        Vert(5).X = Vert(4).X
        Vert(5).Y = .Top + .Height
        Vert(6).X = .Left + shftx
        Vert(6).Y = Vert(5).Y
        Vert(7).X = Vert(6).X
        Vert(7).Y = Vert(1).Y
        Vert(8) = Vert(1)
    End With
End Sub

Private Sub SetVerticesDownArrow(shp As Shape)
    Dim shfty As Single
    Dim shftx As Single
    
    InitVertices 8
    With shp
        On Error Resume Next
        shfty = .Height * 0.75
        shftx = .Width * 0.25
        
        shfty = .Height * .Adjustments(1)
        shftx = .Width * .Adjustments(2)
    
        Vert(1).X = .Left
        Vert(1).Y = .Top + shfty
        Vert(2).X = .Left + .Width / 2
        Vert(2).Y = .Top + .Height
        Vert(3).X = .Left + .Width
        Vert(3).Y = Vert(1).Y
        Vert(4).X = .Left + .Width - shftx
        Vert(4).Y = Vert(1).Y
        Vert(5).X = Vert(4).X
        Vert(5).Y = .Top
        Vert(6).X = .Left + shftx
        Vert(6).Y = Vert(5).Y
        Vert(7).X = Vert(6).X
        Vert(7).Y = Vert(1).Y
        Vert(8) = Vert(1)
    End With
End Sub

Private Sub SetVerticesDonut(shp As Shape)
    Dim cirRatio As Single
    Dim shft        As Single
    Dim l           As Single       ' left, top, width and height of the inner circle
    Dim t           As Single
    Dim w           As Single
    Dim h           As Single
    
    InitVertices 26
    
    On Error Resume Next
    With shp
        cirRatio = 0.28
        
        shft = .Adjustments(1)
        If Err.Number <> 0 Then
            shft = 0.25
            Err.Clear
        End If
        
        Vert(1).X = .Left
        Vert(1).Y = .Top + .Height / 2
        Vert(1).SegType = msoSegmentCurve
        Vert(2).X = .Left
        Vert(2).Y = Vert(1).Y - .Height * cirRatio
        Vert(2).SegType = msoSegmentCurve
        Vert(3).X = .Left + .Width * (0.5 - cirRatio)
        Vert(3).Y = .Top
        Vert(3).SegType = msoSegmentCurve
        Vert(4).X = .Left + .Width / 2
        Vert(4).Y = .Top
        Vert(4).SegType = msoSegmentCurve
        Vert(5).X = Vert(4).X + .Width * cirRatio
        Vert(5).Y = .Top
        Vert(5).SegType = msoSegmentCurve
        Vert(6).X = .Left + .Width
        Vert(6).Y = Vert(2).Y
        Vert(6).SegType = msoSegmentCurve
        Vert(7).X = Vert(6).X
        Vert(7).Y = Vert(1).Y
        Vert(7).SegType = msoSegmentCurve
        Vert(8).X = Vert(7).X
        Vert(8).Y = Vert(7).Y + .Height * cirRatio
        Vert(8).SegType = msoSegmentCurve
        Vert(9).X = Vert(5).X
        Vert(9).Y = .Top + .Height
        Vert(9).SegType = msoSegmentCurve
        Vert(10).X = Vert(4).X
        Vert(10).Y = Vert(9).Y
        Vert(10).SegType = msoSegmentCurve
        Vert(11).X = Vert(3).X
        Vert(11).Y = Vert(10).Y
        Vert(11).SegType = msoSegmentCurve
        Vert(12).X = Vert(1).X
        Vert(12).Y = Vert(8).Y
        Vert(12).SegType = msoSegmentCurve
        Vert(13) = Vert(1)
        Vert(13).SegType = msoSegmentLine
                
        ' inner circle
        l = .Left + .Width * shft
        t = .Top + .Height * shft
        w = .Width * (1 - shft * 2)
        h = .Height * (1 - shft * 2)
        
        Vert(14).X = l
        Vert(14).Y = t + h / 2
        Vert(14).SegType = msoSegmentCurve
        Vert(15).X = l
        Vert(15).Y = t + h * (0.5 + cirRatio)
        Vert(15).SegType = msoSegmentCurve
        Vert(16).X = l + w * (0.5 - cirRatio)
        Vert(16).Y = t + h
        Vert(16).SegType = msoSegmentCurve
        Vert(17).X = l + w / 2
        Vert(17).Y = t + h
        Vert(17).SegType = msoSegmentCurve
        Vert(18).X = Vert(17).X + w * cirRatio
        Vert(18).Y = t + h
        Vert(18).SegType = msoSegmentCurve
        Vert(19).X = l + w
        Vert(19).Y = Vert(15).Y
        Vert(19).SegType = msoSegmentCurve
        Vert(20).X = Vert(19).X
        Vert(20).Y = Vert(14).Y
        Vert(20).SegType = msoSegmentCurve
        Vert(21).X = Vert(20).X
        Vert(21).Y = Vert(20).Y - h * cirRatio
        Vert(21).SegType = msoSegmentCurve
        Vert(22).X = Vert(18).X
        Vert(22).Y = t
        Vert(22).SegType = msoSegmentCurve
        Vert(23).X = Vert(17).X
        Vert(23).Y = t
        Vert(23).SegType = msoSegmentCurve
        Vert(24).X = Vert(16).X
        Vert(24).Y = t
        Vert(24).SegType = msoSegmentCurve
        Vert(25).X = l
        Vert(25).Y = Vert(21).Y
        Vert(25).SegType = msoSegmentCurve
        Vert(26) = Vert(14)

    End With
End Sub

Public Sub SetShapeAsPolygon(gs As Long, pntStr As String, col As String, fcol As String)
    ShapeType = aofShapeTypePolygon
    GraphStyle = gs
    PointsString = pntStr
    LineColor = col
    FillColor = fcol
    Invisible = False
End Sub

Public Sub SetVerticesOval(shp As Shape, _
                            Optional bUserDefined As Boolean = False, _
                            Optional sl As Single, Optional st As Single, _
                            Optional sw As Single, Optional sh As Single)
    Dim cirRatio As Single
    'Dim l As Single, t As Single, w As Single, h As Single
    
    If Not bUserDefined Then
        sl = shp.Left
        st = shp.Top
        sw = shp.Width
        sh = shp.Height
    End If
    
    InitVertices 13
    
    With shp
        cirRatio = 0.28
        Vert(1).X = sl
        Vert(1).Y = st + sh / 2
        Vert(1).SegType = msoSegmentCurve
        Vert(2).X = sl
        Vert(2).Y = Vert(1).Y - sh * cirRatio
        Vert(2).SegType = msoSegmentCurve
        Vert(3).X = sl + sw * (0.5 - cirRatio)
        Vert(3).Y = st
        Vert(3).SegType = msoSegmentCurve
        Vert(4).X = sl + sw / 2
        Vert(4).Y = st
        Vert(4).SegType = msoSegmentCurve
        Vert(5).X = Vert(4).X + sw * cirRatio
        Vert(5).Y = st
        Vert(5).SegType = msoSegmentCurve
        Vert(6).X = sl + sw
        Vert(6).Y = Vert(2).Y
        Vert(6).SegType = msoSegmentCurve
        Vert(7).X = Vert(6).X
        Vert(7).Y = Vert(1).Y
        Vert(7).SegType = msoSegmentCurve
        Vert(8).X = Vert(7).X
        Vert(8).Y = Vert(7).Y + sh * cirRatio
        Vert(8).SegType = msoSegmentCurve
        Vert(9).X = Vert(5).X
        Vert(9).Y = st + sh
        Vert(9).SegType = msoSegmentCurve
        Vert(10).X = Vert(4).X
        Vert(10).Y = Vert(9).Y
        Vert(10).SegType = msoSegmentCurve
        Vert(11).X = Vert(3).X
        Vert(11).Y = Vert(10).Y
        Vert(11).SegType = msoSegmentCurve
        Vert(12).X = Vert(1).X
        Vert(12).Y = Vert(8).Y
        Vert(12).SegType = msoSegmentCurve
        Vert(13) = Vert(1)
    End With
End Sub

Private Sub SetVerticesLeftRightArrow(shp As Shape)
    Dim shfty As Single
    Dim shftx As Single
    
    InitVertices 11
    With shp
        On Error Resume Next
        shftx = .Width * 0.2
        shfty = .Height * 0.25
        
        shftx = .Width * .Adjustments(1)
        shfty = .Height * .Adjustments(2)
    
        Vert(1).X = .Left
        Vert(1).Y = .Top + .Height / 2
        Vert(2).X = .Left + shftx
        Vert(2).Y = .Top
        Vert(3).X = Vert(2).X
        Vert(3).Y = .Top + shfty
        Vert(4).X = .Left + .Width - shftx
        Vert(4).Y = Vert(3).Y
        Vert(5).X = Vert(4).X
        Vert(5).Y = .Top
        Vert(6).X = .Left + .Width
        Vert(6).Y = Vert(1).Y
        Vert(7).X = Vert(4).X
        Vert(7).Y = .Top + .Height
        Vert(8).X = Vert(4).X
        Vert(8).Y = .Top + .Height - shfty
        Vert(9).X = Vert(2).X
        Vert(9).Y = Vert(8).Y
        Vert(10).X = Vert(2).X
        Vert(10).Y = .Top + .Height
        Vert(11) = Vert(1)
    End With
End Sub

Private Sub SetVerticesUpDownArrowCallout(shp As Shape)
    Dim shftx1 As Single
    Dim shftx2 As Single
    Dim shfty1 As Single
    Dim shfty2 As Single
    
    InitVertices 19
    With shp
        On Error Resume Next
        shftx1 = .Width * 0.25
        shftx1 = .Width * .Adjustments(2)
        shftx2 = .Width * 0.375
        shftx2 = .Width * .Adjustments(4)
        shfty1 = .Height * 0.125
        shfty1 = .Height * .Adjustments(3)
        shfty2 = .Height * 0.25
        shfty2 = .Height * .Adjustments(1)
        
        Vert(1).X = .Left
        Vert(1).Y = .Top + shfty2
        Vert(2).X = .Left + shftx2
        Vert(2).Y = Vert(1).Y
        Vert(3).X = Vert(2).X
        Vert(3).Y = .Top + shfty1
        Vert(4).X = .Left + shftx1
        Vert(4).Y = Vert(3).Y
        Vert(5).X = .Left + .Width / 2
        Vert(5).Y = .Top
        Vert(6).X = .Left + .Width - shftx1
        Vert(6).Y = Vert(4).Y
        Vert(7).X = .Left + .Width - shftx2
        Vert(7).Y = Vert(6).Y
        Vert(8).X = Vert(7).X
        Vert(8).Y = Vert(2).Y
        Vert(9).X = .Left + .Width
        Vert(9).Y = Vert(2).Y
        Vert(10).X = .Left + .Width
        Vert(10).Y = .Top + .Height - shfty2
        Vert(11).X = Vert(8).X
        Vert(11).Y = Vert(10).Y
        Vert(12).X = Vert(11).X
        Vert(12).Y = .Top + .Height - shfty1
        Vert(13).X = Vert(6).X
        Vert(13).Y = Vert(12).Y
        Vert(14).X = Vert(5).X
        Vert(14).Y = .Top + .Height
        Vert(15).X = Vert(4).X
        Vert(15).Y = Vert(12).Y
        Vert(16).X = Vert(2).X
        Vert(16).Y = Vert(12).Y
        Vert(17).X = Vert(2).X
        Vert(17).Y = Vert(11).Y
        Vert(18).X = Vert(1).X
        Vert(18).Y = Vert(17).Y
        Vert(19) = Vert(1)
    End With

End Sub

Private Sub SetShapeVertices(shp As Shape)
    
    Select Case shp.AutoShapeType
        Case msoShapeMixed  ' shape maybe msoLine or msoTextBox
            Select Case shp.Type
                Case MsoShapeType.msoLine
                    If InitVertices(2) < 1 Then     ' init Vert() failed
                        Exit Sub
                    End If
                    
                    With shp
                        Vert(1).X = .Left
                        Vert(1).Y = .Top
                        Vert(2).X = .Left + .Width
                        Vert(2).Y = .Top + .Height
                    End With
                'Case MsoShapeType.msoTextBox
                Case Else   ' msoTable have no shadow
                     If shp.Connector = msoTrue Then
                          Select Case shp.ConnectorFormat.Type
                              Case msoConnectorStraight
                                  SetVerticesConnectorStraight shp
                              Case msoConnectorElbow
                                  SetVerticesConnectorElbow shp
                              Case msoConnectorCurve
                                  SetVerticesConnectorCurve shp
                              Case Else
                                  SetVerticesConnectorElbow shp
                          End Select
                      Else
                          ShpIsUnsupported = True
                          SetVerticesRect shp         ' set bounding box as a rectangle
                    End If
            End Select
        Case MsoAutoShapeType.msoShapeRectangle, MsoAutoShapeType.msoShapeFlowchartProcess
            SetVerticesRect shp
        Case MsoAutoShapeType.msoShapeRightTriangle
            SetVerticesRightTriangle shp
        Case MsoAutoShapeType.msoShapeIsoscelesTriangle
            SetVerticesIsoscelesTriangle shp
        Case MsoAutoShapeType.msoShapeParallelogram, MsoAutoShapeType.msoShapeFlowchartData
            SetVerticesParallelogram shp
        Case MsoAutoShapeType.msoShapeTrapezoid, msoShapeFlowchartManualOperation
            SetVerticesTrapezoid shp
        Case MsoAutoShapeType.msoShapeDiamond, MsoAutoShapeType.msoShapeFlowchartDecision
            SetVerticesDiamond shp
        Case MsoAutoShapeType.msoShapeOctagon
            SetVerticesOctagon shp
        Case MsoAutoShapeType.msoShapeHexagon, msoShapeFlowchartPreparation
            SetVerticesHexagon shp
        Case MsoAutoShapeType.msoShapeRegularPentagon
            SetVerticesRegularPentagon shp
        Case MsoAutoShapeType.msoShapeRightArrow
            SetVerticesRightArrow shp
        Case MsoAutoShapeType.msoShapeLeftArrow
            SetVerticesLeftArrow shp
        Case MsoAutoShapeType.msoShapeUpArrow
            SetVerticesUpArrow shp
        Case MsoAutoShapeType.msoShapeDownArrow
            SetVerticesDownArrow shp
        Case MsoAutoShapeType.msoShapeLeftRightArrow
            SetVerticesLeftRightArrow shp
        Case MsoAutoShapeType.msoShapeUpDownArrow
            SetVerticesUpDownArrow shp
        Case MsoAutoShapeType.msoShapeQuadArrow
            SetVerticesQuadArrow shp
        Case MsoAutoShapeType.msoShapeLeftRightUpArrow
            SetVerticesLeftRightUpArrow shp
        Case MsoAutoShapeType.msoShapeLeftUpArrow
            SetVerticesLeftUpArrow shp
        Case MsoAutoShapeType.msoShapeBentUpArrow
            SetVerticesBentUpArrow shp
        Case MsoAutoShapeType.msoShapeStripedRightArrow
            SetVerticesStripeRightArrow shp
        Case MsoAutoShapeType.msoShapeNotchedRightArrow
            SetVerticesNotchedRightArrow shp
        Case MsoAutoShapeType.msoShapePentagon
            SetVerticesPentagon shp
        Case MsoAutoShapeType.msoShapeChevron
            SetVerticesChevron shp
        Case MsoAutoShapeType.msoShapeRightArrowCallout
            SetVerticesRightArrowCallout shp
        Case MsoAutoShapeType.msoShapeLeftArrowCallout
            SetVerticesLeftArrowCallout shp
        Case MsoAutoShapeType.msoShapeUpArrowCallout
            SetVerticesUpArrowCallout shp
        Case MsoAutoShapeType.msoShapeDownArrowCallout
            SetVerticesDownArrowCallout shp
        Case MsoAutoShapeType.msoShapeLeftRightArrowCallout
            SetVerticesLeftRightArrowCallout shp
        Case MsoAutoShapeType.msoShapeUpDownArrowCallout
            SetVerticesUpDownArrowCallout shp
        Case MsoAutoShapeType.msoShapeQuadArrowCallout
            SetVerticesQuadArrowCallout shp
        Case MsoAutoShapeType.msoShapeFlowchartConnector, msoShapeOval
            'SetAsOval shp
            SetVerticesOval shp
        Case msoShapeDonut
            SetVerticesDonut shp
        Case MsoAutoShapeType.msoShapeFlowchartOffpageConnector
            SetVerticesFlowchartOffpageConnector shp
        Case MsoAutoShapeType.msoShapeFlowchartManualInput
            SetVerticesFlowchartManualInput shp
        Case msoShapeFlowchartCard
            SetVerticesFlowchartCard shp
        Case msoShapeFlowchartOr        ' no 3D effect.
            SetVerticesFlowchartOr shp
        Case msoShapeFlowchartCollate
            SetVerticesFlowchartCollate shp
        Case msoShapeFlowchartExtract
            SetVerticesFlowchartExtract shp
        Case msoShapeFlowchartMerge
            SetVerticesFlowchartMerge shp
        Case msoShapeFlowchartStoredData
            SetVerticesFlowchartStoredData shp
        Case msoShapeFlowchartPunchedTape
            SetVerticesFlowchartPunchedTape shp
        Case msoShapeFlowchartPredefinedProcess     ' no 3D effect
            SetVerticesFlowchartPredefinedProcess shp
        Case msoShapeFlowchartInternalStorage
            SetVerticesFlowchartInternalStorage shp
        Case msoShapeFlowchartDocument
            SetVerticesFlowchartDocument shp
        Case msoShapeFlowchartAlternateProcess, msoShapeRoundedRectangle
            SetVerticesFlowchartAlternateProcess shp
        Case msoShapeFlowchartTerminator
            SetVerticesFlowchartTerminator shp
        Case msoShapeFlowchartDelay
            SetVerticesFlowchartDelay shp
        Case msoShapeFlowchartSequentialAccessStorage
            SetVerticesFlowchartSequentialAccessStorage shp
        Case msoShapeFlowchartDisplay
            SetVerticesFlowchartDisplay shp
        Case msoShapeCross
            SetVerticesCross shp
        Case msoShapeBentArrow
            SetVerticesBentArrow shp
        Case msoShapeUTurnArrow
            SetVerticesUTurnArrow shp
        Case msoShapeLeftBracket
            SetVerticesLeftBrackt shp
        Case msoShapeRightBracket
            SetVerticesRightBrackt shp
        Case msoShapeLeftBrace
            SetVerticesLeftBrace shp
        Case msoShapeRightBrace
            SetVerticesRightBrace shp
        Case msoShapeExplosion1
            SetVerticesExplosion1 shp
        Case msoShapeExplosion2
            SetVerticesExplosion2 shp
        Case msoShape4pointStar
            SetVertices4pointStar shp
        Case msoShape5pointStar
            SetVertices5pointStar shp
        Case msoShape8pointStar
            SetVertices8pointStar shp
        Case msoShapeLightningBolt
            SetVerticesLightningBolt shp
        Case msoShapeMoon
            SetVerticesMoon shp
        Case MsoAutoShapeType.msoShapeCube
            SetVerticesCube shp
        Case msoShapeFlowchartSort
            SetVerticesFlowchartSort shp
        Case msoShapeFlowchartMultidocument
            SetVerticesFlowchartMultidocument shp
        Case msoShapeFlowchartSummingJunction
            SetVerticesFlowchartSummingJunction shp
        Case msoShapeCan, msoShapeFlowchartMagneticDisk
            SetVerticesCan shp
        Case msoShapeFlowchartDirectAccessStorage
            SetVerticesFlowchartDirectAccessStorage shp
        Case msoShapeBevel, msoShapeActionButtonCustom
            SetVerticesBevel shp
        Case msoShapeDoubleBracket
            SetVerticesDoubleBracket shp
        Case msoShapeDoubleBrace
            SetVerticesDoubleBrace shp
        Case msoShapePlaque
            SetVerticesPlaque shp
        Case msoShapeFoldedCorner
            SetVerticesFoldedCorner shp
        Case msoShapeSmileyFace
            SetVerticesSmileyFace shp
        Case msoShapeCurvedRightArrow
            SetVerticesCurvedRightArrow shp
        Case msoShapeCurvedLeftArrow
            SetVerticesCurvedLeftArrow shp
        Case msoShapeCurvedUpArrow
            SetVerticesCurvedUpArrow shp
        Case msoShapeCurvedDownArrow
            SetVerticesCurvedDownArrow shp
        Case msoShapeRectangularCallout     ' 3D effect still incorrect
            SetVerticesRectangularCallout shp
        Case msoShapeRoundedRectangularCallout ' 3D effect still incorrect
            SetVerticesRoundedRectangularCallout shp
        Case msoShapeOvalCallout, msoShapeCloudCallout
            SetVerticesOvalCallout shp
        Case Else
            ShpIsUnsupported = True
            SetVerticesRect shp
    End Select

    NewFlipNodes shp

End Sub

Private Sub SetNewCalloutAnchor(shp As Shape)
    Dim l As Single, t As Single, r As Single, b As Single
    Dim i As Long
    
    NewFlipNodes shp
    NewRotateNodes shp
    ' get the dimension
    l = X
    r = X
    t = Y
    b = Y
    For i = 1 To VertNum
        If Vert(i).X < l Then
            l = Vert(i).X
        ElseIf Vert(i).X > r Then
            r = Vert(i).X
        End If
        If Vert(i).Y < t Then
            t = Vert(i).Y
        ElseIf Vert(i).Y > b Then
            b = Vert(i).Y
        End If
    Next
    
    X = l
    Y = t
    Width = r - l
    Height = b - t
    
End Sub

' the vertices can only be used to find out the dimension,
' they're not the actual bounding points.
Private Sub SetVerticesOvalCallout(shp As Shape)
    Dim ratio1 As Single, ratio2 As Single, shftx3 As Single, shfty3 As Single
    
    SetVerticesOval shp
    VertNum = VertNum + 1
    ReDim Preserve Vert(1 To VertNum) As aofNode
    
    With shp
        On Error Resume Next
        ratio1 = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio1 = 0.0625
            Err.Clear
        End If
        ratio2 = .Adjustments(2)
        If Err.Number <> 0 Then
            ratio2 = 1.2
        End If
        On Error GoTo 0
        
        ' the callout point
        shftx3 = .Width * ratio1
        shfty3 = .Height * ratio2
        
        Vert(VertNum).X = .Left + shftx3
        Vert(VertNum).Y = .Top + shfty3
    End With
End Sub

Private Sub ParseDonut(shp As Shape)
    
    NewRotateNodes shp     ' rotate vertices
    SetGraphstyle shp
    
    If GraphStyle = aofGraphStyleFilled Or GraphStyle = aofGraphStyleFilledOutline Then
        ' add the filled polygon
        AddGroupItem
        With GroupItems(GroupItemNum)
            .ShapeType = aofShapeTypePolygon
            .GraphStyle = aofGraphStyleFilled       ' no outlines
            .InitVerts 1, VertNum, Vert, True
            .FillColor = FillColor
            .PrintPointsString
        End With
    End If
        
    If GraphStyle = aofGraphStyleOutline Or GraphStyle = aofGraphStyleFilledOutline Then
        ' add the outlines
        AddGroupItem
        With GroupItems(GroupItemNum)
'            If shp.Rotation = 0 Then
'                .SetAsOval shp
'                .GraphStyle = aofGraphStyleOutline
'            Else
                .ShapeType = aofShapeTypePolygon
                .GraphStyle = aofGraphStyleOutline
                .InitVerts 1, 13, Vert, True
                .LineColor = LineColor
                .PrintPointsString
'            End If
        End With
        
        AddGroupItem
        BPoints.Clear
        NewSetBoundingPoints 14, 26      ' inner circle
        BPoints.PrintString
        With GroupItems(GroupItemNum)
            .ShapeType = aofShapeTypePolygon
            .GraphStyle = aofGraphStyleOutline
            .InitVerts 14, 13, Vert, True
            .LineColor = LineColor
            .PrintPointsString
        End With
    End If
    
    ShapeType = aofShapeTypeUserDefinedGroup
    
End Sub

Private Sub NewFlipNodes(shp As Shape)
    Dim midline     As Long
    Dim i           As Long
    
    With shp
        If .VerticalFlip = msoTrue Then
            midline = .Top * 2 + .Height
            For i = 1 To VertNum
                Vert(i).Y = midline - Vert(i).Y
            Next
        End If
        If .HorizontalFlip = msoTrue Then
            midline = .Left * 2 + .Width
            For i = 1 To VertNum
                Vert(i).X = midline - Vert(i).X
            Next
        End If
    End With
End Sub

Public Sub NewRotateNodes(shp As Shape) '(rotAng As Long)
    Dim c11     As Double
    Dim c12     As Double
    Dim c21     As Double
    Dim c22     As Double
    Dim d1      As Double
    Dim d2      As Double
    Dim ang     As Double
    
    Dim nx      As Double
'    Dim ny      As Double
    
    If shp.Rotation = 0 Then
        Exit Sub
    End If
    
    ang = -shp.Rotation * PI / 180
    c11 = Cos(ang)
    c12 = Sin(ang)
    c21 = -c12
    c22 = c11
    
    Dim x0      As Double
    Dim y0      As Double
    
    x0 = shp.Left + shp.Width / 2
    y0 = shp.Top + shp.Height / 2
    
    d1 = x0 - x0 * c11 - y0 * c12
    d2 = y0 - x0 * c21 - y0 * c22
    
    Dim i        As Long
    
    For i = 1 To VertNum
        With Vert(i)
            nx = .X
            .X = c11 * .X + c12 * .Y + d1
            .Y = c21 * nx + c22 * .Y + d2
        End With
    Next
End Sub

Private Sub SetBoundingPoints()
    Dim i                   As Long
    Dim j                   As Long
    Dim strTemp             As String
    Dim InsertedPoints      As Long
    Dim sgPoints(0 To 3)    As WBPoint
    
    Set BPoints = New aofPoints
    
    i = 1
    Do While i <= VertNum
        With Vert(i)
            If .SegType = MsoSegmentType.msoSegmentLine Then        ' line segment
                strTemp = strTemp & "{" & CLng(.X) & " " & CLng(.Y) & "} "
                i = i + 1
                PointNum = PointNum + 1
                
                BPoints.Add CLng(.X), CLng(.Y)
            
            Else        'nSegType = MsoSegmentType.msoSegmentCurve   bezier curve segment
                If i < VertNum Then        ' else reached the end of Vertices.
                    For j = 1 To 4
                        If i - 1 + j <= VertNum Then
                            sgPoints(j - 1).X = Vert(i - 1 + j).X
                            sgPoints(j - 1).Y = Vert(i - 1 + j).Y
                        Else
                            sgPoints(j - 1).X = Vert(1).X
                            sgPoints(j - 1).Y = Vert(1).Y
                        End If
                    Next
                    strTemp = strTemp & InsertBezierPoints(sgPoints, InsertedPoints)
                    i = i + 3
                    PointNum = PointNum + InsertedPoints
                Else
                    strTemp = strTemp & "{" & CLng(.X) & " " & CLng(.Y) & "} "
                    i = i + 1
                    PointNum = PointNum + 1
                    
                    BPoints.Add CLng(.X), CLng(.Y)
                
                End If
            End If
        End With
    Loop
        
    If BPoints.Count < 1 Then
        Invisible = True
    End If
'    PointsString = BPoints.PrintString()
End Sub

Private Sub NewSetBoundingPoints(Optional nBegin As Long = -1, Optional nEnd As Long = -1)
    Dim i                   As Long
    Dim j                   As Long
    Dim strTemp             As String
    Dim InsertedPoints      As Long
    Dim sgPoints(0 To 3)    As WBPoint
    Dim nb                  As Long
    Dim ne                  As Long
    
'    Set BPoints = New aofPoints
    
    If nBegin < 0 Or nEnd < 0 Then
        nb = 1
        ne = VertNum
    Else
        nb = nBegin
        ne = nEnd
    End If
    
    On Error Resume Next        ' user-defined nBegin and nEnd may cuase the index overflow of Vert()
    i = nb '1
    Do While i <= ne 'VertNum
        With Vert(i)
            If .SegType = MsoSegmentType.msoSegmentLine Then        ' line segment
                strTemp = strTemp & "{" & CLng(.X) & " " & CLng(.Y) & "} "
                i = i + 1
                PointNum = PointNum + 1
                
                BPoints.Add CLng(.X), CLng(.Y)
            
            Else        'nSegType = MsoSegmentType.msoSegmentCurve   bezier curve segment
                If i < VertNum Then        ' else reached the end of Vertices.
                    For j = 1 To 4
                        If i - 1 + j <= VertNum Then
                            sgPoints(j - 1).X = Vert(i - 1 + j).X
                            sgPoints(j - 1).Y = Vert(i - 1 + j).Y
                        Else
                            sgPoints(j - 1).X = Vert(1).X
                            sgPoints(j - 1).Y = Vert(1).Y
                        End If
                    Next
                    strTemp = strTemp & InsertBezierPoints(sgPoints, InsertedPoints)
                    i = i + 3
                    PointNum = PointNum + InsertedPoints
                Else
                    strTemp = strTemp & "{" & CLng(.X) & " " & CLng(.Y) & "} "
                    i = i + 1
                    PointNum = PointNum + 1
                    
                    BPoints.Add CLng(.X), CLng(.Y)
                
                End If
            End If
        End With
    Loop
        
    If BPoints.Count < 1 Then
        Invisible = True
    End If
'    PointsString = BPoints.PrintString()
End Sub

Public Sub ParseSimpleShape(shp As Shape)
    SetGraphmode shp
    NewRotateNodes shp
    NewSetBoundingPoints
    IsClosedPolyline = BPoints.IsClosed()
    PointsString = BPoints.PrintString()
    ShapeType = aofShapeTypePolygon
End Sub

Public Sub NewParseAutoshape(shp As Shape)
    SetShapeVertices shp
    
    If ShpIsUnsupported Then
        SetAsImage shp:=shp, iDelTrans:=0
        Exit Sub
    End If
    
    If ShpIsComplex Then
        ParseComplexShapes shp
    Else
        ParseSimpleShape shp
    End If
End Sub

Private Sub ParseComplexShapes(shp As Shape)
    Select Case shp.AutoShapeType
        Case MsoAutoShapeType.msoShapeStripedRightArrow
            ParseStripeRightArrow shp
        Case MsoAutoShapeType.msoShapeFlowchartConnector, msoShapeOval
            SetAsOval shp
        Case msoShapeDonut
            ParseDonut shp
        Case msoShapeFlowchartOr        ' no 3D effect.
            ParseFlowchartOr shp
        Case MsoAutoShapeType.msoShapeCube
            ParseCube shp
        Case msoShapeFlowchartSummingJunction
            ParseFlowchartSummingJunction shp
        Case msoShapeCan, msoShapeFlowchartMagneticDisk
            ParseCan shp
        Case msoShapeBevel, msoShapeActionButtonCustom
            ParseBevel shp
        Case msoShapeDoubleBracket
            ParseDoubleBracket shp
        Case msoShapeDoubleBrace
            ParseDoubleBrace shp
        Case msoShapeFoldedCorner
            ParseFoldedCorner shp
        Case msoShapeSmileyFace
            ParseSmileyFace shp
        Case msoShapeCurvedRightArrow
            ParseCurvedRightArrow shp
        Case msoShapeCurvedLeftArrow
            ParseCurvedLeftArrow shp
        Case msoShapeCurvedUpArrow
            ParseCurvedUpArrow shp
        Case msoShapeCurvedDownArrow
            ParseCurvedDownArrow shp
        Case msoShapeOvalCallout, msoShapeCloudCallout
            If ShpHasConvertableText Then
                SetAsImageWithoutText shp
            Else
                SetAsImage shp
            End If
            SetNewCalloutAnchor shp
            iCutTransOff = 0
        Case Else
            If ShpHasConvertableText Then
                SetAsImageWithoutText shp
            Else
                SetAsImage shp
            End If
            SetNewAnchor shp
            iCutTransOff = 0
        End Select
End Sub

Public Sub NewSet3DBoundaryPoints(shp As Shape)
    bParsingAutoshape = False
    SetShapeVertices shp
    ' do not rotate the shape, the shape should be rotated in ThreeDTransform()
    NewSetBoundingPoints
    ' ThreedTransform here
              
    Dim vnum        As Long         ' the number of boundary points
    Dim i           As Long
    Dim ExtrusionDir As Long
    Dim offsetWidth  As Single
    Dim offsetHeight As Single
    
    offsetWidth = 0
    offsetHeight = 0
    
    vnum = BPoints.Count * 2
    ReDim v(1 To vnum, 1 To 3)
    BPoints.SetV v
    
    On Error Resume Next
    With shp
        ExtrusionDir = .ThreeD.PresetExtrusionDirection
        If Err.Number <> 0 Then
            ExtrusionDir = -1
        End If
        
        ThreeDTransform vnum, .ThreeD.RotationX, .ThreeD.RotationY, .Rotation, _
                    .Left, .Top, .Width + offsetWidth, .Height + offsetHeight, _
                    .ThreeD.Depth, .ThreeD.Perspective, ExtrusionDir
    End With
End Sub

Private Sub Set3DObjectOffset(shp As Shape)
    NewSet3DBoundaryPoints shp
End Sub

Private Function ThreeDTransform(vnum As Long, rx As Single, ry As Single, rz As Single, _
                        l As Single, t As Single, w As Single, h As Single, d As Single, _
                        bPerspective As Boolean, ExtrusionDir As Long)
    Dim T11 As Double
    Dim T12 As Double
    Dim T13 As Double
    Dim T21 As Double
    Dim T22 As Double
    Dim T23 As Double
    Dim T31 As Double
    Dim T32 As Double
    Dim T33 As Double
    
    Dim sa As Double
    Dim ca As Double
    Dim sb As Double
    Dim cb As Double
    Dim sc As Double
    Dim cc As Double
    
    Dim x0 As Double
    Dim y0 As Double
    
    Dim hw As Double
    Dim hh As Double
    
    Dim r As Double
    
    Dim i As Long, j As Long
    
'    Dim v(1 To 8, 1 To 3) As Double     ' coordinates before transform
'    Dim p(1 To 8, 1 To 3) As Double     ' coordiantes after transform
'    Dim f(1 To 8, 1 To 2) As Double     ' coordinates after 2D affine transform
    ReDim p(1 To vnum, 1 To 3) As Double    ' coordiantes after transform
    ReDim f(1 To vnum, 1 To 2) As Double    ' coordinates after 2D affine transform
    
    
    sa = Sin(rx * PI / 180)
    ca = Cos(rx * PI / 180)
    sb = Sin(ry * PI / 180)
    cb = Cos(ry * PI / 180)
    sc = Sin(-rz * PI / 180)
    cc = Cos(-rz * PI / 180)
    
    T11 = cb * cc
    T21 = -sa * sb * cc - ca * sc
    T31 = -ca * sb * cc + sa * sc
    T12 = cb * sc
    T22 = -sa * sb * sc + ca * cc
    T32 = -ca * sb * sc - sa * cc
    T13 = sb
    T23 = sa * cb
    T33 = ca * cb
    
    hw = w / 2
    hh = h / 2
    
    ' prepare the array:
    ' move the coordinate origin to the center of the boundary, and
    ' set the boundary points in far half part.
    For i = 1 To vnum / 2
        v(i, 1) = v(i, 1) - l - hw
        v(i, 2) = v(i, 2) - t - hh
        v(i, 3) = 0
        v(i + vnum / 2, 1) = v(i, 1)
        v(i + vnum / 2, 2) = v(i, 2)
        v(i + vnum / 2, 3) = d
    Next
    ' rotate
    For i = 1 To vnum   '8
        p(i, 1) = T11 * v(i, 1) + T12 * v(i, 2) + T13 * v(i, 3)
        p(i, 2) = T21 * v(i, 1) + T22 * v(i, 2) + T23 * v(i, 3)
        p(i, 3) = T31 * v(i, 1) + T32 * v(i, 2) + T33 * v(i, 3)
    Next
        
    ' 2D affine transform
    If bPerspective Then
        
        Dim viewpx As Double    'view point
        Dim viewpy As Double
        Dim vo As Double
        
        Dim minx As Double, miny As Double, maxx As Double, maxy As Double
        minx = p(1, 1)
        maxx = minx
        miny = p(1, 2)
        maxy = miny
        
        ' find the boundry of rotated shape
        For i = 2 To (vnum / 2) '4
            If p(i, 1) < minx Then
                minx = p(i, 1)
            ElseIf p(i, 1) > maxx Then
                maxx = p(i, 1)
            End If
            If p(i, 2) < miny Then
                miny = p(i, 2)
            ElseIf p(i, 2) > maxy Then
                maxy = p(i, 2)
            End If
        Next
        
        viewpx = (maxx - minx) / 2
        viewpy = (maxy - miny) / 2
        
        vo = 100    ' offset from the shape corner to the viewpoint, a constant in PowerPoint
        
        Select Case ExtrusionDir
            Case MsoPresetExtrusionDirection.msoExtrusionBottomRight
                viewpx = -viewpx - vo
                viewpy = -viewpy - vo
            Case MsoPresetExtrusionDirection.msoExtrusionBottom
                viewpx = 0
                viewpy = -viewpy - vo
            Case MsoPresetExtrusionDirection.msoExtrusionBottomLeft
                viewpx = viewpx + vo
                viewpy = -viewpy - vo
            Case MsoPresetExtrusionDirection.msoExtrusionRight
                viewpx = -viewpx - vo
                viewpy = 0
            Case MsoPresetExtrusionDirection.msoExtrusionNone
                viewpx = 0
                viewpy = 0
            Case MsoPresetExtrusionDirection.msoExtrusionLeft
                viewpx = viewpx + vo
                viewpy = 0
            Case MsoPresetExtrusionDirection.msoExtrusionTopRight
                viewpx = -viewpx - vo
                viewpy = viewpy + vo
            Case MsoPresetExtrusionDirection.msoExtrusionTop
                viewpx = 0
                viewpy = viewpy + vo
            Case MsoPresetExtrusionDirection.msoExtrusionTopLeft
                viewpx = viewpx + vo
                viewpy = viewpy + vo
            Case Else
        End Select
    
        '   2D affine of 3D perspective transform
        '       / 1 0 0 0 \
        '       | 0 1 0 0 |
        '   T = | 0 0 0 r |
        '       \ 0 0 0 1 /
        '   e.g. ExtrusionDirectoryTopRight
        '       viewpoint is in positive z axis.
        '   top right corner of the shape A (Xa, Ya, Za, 1)  Xa=100, Ya=100, Za = 0
        '   remote top right corner A' (Xa', Ya', Za', 1)    Xa'=Xa, Ya'=Ya, Za'=d (depth)
        '   after the transform:  A -> B (Xb, Yb, Zb, 1)  Xb=Xa, Yb=Ya, Zb=Za=0
        '                         A'-> B'(Xb',Yb',Zb',1)  Xb'=Xb/(1+rd), Yb'=Yb/(1+rd), Zb'=0
        '               offsetX = Xb' - Xb = rd/(1+rd) * Xb
        '   as the real value (A'):1 (100, 100, 36, 1) -> (94, 94, 0, 1)
        '                     (A'):2 (100, 100, 9600, 1)->(7, 7, 0, 1)
        '                     ...
        '                   => r ~ 0.0014
        '                   => the vanishing point ~ (0, 0, -714)
        r = 0.0014
        
        For i = 1 To vnum '8
            f(i, 1) = (p(i, 1) + viewpx) / (1 + r * p(i, 3)) + l + hw - viewpx
            f(i, 2) = (p(i, 2) + viewpy) / (1 + r * p(i, 3)) + t + hh - viewpy
        Next
    Else
        'No perspective
        '       / 1  0  (0.5 * cos(a)) 0 \
        '       | 0  1 -(0.5 * sin(a)) 0 |
        '   T = | 0  0               0 0 |
        '       \ 0  0               0 1 /
        ' a = pi/4 or a = pi/2
        ' vp = 0.5 * sin(pi/4)
        ' vq = 0.5 * sin(pi/2)
        Dim vp As Double, vq As Double
        
        vp = 0.3535         ' 0.5 * sin PI/4
        vq = 0.5            ' 0.5 * sin PI/2
        
        Dim a1 As Double, a2 As Double
        
        Select Case ExtrusionDir
            Case MsoPresetExtrusionDirection.msoExtrusionBottomRight
                a1 = vp
                a2 = vp
            Case MsoPresetExtrusionDirection.msoExtrusionBottom
                a1 = 0
                a2 = vq
            Case MsoPresetExtrusionDirection.msoExtrusionBottomLeft
                a1 = -vp
                a2 = vp
            Case MsoPresetExtrusionDirection.msoExtrusionRight
                a1 = vq
                a2 = 0
            Case MsoPresetExtrusionDirection.msoExtrusionNone
                a1 = 0
                a2 = 0
            Case MsoPresetExtrusionDirection.msoExtrusionLeft
                a1 = -vq
                a2 = 0
            Case MsoPresetExtrusionDirection.msoExtrusionTopRight
                a1 = vp
                a2 = -vp
            Case MsoPresetExtrusionDirection.msoExtrusionTop
                a1 = 0
                a2 = -vq
            Case MsoPresetExtrusionDirection.msoExtrusionTopLeft
                a1 = -vp
                a2 = -vp
            Case Else
        End Select
        
        For i = 1 To vnum '8
            f(i, 1) = p(i, 1) + a1 * p(i, 3) + l + hw
            f(i, 2) = p(i, 2) + a2 * p(i, 3) + t + hh
        Next
    End If
    
    Dim lb As Double, tb As Double, rb As Double, bb As Double  ' boundary
    
    ' find position and size
    lb = f(1, 1)
    rb = f(1, 1)
    tb = f(1, 2)
    bb = f(1, 2)
    For i = 2 To vnum   '8
        If f(i, 1) > rb Then
            rb = f(i, 1)
        ElseIf f(i, 1) < lb Then
            lb = f(i, 1)
        End If
        If f(i, 2) > bb Then
            bb = f(i, 2)
        ElseIf f(i, 2) < tb Then
            tb = f(i, 2)
        End If
    Next
    
    X = lb
    Y = tb
    Width = rb - lb
    Height = bb - tb
    
    Erase v
    Erase p
    Erase f
'    With ActivePresentation.Slides(1).Shapes.AddShape(msoShapeRectangle, x, y, Width, Height)
'        .Line.ForeColor.RGB = RGB(255, 0, 0)
'        .Fill.Visible = msoFalse
'    End With

End Function

' insert the point list into a Bezier curve segment
'
' args:     sgPoint()             - 4 control points of a Bezier curve segment
'           lgNumOfInsertedPoints - byRef, return the number of generated points
' return:   AOFwb script of point list
Private Function InsertBezierPoints(sgPoint() As WBPoint, lgNumOfInsertedPoints As Long) As String
    Dim strScript           As String
    Dim nPointNum           As Long
    Dim i                   As Long
    Dim bzrPnts()           As WBPoint
    
    strScript = ""
    ' POINTDIST is the distance between two points
    ' POINTDIST = 2
    nPointNum = BzrPntNum(sgPoint, POINTDIST)
    ReDim bzrPnts(0 To nPointNum + 1) As WBPoint
    
    Call GenBzrPnts(sgPoint, bzrPnts, nPointNum)
    
    lgNumOfInsertedPoints = nPointNum + 1
    
    For i = 0 To nPointNum
'        strScript = strScript & vbLf & "<pt x=" & CLng(bzrPnts(i).x) _
'                    & " y=" & CLng(bzrPnts(i).y) & "></pt>"
        strScript = strScript & "{" & CLng(bzrPnts(i).X) _
                    & " " & CLng(bzrPnts(i).Y) & "} "
                    
        BPoints.Add CLng(bzrPnts(i).X), CLng(bzrPnts(i).Y)

    Next
    InsertBezierPoints = strScript
End Function

' inner function to generate Bezier curve
'
' return: the number of the points in one Bezier curve segment
Private Function BzrPntNum(p() As WBPoint, nPntDist As Long) As Long
        Dim maxx, maxy, minx, miny As Double
        Dim i As Long
        
        maxx = p(0).X: minx = p(0).X
        maxy = p(0).Y: miny = p(0).Y
        For i = 1 To 3
            If maxx < p(i).X Then
                maxx = p(i).X
            End If
            If maxy < p(i).Y Then
                maxy = p(i).Y
            End If
            If minx > p(i).X Then
                minx = p(i).X
            End If
            If miny > p(i).Y Then
                miny = p(i).Y
            End If
        Next
        maxx = maxx - minx: maxy = maxy - miny
        
        If maxx < maxy Then
            maxx = maxy
        End If
        BzrPntNum = maxx / nPntDist

End Function

' inner sub to generate Bezier curve
Private Sub GenBzrPnts(sgPoint() As WBPoint, bzrPnts() As WBPoint, pntNum As Long)
    'Dim MaxCtlPoints       As Long
    Dim u                  As Double
    Dim k                  As Long
    Dim pt                 As WBPoint
    
    'MaxCtlPoints = 12
    
    Dim bc(0 To MAXCTLPOINTS - 1)   As WBPoint
    
    Call BzrForm(4, sgPoint, bc)
    
    For k = 0 To pntNum
       pt = BzrCurve(4, bc, CDbl(k) / CDbl(pntNum))
       bzrPnts(k).X = pt.X
       bzrPnts(k).Y = pt.Y
    Next
    
End Sub

' inner sub to generate Bezier curve
Private Sub BzrForm(NumCtlPoints As Long, p() As WBPoint, c() As WBPoint)
    Dim k               As Long
    Dim n               As Double
    Dim choose          As Double
    
    n = NumCtlPoints - 1
    For k = 0 To n
        If k = 0 Then
            choose = 1
        ElseIf k = 1 Then
            choose = n
        Else
            choose = choose * (n - k + 1) / k
        End If
        
        c(k).X = p(k).X * choose
        c(k).Y = p(k).Y * choose
     Next

End Sub

' inner function to generate Bezier curve
Private Function BzrCurve(NumCtlPoints As Long, c() As WBPoint, t As Double) As WBPoint
    Dim k           As Long
    Dim n           As Long
    Dim t1, tt, u   As Double
    Dim pt          As WBPoint
    Dim b(0 To MAXCTLPOINTS - 1) As WBPoint
    
    n = NumCtlPoints - 1: u = t
    b(0).X = c(0).X
    b(0).Y = c(0).Y
    For k = 1 To n
        b(k).X = c(k).X * u
        b(k).Y = c(k).Y * u
        u = u * t
    Next
        
    pt.X = b(n).X:    pt.Y = b(n).Y
    t1 = 1 - t:         tt = t1
    
    k = n - 1
    Do While k >= 0
        pt.X = pt.X + b(k).X * tt
        pt.Y = pt.Y + b(k).Y * tt
        tt = tt * t1
        k = k - 1
    Loop
    BzrCurve = pt
    
End Function

Private Sub lerp(dest As aofNode, A As aofNode, b As aofNode, t As Double)
  dest.X = A.X + (b.X - A.X) * t
  dest.Y = A.Y + (b.Y - A.Y) * t
End Sub

Private Sub bezier(dest As aofNode, t As Double, A As aofNode, b As aofNode, c As aofNode, d As aofNode)
  Dim ab As aofNode, bc As aofNode, cd As aofNode, abbc As aofNode, bccd As aofNode
  
  Call lerp(ab, A, b, t)          ' point between a and b
  Call lerp(bc, b, c, t)          ' point between b and c
  Call lerp(cd, c, d, t)          ' point between c and d
  Call lerp(abbc, ab, bc, t)      ' point between ab and bc
  Call lerp(bccd, bc, cd, t)      ' point between bc and cd
  Call lerp(dest, abbc, bccd, t)  ' point on the bezier-curve
End Sub

Public Sub PerformTemplateTextbox(shp As Shape, Optional dateTime As String = "", _
                                                Optional footer As String = "", _
                                                Optional slideNum As String)
    Dim tmpShp As Shape
    Dim tmpTr  As TextRange
    Dim tmpTr2 As TextRange
    Dim tmpPara As ParagraphFormat
    
    Set tmpShp = GlobalTempSlide.Shapes.AddTextbox(msoTextOrientationHorizontal, shp.Left, shp.Top, shp.Width, shp.Height)
    
    SetReplaceText dateTime, footer, slideNum
    For Each tmpTr In shp.TextFrame.TextRange.Runs
        If ContainAutoTextField(tmpTr.Text) Then
            Set tmpTr2 = tmpShp.TextFrame.TextRange.InsertAfter(ReplaceAutoTextField(tmpTr.Text))
        Else
            Set tmpTr2 = tmpShp.TextFrame.TextRange.InsertAfter(tmpTr.Text)
        End If
        
        Set tmpPara = tmpTr.ParagraphFormat
        With tmpTr2.ParagraphFormat
            .Alignment = tmpPara.Alignment
            .BaseLineAlignment = tmpPara.BaseLineAlignment
            .HangingPunctuation = tmpPara.HangingPunctuation
            .LineRuleAfter = tmpPara.LineRuleAfter
            .LineRuleBefore = tmpPara.LineRuleBefore
            .LineRuleWithin = tmpPara.LineRuleWithin
            .SpaceAfter = tmpPara.SpaceAfter
            .SpaceBefore = tmpPara.SpaceBefore
            .SpaceWithin = tmpPara.SpaceWithin
            .TextDirection = tmpPara.TextDirection
            .WordWrap = tmpPara.WordWrap
        End With
            
        On Error Resume Next
        With tmpTr2.Font
            .BaselineOffset = tmpTr.Font.BaselineOffset
            .Bold = tmpTr.Font.Bold
            .Color.RGB = tmpTr.Font.Color.RGB
            .Italic = tmpTr.Font.Italic
            .Name = tmpTr.Font.Name   ' exception arises if tmpTr.font.name=""
            .NameAscii = tmpTr.Font.NameAscii
            .NameOther = tmpTr.Font.NameOther
            .NameFarEast = tmpTr.Font.NameFarEast
            .Size = tmpTr.Font.Size
            .Subscript = tmpTr.Font.Subscript
            .Superscript = tmpTr.Font.Superscript
            .Underline = tmpTr.Font.Underline
        End With
        On Error GoTo 0
    Next
    
    With tmpShp.TextFrame
        .AutoSize = shp.TextFrame.AutoSize
        .MarginBottom = shp.TextFrame.MarginBottom
        .MarginLeft = shp.TextFrame.MarginLeft
        .MarginRight = shp.TextFrame.MarginRight
        .MarginTop = shp.TextFrame.MarginTop
        .Orientation = shp.TextFrame.Orientation
        .WordWrap = shp.TextFrame.WordWrap
    End With
    
    Perform tmpShp
    
    tmpShp.Delete
    Set tmpShp = Nothing
End Sub

Private Function ContainAutoTextField(txt As String) As Boolean
    On Error Resume Next
    Dim pos As Long
    pos = InStr(1, txt, "*", vbTextCompare)
    ContainAutoTextField = IIf(pos > 0, True, False)
End Function

Public Sub SetSlideAsImage(sld As Slide)
    ShapeType = aofShapeTypeImage
    
    If Not CvtOpt.WithImageSize Then
        Width = 0
        Height = 0
    End If
    
    On Error GoTo ExpError:
    With CvtOpt
        If OutputGIF Or ThreeDAsGIF Then
            ImageFileName = .ImgFileNamePrefix & "_s" _
                        & CurPageNumber & "p" & Position & ".gif"
            'Call shp.Export(.WBFilePath & ImageFileName, ppShapeFormatGIF)
            sld.Export .WBFilePath & ImageFileName, "gif"
        Else
            ImageFileName = .ImgFileNamePrefix & "_s" _
                        & CurPageNumber & "p" & Position & .ExpImageSuffix
            'Call shp.Export(.WBFilePath & ImageFileName, ppShapeFormatGIF)
            sld.Export .WBFilePath & ImageFileName, Mid(.ExpImageSuffix, 2, 3)
        End If
    End With
    Exit Sub
ExpError:
    If Err.Number = -2147467259 Then
        CvtOpt.FailInfo = Err.Number 'Err.Description
        'MsgBox Err.Description
        CvtOpt.Failed = True
    End If
    Resume Next

End Sub

Private Sub Class_Initialize()
    Position = CurrentPosition
    
    ' many aofShapes contain 2 objects: outline and filled
    CurrentPosition = CurrentPosition + 2
    
    FillColor = "none"
    LineColor = "none"
    ArrowShape = "8 10 4"
    FootersHeadersType = aofNoFooterHeader
    
    LineStyle = " "
    
    OutputGIF = False
    'OutputGIF = True
    
    ThreeDAsGIF = False
    'ThreeDAsGIF = True
    
    ZPosition = 0
        
    Set BPoints = New aofPoints
    
    bConvertToPNG = True
    ' old: by default, the transparent part should be cut away
    iCutTransOff = 0

    bAppearInShadow = True
    ShpIsUnsupported = False
End Sub

Private Sub Class_Terminate()
    Dim i As Long
    On Error Resume Next
    Set BPoints = Nothing
    If ContainText Then
        Set TextInShape = Nothing
    End If
    If HasGroupItem Then
        For i = 1 To GroupItemNum
            Set GroupItems(i) = Nothing
        Next i
    End If
    If HasTextItem Then
        For i = 1 To TextItemNum
            Set TextItems(i) = Nothing
        Next i
    End If
    Erase Vert
End Sub
