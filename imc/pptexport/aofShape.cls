VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "aofShape"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Option Explicit

#Const COMPILE_VERSION = 2007

Public m_bVisible           As Boolean

Public x                As Single
Public y                As Single
Public width            As Single
Public height           As Single

Public HypertextAddress As String
Public CurrentDirectory As String
Public InternLink       As String
Public ObjectLinkIds    As String
Public ObjectId         As Long


' determine if there are animation effects within the shape
' normally, only the text shape has such kind of sub-animation.
Public m_bHasSubAnim    As Boolean


Public HasTextItem      As Boolean       ' the text shape contains textitem (for text shape)
Private TextItems()     As aofTextItem
Public TextItemNum      As Long

' use these two properties to determin if there is a bullet in front of one text line
Public TextIndentLevel  As Long
Public ParaIndex        As Long

Public HasVertices      As Boolean       ' used by polys and lines
Private Vert()          As aofNode       ' control points of polyline or line
Public VertNum          As Long          ' number of control points

Public PointsString     As String        ' store the string of points (generated by control points)
Public PointNum         As Long          ' number of points on the Bezier curve
Public IsClosedPolyline As Boolean

' group shape setting
Public HasGroupItem     As Boolean
Private GroupItems()    As aofShape
Public GroupItemNum     As Long

' Outline rectangle for images
Private OutlineRect     As aofShape
Private HasOutline      As Boolean
' New shadow group 18.02.03
Public HasShadowItem    As Boolean
Private ShadowItems()   As aofShape
Public ShadowItemNum    As Long

'Public ShadowFillColor As String    ' fill color of shadow
'Public ShadowLineColor As String    ' line color of shadow

Public ContainText      As Boolean       ' the shape contains text (especially for Autoshapes)
Public TextInShape      As aofShape

' line setting and fill setting
Public m_lecDrawStyle   As LecDrawStyle
Public LineStyle        As String
Public LineWidth        As Long
Public arrowStyle       As String
Public arrowConfig      As String

Public m_szFillColor     As String
Public m_szLineColor     As String

' Z-Order position of the shape
Public ZPosition       As Long

' only for image shape
Public ImageFileName    As String        ' image file name
Public DefaultPath      As String        ' default path of image file

' the image position offset of the objects with 3D effect
Private ThreeDOffsetX   As Long
Private ThreeDOffsetY   As Long

' especially for the rectangle with text and was exported as an image.
Public ForceToNoText    As Boolean

' the string to replace <Datum/Uhrzeit>, <Fusszeile> and <Nr.>
Private StrDate         As String
Private StrFooter       As String
Private StrSlideNumber  As String

Public FootersHeadersType   As Long

Public HasTextShadow    As Boolean
Public ShadowOffX       As Single
Public ShadowOffY       As Single
Public ShadowColor      As String

Private m_bExportAutoformAsImage  As Boolean

'Private BPoints     As aofPoints
Public BPoints     As aofPoints

' true means the wmf images should be converted into PNG.
Public m_bConvertToPNG              As Boolean

' 1 means cut the trans-part off, 0 not.
' Only used in PowerPoint 2000
Public m_iCutTransOff               As Integer

Private v() As Double
Private p() As Double
Private f() As Double

Private m_lecShapeType              As LecShapeType
Private m_lecTextShapeType          As LecTextShapeType

Private m_bIsAnimatedText           As Boolean
Private m_bAnimInReverse            As Boolean

Private m_lImageId                  As Long     ' serial ID of the exported images

Private m_bIsOLEObject              As Boolean

Private m_bShpHas3D                 As Boolean
Private m_bShpHasText               As Boolean
Private m_bShpHasConvertableText    As Boolean
Private m_bShpHasShadow             As Boolean
Private m_bShpIsSolidFilled         As Boolean
Private m_bShpIsComplex             As Boolean  ' (17.02.03) to identify whether it's a complex Autoshape.
Private m_bShpIsUnsupported         As Boolean  ' Unsupported shape should be exported as image.

Private m_bIsPlaceholder            As Boolean


''''''''''''''''''''''''''
' Constructor/Destructor '
''''''''''''''''''''''''''

Private Sub Class_Initialize()

    ' many aofShapes contain 2 objects: outline and filled
    g_lCurrentIndex = g_lCurrentIndex + 2
    
    ' The global index is used to create image names
    m_lImageId = g_lCurrentIndex
    
    m_lecShapeType = LEC_SHAPETYPE_NONE
    m_bVisible = True
    
    x = 0
    y = 0
    width = 0
    height = 0
    
    m_bHasSubAnim = False
    m_bIsAnimatedText = False
    
    m_szFillColor = "none"
    m_szLineColor = "none"
    FootersHeadersType = LEC_FOOTERHEADER_NONE

    LineStyle = " "
    
    ZPosition = 0

    Set BPoints = New aofPoints

    ' by default, the transparent part should be cut away
    m_iCutTransOff = 1
    
    m_bIsOLEObject = False
    m_bIsPlaceholder = False
    
    m_bExportAutoformAsImage = False
    
    m_bShpIsUnsupported = False
    m_bShpHas3D = False
    m_bShpHasShadow = False
    m_bShpHasText = False
    m_bShpIsSolidFilled = False
    m_bShpIsComplex = False
    m_bShpHasConvertableText = False

    m_bConvertToPNG = False
    
End Sub

Private Sub Class_Terminate()
    Dim i As Long
    On Error Resume Next
    Set BPoints = Nothing
    If ContainText Then
        Set TextInShape = Nothing
    End If
    If HasGroupItem Then
        For i = 1 To GroupItemNum
            Set GroupItems(i) = Nothing
        Next i
    End If
    If HasTextItem Then
        For i = 1 To TextItemNum
            Set TextItems(i) = Nothing
        Next i
    End If
    Erase Vert
End Sub


'''''''''''''''''''''''''''''''''''
' Public functions and procedures '
'''''''''''''''''''''''''''''''''''

' implement the conversion
'
' +++ Some known rules (according to experiments, no official documents) +++
'
' 0. Shadow and 3D are mutually exclusive.
' 1. Tables have no shadow/3D effects
' 2. Some OLE objects have shadow effects 1,2,5,6,13,14,17,18, but no 3D.
' 3. Charts have no 3D effects, have shadow effects 1,2,5,6,13,14,17,18.
' 4. Complex Autoshapes (Can, Cube, Bevel, etc.) HAVE shaodw effects now(?!).
'    As I knew before, these kinds of Autoshape had no shadow effects.
' 5. Textbox without outline and fillcolor has no 3D effects, has shadow 1,2,5,
'    6,13,14,17,18.
' 6. Single lines, single brackets, single braces, connectors and arcs can only
'    have shadow 1,2,5,6,13,14,17,18.
' 7. Polylines (opened or closed), double brackets and double braces have all
'    shadow effects.
' 8. Pointed callouts, rectangle callout, round corner rectangle callout, oval
'    callout and cloudy callout can only have shaodw 1,2,5,6,13,14,17,18.
' 9. Images can also have shaodws, only 1,2,5,6,13,14,17,18.
' 10.Line may have Shadow 1,2,5,6,13,14,17,18. Line donot have Text content.
' 11.Text may ONLY have shadow 1,2,5,6,14.
'
' +++ Known bugs (TODO list) +++
'
' 1. If the text's bounding box exceeds its host autoshape's territory, and,
'    this shape (rotated) should be exported as image, the image size is no
'    longer the bounding box of the autoshape. This should be fixed in future.
'
Public Sub Perform(sld As Slide, shp As Shape, Optional paragraphDescription As String = "")

    On Error Resume Next
    
    ' A visible shape won't be converted. Property "Invisible" is marked as
    ' True, this object will not be written into lsd file.
    If shp.Visible = msoFalse Then
        m_bVisible = False
        Exit Sub
    End If

    m_bIsAnimatedText = IsAnimatedText(paragraphDescription)

    ' set correct type for placeholder objects
    If shp.Type = msoPlaceholder Then
        If shp.PlaceholderFormat.Type = ppPlaceholderDate Then
            FootersHeadersType = LEC_FOOTERHEADER_DATETIME
        ElseIf shp.PlaceholderFormat.Type = ppPlaceholderFooter Then
            FootersHeadersType = LEC_FOOTERHEADER_FOOTER
        ElseIf shp.PlaceholderFormat.Type = ppPlaceholderSlideNumber Then
            FootersHeadersType = LEC_FOOTERHEADER_SLIDENUMBER
        End If
    End If
        
    CheckIfShapeIsSupported shp, sld.slideNumber
        
    SearchForHyperlink shp
    
    ' In PowerPoint 2007 there is a new member "table" if the shape is a table object.
    ' In this case we perform this shape without any other check.
    If shp.Type = msoTable And g_lApplicationVersion = 2007 Then
        PerformTable sld, shp
        Exit Sub
    End If
    
    ' As we now know, a group can have 3D or shadow effect.
    ' Fortunately, the 3D/shadow effect is applied to each group item.
    ' That means, it is safe to convert group items without considering the
    ' effect on the group itself. First, the group will be ungrouped, then
    ' each item will be converted individually (following the normal flow).
    If shp.Type <> msoGroup Then
    
        SetShapeProperties shp
        
        If ShapeHasToBeSavedAsImage(sld, shp, paragraphDescription) Then
            Exit Sub
        End If
       
    End If ' shp.Type <> msoGroup

    ' Normal shape conversion procedure.
    ' Now the shapes obey following rules:
    ' 1) No 3D or Shadow effect.
    ' 2) No unconvertable text.
    ' 3) No special fill mode.
    ' They may:
    ' 1) With convertable text.
    ' 2) Rotated but no text.
    Select Case shp.Type
        Case MsoShapeType.msoTextBox
            PerformTextBox sld, shp, m_bShpHasConvertableText, paragraphDescription
        Case MsoShapeType.msoGroup
            PerformGroup sld, shp
        Case MsoShapeType.msoLine
            PerformLine shp
        Case MsoShapeType.msoPlaceholder
            Select Case shp.PlaceholderFormat.Type
                Case PpPlaceholderType.ppPlaceholderTitle, _
                    PpPlaceholderType.ppPlaceholderBody, _
                    PpPlaceholderType.ppPlaceholderCenterTitle, _
                    PpPlaceholderType.ppPlaceholderSubtitle, _
                    PpPlaceholderType.ppPlaceholderFooter, _
                    PpPlaceholderType.ppPlaceholderHeader, _
                    PpPlaceholderType.ppPlaceholderSlideNumber, _
                    PpPlaceholderType.ppPlaceholderDate, _
                    PpPlaceholderType.ppPlaceholderObject
                    
                    'If the placeholder contains an object and that object is not text, then
                    'it has to be saved as image
                    Dim bPerfImage As Boolean: bPerfImage = False
                   
                    If shp.PlaceholderFormat.Type = ppPlaceholderObject Then
                        If g_lApplicationVersion = 2007 And shp.HasTextFrame = msoFalse Then
                            m_bConvertToPNG = True
                            m_iCutTransOff = 0
                            PerformAsImage shp
                            bPerfImage = True
                        End If
                    End If
                    
            
#If COMPILE_VERSION = 2007 Then
                    If shp.PlaceholderFormat.ContainedType = msoAutoShape And _
                       shp.AutoShapeType <> msoShapeMixed Then
#Else
                    If shp.AutoShapeType <> msoShapeMixed Then
#End If
                        PerformTextBox sld, shp, m_bShpHasConvertableText, paragraphDescription
                        If shp.PlaceholderFormat.Type = ppPlaceholderDate Then
                            FootersHeadersType = LEC_FOOTERHEADER_DATETIME
                        ElseIf shp.PlaceholderFormat.Type = ppPlaceholderFooter Then
                            FootersHeadersType = LEC_FOOTERHEADER_FOOTER
                        ElseIf shp.PlaceholderFormat.Type = ppPlaceholderSlideNumber Then
                            FootersHeadersType = LEC_FOOTERHEADER_SLIDENUMBER
                        End If
                    Else
                        If Not bPerfImage Then
                            m_bConvertToPNG = True
                            m_iCutTransOff = 0
                            PerformAsImage shp
                        End If
                    End If
                    
                Case PpPlaceholderType.ppPlaceholderBitmap
                    m_bConvertToPNG = True
                    m_iCutTransOff = 0
                    PerformAsImage shp
#If COMPILE_VERSION = 2007 Then
                Case PpPlaceholderType.ppPlaceholderPicture
                    m_bConvertToPNG = True
                    m_iCutTransOff = 0
                    PerformAsImage shp
#End If
                Case Else
                    m_bConvertToPNG = True
                    m_iCutTransOff = 0
                    PerformAsImage shp
            End Select
        Case MsoShapeType.msoAutoShape
                If shp.AutoShapeType = msoShapeOval Then
                    PerformOval sld, shp
                Else
                    PerformAutoshape sld, shp, paragraphDescription
                End If
        Case MsoShapeType.msoFreeform
            PerformPolygon sld, shp
        Case MsoShapeType.msoLinkedPicture, msoPicture
            m_bConvertToPNG = True
            m_iCutTransOff = 0
            PerformAsImage shp
        Case MsoShapeType.msoTable
            If g_lApplicationVersion = 2007 Then
                PerformTable sld, shp
            Else
                PerformGroup sld, shp
            End If
        Case MsoShapeType.msoCallout
            PerformCallout sld, shp
        Case MsoShapeType.msoEmbeddedOLEObject, MsoShapeType.msoLinkedOLEObject
            PerformOLEObject shp
        Case Else
            PerformAsImage shp
    End Select
    

End Sub

Public Function GetShapeType() As LecShapeType
    GetShapeType = m_lecShapeType
End Function

Public Sub SetShapeType(LecShapeType As LecShapeType)
    m_lecShapeType = LecShapeType
End Sub

Public Sub GetZPosition(shp As Shape)
    On Error Resume Next
    ZPosition = shp.ZOrderPosition
End Sub

Public Sub SetZPosition(zp As Long)
    Dim i As Long
    On Error GoTo Finish:
    ZPosition = zp
    If HasGroupItem Then
        For i = 1 To GroupItemNum
            GroupItems(i).SetZPosition zp
        Next
    End If
    If HasShadowItem Then
        For i = 1 To ShadowItemNum
            ShadowItems(i).SetZPosition zp
        Next
    End If
    If ContainText Then
        TextInShape.SetZPosition zp
    End If
    If HasOutline Then
        OutlineRect.SetZPosition zp
    End If
    
Finish:
End Sub

Public Sub SetReplaceText(dt As String, ftr As String, pn As String)
    StrDate = dt
    StrFooter = ftr
    StrSlideNumber = pn

    On Error Resume Next
    If HasGroupItem Then
        Dim i As Long
        For i = 1 To GroupItemNum
            GroupItems(i).SetReplaceText dt, ftr, pn
        Next
    End If
    
    If ContainText Then
        TextInShape.SetReplaceText dt, ftr, pn
    End If
End Sub

Public Function GetGroupItem(idx As Long) As aofShape
    Set GetGroupItem = GroupItems(idx)
End Function

Public Sub ConvertToPNG()
    Dim wname As String, pname As String
    Dim iRet As Integer

    ' Do not convert images to PNG in PowerPoint 2002 and 2003
    If g_lApplicationVersion <> 2000 Then
        Exit Sub
    End If

    If Not m_bConvertToPNG Or ImageFileName = "" Then
        Exit Sub
    End If

    On Error GoTo ConvertToPNGError
    If StrComp(Right(ImageFileName, 4), ".wmf", vbTextCompare) = 0 Then
        wname = g_conversionOptions.WBFilePath & Me.ImageFileName
        pname = Left(ImageFileName, Len(ImageFileName) - 4) & ".png"
        Dim szPath As String: szPath = g_conversionOptions.WBFilePath & pname
        iRet = ConvertWMFtoPNG(StrPtr(wname), StrPtr(szPath), m_iCutTransOff)
        If iRet = 1 Then
            ' conversion success. delete the wmf file
            ImageFileName = pname
            Kill wname
        End If
    End If
    Exit Sub
ConvertToPNGError:
    Exit Sub
End Sub

Public Sub SetBackgroundAsRect_2007(shp As Shape)

    m_lecShapeType = LEC_SHAPETYPE_RECTANGLE
    x = 0
    y = 0
    width = g_lSlideWidth
    height = g_lSlideHeight

    
    If shp.Fill.Visible = msoTrue Then
        m_lecDrawStyle = LEC_DRAWSTYLE_FILLED
        SetFillAttributes shp
        m_szLineColor = m_szFillColor
        'If shp.Fill.Type <> msoFillBackground Or shp.Fill.Type <> msoFillSolid Then
    End If

End Sub

Public Sub SetBackgroundAsImage_2007(sld As Slide, szTemplateName As String, shp As Shape)

#If COMPILE_VERSION = 2007 Then

    m_lecShapeType = LEC_SHAPETYPE_IMAGE
    HasOutline = False
 
    x = 0
    y = 0
    width = g_lSlideWidth
    height = g_lSlideHeight
    
    Dim tmpSlide As Slide
    
    Dim bSlideCreated As Boolean: bSlideCreated = False
    Dim bDisplayMasterShapes As Boolean: bDisplayMasterShapes = msoFalse
    If Len(szTemplateName) > 0 Then
        If sld.CustomLayout.Name = szTemplateName Then
            Dim pptLayout As CustomLayout
            Set pptLayout = sld.CustomLayout
            If pptLayout.DisplayMasterShapes Then
                bDisplayMasterShapes = msoTrue
                pptLayout.DisplayMasterShapes = msoFalse
            End If
            Set tmpSlide = g_currentPresentation.Slides.AddSlide(g_currentPresentation.Slides.Count + 1, pptLayout)
            bSlideCreated = True
        End If
    End If
        
    If Not bSlideCreated And szTemplateName <> "" Then
        Set tmpSlide = sld.Duplicate(1)
        tmpSlide.FollowMasterBackground = msoTrue
        tmpSlide.DisplayMasterShapes = msoFalse
        tmpSlide.layout = ppLayoutBlank
    Else
        If Not bSlideCreated And szTemplateName = "" Then
            Set tmpSlide = sld.Duplicate(1)
        End If
    End If
    
    Dim i As Long
    Dim delShape As Shape
    For i = 1 To tmpSlide.Shapes.Count
        tmpSlide.Shapes(i).Visible = msoFalse
    Next

    Dim visibleObjects() As Boolean
    If tmpSlide.CustomLayout.Shapes.Count > 0 Then
        ReDim visibleObjects(1 To tmpSlide.CustomLayout.Shapes.Count) As Boolean
        For i = 1 To tmpSlide.CustomLayout.Shapes.Count
            If tmpSlide.CustomLayout.Shapes(i).Visible Then
                visibleObjects(i) = True
            Else
                visibleObjects(i) = False
            End If
            tmpSlide.CustomLayout.Shapes(i).Visible = msoFalse
        Next
    End If

    On Error GoTo ExpError:
    With g_conversionOptions
    
        Dim szImagePrefix As String
        szImagePrefix = CreateImagePrefix()
        
        Dim result As Boolean: result = False
            
        ImageFileName = szImagePrefix & .ExpImageSuffix
        Call tmpSlide.Export(.WBFilePath & ImageFileName, "PNG")
        result = RewriteImage(.WBFilePath, ImageFileName, szImagePrefix, .ExpImageSuffix)
           
    End With

    If tmpSlide.CustomLayout.Shapes.Count > 0 Then
        For i = 1 To tmpSlide.CustomLayout.Shapes.Count
            If visibleObjects(i) Then
                tmpSlide.CustomLayout.Shapes(i).Visible = msoTrue
            End If
        Next
        Erase visibleObjects
    End If
    
    If bDisplayMasterShapes Then
        sld.CustomLayout.DisplayMasterShapes = msoTrue
    End If
    
    tmpSlide.Delete
    
    Exit Sub
    
ExpError:
    If Err.Number = -2147467259 Then
        g_conversionOptions.FailInfo = Err.Number 'Err.Description
        'MsgBox Err.Description
        'g_conversionOptions.FailMsg = Err.Description
        g_conversionOptions.FailMsg = g_szMsgOverwriteImage & g_conversionOptions.WBFilePath & ImageFileName
        g_conversionOptions.Failed = True
    End If
    Resume Next
    
#End If
    
End Sub


Public Function Script() As String
    Dim strScript       As String
    Dim i               As Long
    Dim rStr    As String

    If Not m_bVisible Then
        Script = ""
        Exit Function
    End If

    If m_bIsAnimatedText Then
        If m_lecShapeType = LEC_SHAPETYPE_TEXT Then
            IncIndent
            If Not g_conversionOptions.NoGroup And TextItemNum > 1 Then
                strScript = NewLine() & "<GROUP>" '  name=""" & NameForAnim & """>"
                IncIndent
            End If
            For i = 1 To TextItemNum
                With TextItems(i)
                    'Dim rStr    As String
                    If g_shapeIsInTemplate Then
                        rStr = ReplaceAutoTextField(.text)
                        If rStr <> .text Then
                            .width = 0
                        End If
                    Else
                        rStr = .text
                    End If
                    .length = Len(rStr)

                    If .length > 0 Then
                        strScript = strScript & NewLine() & "<TEXT x=""" & ConvertDoubleToString(.x) _
                                & """ y=""" & ConvertDoubleToString(y + .offY) _
                                & """ width=""" & ConvertDoubleToString(.width) _
                                & """ color=""" & .FontColor _
                                & """ size=""" & .FontSize _
                                & """ family=""" & .Family _
                                & """ weight=""" & .Weight _
                                & """ slant=""" & .Slant _
                                & """ style=""" & .Style _
                                & """ position=""" & .Position _
                                & """ length=""" & Len(rStr) _
                                & """ ZPosition=""" & ZPosition _
                                & MakeHypertextString(.HypertextAddress, .InternLink, .CurrentDirectory, .ObjectLinkIds, .ObjectId) _
                                & """ linkcolor=""" & .LinkColor _
                                & """>" _
                                & NewLine() & "  """ & rStr & """" _
                                & NewLine() & "</TEXT>"
                    End If
                End With
            Next
            If Not g_conversionOptions.NoGroup And TextItemNum > 1 Then
                DecIndent
                strScript = strScript & NewLine() & "</GROUP>"
            End If
            DecIndent
        ElseIf m_lecShapeType = LEC_SHAPETYPE_TEXTGROUP Then
                IncIndent
                If Not g_conversionOptions.NoGroup Then
                    strScript = NewLine() & "<GROUP>" '  name=""" & NameForAnim & """>"
                    IncIndent
                End If
                
                For i = 1 To GroupItemNum
                    DecIndent
                    If GroupItems(i).m_bVisible Then
                        strScript = strScript & GroupItems(i).Script()
                    End If
                    IncIndent
                Next
                If Not g_conversionOptions.NoGroup Then
                    DecIndent
                    strScript = strScript & NewLine() & "</GROUP>"
                End If
                DecIndent
        End If
        If HasTextShadow Then
'        IncIndent
            If Not g_conversionOptions.NoGroup And TextItemNum > 1 Then
                strScript = NewLine() & "<GROUP>" '  name=""" & NameForAnim & """>"
                IncIndent
            End If
            For i = 1 To TextItemNum
                With TextItems(i)
                    If g_shapeIsInTemplate Then
                        rStr = ReplaceAutoTextField(.text)
                        If rStr <> .text Then
                            .width = 0
                        End If
                    Else
                        rStr = .text
                    End If
                    .length = Len(rStr)
    
                    If .length > 0 Then
                        ' add text shadow
                        strScript = strScript & NewLine() & "<TEXT x=""" & ConvertDoubleToString(.x + ShadowOffX) _
                                & """ y=""" & ConvertDoubleToString(y + .offY + ShadowOffY) _
                                & """ width=""" & ConvertDoubleToString(.width) _
                                & """ color=""" & ShadowColor _
                                & """ size=""" & .FontSize _
                                & """ family=""" & .Family _
                                & """ weight=""" & .Weight _
                                & """ slant=""" & .Slant _
                                & """ style=""" & .Style _
                                & """ position=""" & .Position _
                                & """ length=""" & Len(rStr) _
                                & """ ZPosition=""" & ZPosition _
                                & """ linkcolor=""" & .LinkColor _
                                & """>" _
                                & NewLine() & "  """ & rStr & """" _
                                & NewLine() & "</TEXT>"
                    End If
                End With
            Next
            If Not g_conversionOptions.NoGroup And TextItemNum > 1 Then
                DecIndent
                strScript = strScript & NewLine() & "</GROUP>"
            End If
    '        DecIndent
        End If
        
        If ContainText Then
            strScript = strScript & TextInShape.Script()
        End If
    Else
        
        ' Shadows
        If HasShadowItem Then
            If Not g_conversionOptions.NoGroup Then
                IncIndent
                strScript = NewLine() & "<GROUP>" '  name=""" & NameForAnim & """>"
            End If
            For i = 1 To ShadowItemNum
                If ShadowItems(i).m_bVisible Then
                    strScript = strScript & ShadowItems(i).Script()
                End If
            Next
            If Not g_conversionOptions.NoGroup Then
                strScript = strScript & NewLine() & "</GROUP>"
                DecIndent
            End If
        End If
    
        ' add text shadow
        If ContainText Then
            strScript = strScript & TextInShape.ScriptTextShadow()
        End If
    
        Dim arrowString As String
        Select Case m_lecShapeType
            Case LEC_SHAPETYPE_LINE
                IncIndent
                strScript = NewLine() & "<LINE x=""" & ConvertDoubleToString(x) _
                            & """ y=""" & ConvertDoubleToString(y) _
                            & """ width=""" & ConvertDoubleToString(width) _
                            & """ height=""" & ConvertDoubleToString(height) _
                            & """ color=""" & m_szLineColor _
                            & """ lineWidth=""" & LineWidth _
                            & """ lineStyle=""" & LineStyle _
                            & MakeArrowString(arrowStyle, arrowConfig) _
                            & """ ZPosition=""" & ZPosition _
                            & MakeHypertextString(HypertextAddress, InternLink, CurrentDirectory, ObjectLinkIds, ObjectId) _
                            & """></LINE>"
    '                        & """ name=""" & NameForAnim _

                DecIndent
    
            Case LEC_SHAPETYPE_GROUP
                If Not g_conversionOptions.NoGroup Then
                    IncIndent
                    strScript = NewLine() & "<GROUP>" '  name=""" & NameForAnim & """>"
                End If
    
                For i = 1 To GroupItemNum
                    If GroupItems(i).m_bVisible Then
                        strScript = strScript & GroupItems(i).Script()
                    End If
                Next
    
                If Not g_conversionOptions.NoGroup Then
                    strScript = strScript & NewLine() & "</GROUP>"
                    DecIndent
                End If
    
            Case LEC_SHAPETYPE_TEXT
                IncIndent
                If Not g_conversionOptions.NoGroup And TextItemNum > 1 Then
                    strScript = NewLine() & "<GROUP>" '  name=""" & NameForAnim & """>"
                    IncIndent
                End If
                For i = 1 To TextItemNum
                    If Not TextItems(i) Is Nothing Then
                        With TextItems(i)
                            'Dim rStr    As String
                            If g_shapeIsInTemplate Then
                                rStr = ReplaceAutoTextField(.text)
                                If rStr <> .text Then
                                    .width = 0
                                End If
                            Else
                                rStr = .text
                            End If
                            .length = Len(rStr)
        
                            If .length > 0 Then
        ' --- moved
        '                        If HasTextShadow Then       ' add text shadow
        '                            strScript = strScript & NewLine() & "<TEXT x=""" & CLng(.x + ShadowOffX) _
        '                                    & """ y=""" & CLng(y + .OffY + ShadowOffY) _
        '                                    & """ width=""" & .Width _
        '                                    & """ color=""" & ShadowColor _
        '                                    & """ size=""" & .FontSize _
        '                                    & """ family=""" & .Family _
        '                                    & """ weight=""" & .Weight _
        '                                    & """ slant=""" & .Slant _
        '                                    & """ position=""" & .Position _
        '                                    & """ length=""" & Len(rStr) _
        '                                    & """ ZPosition=""" & ZPosition _
        '                                    & """>" _
        '                                    & NewLine() & "  """ & rStr & """" _
        '                                    & NewLine() & "</TEXT>"
        '                        End If
        
                                strScript = strScript & NewLine() & "<TEXT x=""" & ConvertDoubleToString(.x) _
                                        & """ y=""" & ConvertDoubleToString(y + .offY) _
                                        & """ width=""" & ConvertDoubleToString(.width) _
                                        & """ color=""" & .FontColor _
                                        & """ size=""" & .FontSize _
                                        & """ family=""" & .Family _
                                        & """ weight=""" & .Weight _
                                        & """ slant=""" & .Slant _
                                        & """ style=""" & .Style _
                                        & """ position=""" & .Position _
                                        & """ length=""" & Len(rStr) _
                                        & """ ZPosition=""" & ZPosition _
                                        & MakeHypertextString(.HypertextAddress, .InternLink, .CurrentDirectory, .ObjectLinkIds, .ObjectId) _
                                        & """ linkcolor=""" & .LinkColor _
                                        & """>" _
                                        & NewLine() & "  """ & rStr & """" _
                                        & NewLine() & "</TEXT>"
                            End If
                        End With
                    End If
                Next
                If Not g_conversionOptions.NoGroup And TextItemNum > 1 Then
                    DecIndent
                    strScript = strScript & NewLine() & "</GROUP>"
                End If
                DecIndent
            Case LEC_SHAPETYPE_RECTANGLE
                If m_lecDrawStyle <> LEC_DRAWSTYLE_NONE Then
                    IncIndent
    
                    If m_lecDrawStyle <> LEC_DRAWSTYLE_TRANSPARENT Then
                        strScript = NewLine() & "<RECTANGLE x=""" & ConvertDoubleToString(x) _
                                    & """ y=""" & ConvertDoubleToString(y) _
                                    & """ width=""" & ConvertDoubleToString(width) _
                                    & """ height=""" & ConvertDoubleToString(height) _
                                    & """ color=""" & m_szLineColor _
                                    & """ fillColor=""" & m_szFillColor _
                                    & """ lineWidth=""" & LineWidth _
                                    & """ lineStyle=""" & LineStyle _
                                    & """ ZPosition=""" & ZPosition _
                                    & MakeHypertextString(HypertextAddress, InternLink, CurrentDirectory, ObjectLinkIds, ObjectId) _
                                    & """></RECTANGLE>"
                    Else
                        strScript = NewLine() & "<RECTANGLE x=""" & ConvertDoubleToString(x) _
                                    & """ y=""" & ConvertDoubleToString(y) _
                                    & """ width=""" & ConvertDoubleToString(width) _
                                    & """ height=""" & ConvertDoubleToString(height) _
                                    & """ color=""" & "#01ffffff" _
                                    & """ fillColor=""" & "#01ffffff" _
                                    & """ lineWidth=""" & LineWidth _
                                    & """ lineStyle=""" & LineStyle _
                                    & """ ZPosition=""" & ZPosition _
                                    & MakeHypertextString(HypertextAddress, InternLink, CurrentDirectory, ObjectLinkIds, ObjectId) _
                                    & """></RECTANGLE>"
                    End If
    
                    DecIndent
               End If
            Case LEC_SHAPETYPE_POLYGON
                ' this is a polygon without outline. so the "color" is set to "fillColor"
                IncIndent
    
                If m_szFillColor <> "none" Or m_szLineColor <> "none" Or m_lecDrawStyle = LEC_DRAWSTYLE_TRANSPARENT Then
                    If m_lecDrawStyle = LEC_DRAWSTYLE_FILLEDOUTLINE And Not g_conversionOptions.NoGroup Then
                        strScript = NewLine() & "<GROUP>" '  name=""" & NameForAnim & """>"
                        IncIndent
                    End If
    
                    If m_lecDrawStyle = LEC_DRAWSTYLE_FILLED Then
                        strScript = strScript & NewLine() & "<POLYGON x=""" & ConvertDoubleToString(x) _
                                    & """ y=""" & ConvertDoubleToString(y) _
                                    & """ width=""" & ConvertDoubleToString(width) _
                                    & """ height=""" & ConvertDoubleToString(height) _
                                    & """ color=""" & m_szLineColor _
                                    & """ fillColor=""" & m_szFillColor _
                                    & """ lineWidth=""" & LineWidth _
                                    & """ lineStyle=""" & LineStyle _
                                    & """ length=""" & Len(PointsString) _
                                    & """ ZPosition=""" & ZPosition _
                                    & MakeHypertextString(HypertextAddress, InternLink, CurrentDirectory, ObjectLinkIds, ObjectId) _
                                    & """>" _
                                    & NewLine() & "  """ & PointsString & """" _
                                    & NewLine() & "</POLYGON>"
                    ElseIf (m_lecDrawStyle = LEC_DRAWSTYLE_FILLEDOUTLINE And IsClosedPolyline) Then
                        strScript = strScript & NewLine() & "<POLYGON x=""" & ConvertDoubleToString(x) _
                                    & """ y=""" & ConvertDoubleToString(y) _
                                    & """ width=""" & ConvertDoubleToString(width) _
                                    & """ height=""" & ConvertDoubleToString(height) _
                                    & """ color=""" & m_szLineColor _
                                    & """ fillColor=""" & m_szFillColor _
                                    & """ lineWidth=""" & LineWidth _
                                    & """ lineStyle=""" & LineStyle _
                                    & """ length=""" & Len(PointsString) _
                                    & """ ZPosition=""" & ZPosition _
                                    & MakeHypertextString(HypertextAddress, InternLink, CurrentDirectory, ObjectLinkIds, ObjectId) _
                                    & """>" _
                                    & NewLine() & "  """ & PointsString & """" _
                                    & NewLine() & "</POLYGON>"
                    ElseIf m_lecDrawStyle = LEC_DRAWSTYLE_FILLEDOUTLINE And Not IsClosedPolyline Then
                        strScript = strScript & NewLine() & "<POLYGON x=""" & ConvertDoubleToString(x) _
                                    & """ y=""" & ConvertDoubleToString(y) _
                                    & """ width=""" & ConvertDoubleToString(width) _
                                    & """ height=""" & ConvertDoubleToString(height) _
                                    & """ color=""" & m_szLineColor _
                                    & """ fillColor=""" & m_szFillColor _
                                    & """ lineWidth=""" & LineWidth _
                                    & """ lineStyle=""" & LineStyle _
                                    & """ length=""" & Len(PointsString) _
                                    & """ ZPosition=""" & ZPosition _
                                    & MakeHypertextString(HypertextAddress, InternLink, CurrentDirectory, ObjectLinkIds, ObjectId) _
                                    & """>" _
                                    & NewLine() & "  """ & PointsString & """" _
                                    & NewLine() & "</POLYGON>"
                        strScript = strScript & NewLine() & "<POLYLINE x=""" & ConvertDoubleToString(x) _
                                    & """ y=""" & ConvertDoubleToString(y) _
                                    & """ width=""" & ConvertDoubleToString(width) _
                                    & """ height=""" & ConvertDoubleToString(height) _
                                    & """ color=""" & m_szLineColor _
                                    & """ lineWidth=""" & LineWidth _
                                    & """ lineStyle=""" & LineStyle _
                                    & MakeArrowString(arrowStyle, arrowConfig) _
                                    & """ length=""" & Len(PointsString) _
                                    & """ ZPosition=""" & ZPosition _
                                    & MakeHypertextString(HypertextAddress, InternLink, CurrentDirectory, ObjectLinkIds, ObjectId) _
                                    & """>" _
                                    & NewLine() & "  """ & PointsString & """" _
                                    & NewLine() & "</POLYLINE>"
                    ElseIf m_lecDrawStyle = LEC_DRAWSTYLE_OUTLINE Then 'Or m_lecDrawStyle = LEC_DRAWSTYLE_FILLEDOUTLINE Then
                        strScript = strScript & NewLine() & "<POLYLINE x=""" & ConvertDoubleToString(x) _
                                    & """ y=""" & ConvertDoubleToString(y) _
                                    & """ width=""" & ConvertDoubleToString(width) _
                                    & """ height=""" & ConvertDoubleToString(height) _
                                    & """ color=""" & m_szLineColor _
                                    & """ lineWidth=""" & LineWidth _
                                    & """ lineStyle=""" & LineStyle _
                                    & MakeArrowString(arrowStyle, arrowConfig) _
                                    & """ length=""" & Len(PointsString) _
                                    & """ ZPosition=""" & ZPosition _
                                    & MakeHypertextString(HypertextAddress, InternLink, CurrentDirectory, ObjectLinkIds, ObjectId) _
                                    & """>" _
                                    & NewLine() & "  """ & PointsString & """" _
                                    & NewLine() & "</POLYLINE>"
        '                            & """ name=""" & NameForAnim & "L"
                    ElseIf m_lecDrawStyle = LEC_DRAWSTYLE_TRANSPARENT Then
                        strScript = strScript & NewLine() & "<POLYGON x=""" & ConvertDoubleToString(x) _
                                    & """ y=""" & ConvertDoubleToString(y) _
                                    & """ width=""" & ConvertDoubleToString(width) _
                                    & """ height=""" & ConvertDoubleToString(height) _
                                    & """ color=""" & "#01ffffff" _
                                    & """ fillColor=""" & "#01ffffff" _
                                    & """ lineWidth=""" & LineWidth _
                                    & """ lineStyle=""" & LineStyle _
                                    & """ length=""" & Len(PointsString) _
                                    & """ ZPosition=""" & ZPosition _
                                    & MakeHypertextString(HypertextAddress, InternLink, CurrentDirectory, ObjectLinkIds, ObjectId) _
                                    & """>" _
                                    & NewLine() & "  """ & PointsString & """" _
                                    & NewLine() & "</POLYGON>"
                    End If
    
                    If m_lecDrawStyle = LEC_DRAWSTYLE_FILLEDOUTLINE And Not g_conversionOptions.NoGroup Then
                        DecIndent
                        strScript = strScript & NewLine() & "</GROUP>"
                    End If
                End If
                DecIndent
    
            Case LEC_SHAPETYPE_CIRCLE
                If m_lecDrawStyle <> LEC_DRAWSTYLE_NONE Then
                    IncIndent
                    If m_lecDrawStyle <> LEC_DRAWSTYLE_TRANSPARENT Then
                        strScript = NewLine() & "<OVAL x=""" & ConvertDoubleToString(x) _
                                    & """ y=""" & ConvertDoubleToString(y) _
                                    & """ width=""" & ConvertDoubleToString(width) _
                                    & """ height=""" & ConvertDoubleToString(height) _
                                    & """ color=""" & m_szLineColor _
                                    & """ fillColor=""" & m_szFillColor _
                                    & """ lineWidth=""" & LineWidth _
                                    & """ lineStyle=""" & LineStyle _
                                    & """ ZPosition=""" & ZPosition _
                                    & MakeHypertextString(HypertextAddress, InternLink, CurrentDirectory, ObjectLinkIds, ObjectId) _
                                    & """></OVAL>"
            '                        & """ name=""" & NameForAnim
                    Else
                        strScript = NewLine() & "<OVAL x=""" & ConvertDoubleToString(x) _
                                    & """ y=""" & ConvertDoubleToString(y) _
                                    & """ width=""" & ConvertDoubleToString(width) _
                                    & """ height=""" & ConvertDoubleToString(height) _
                                    & """ color=""" & "#01ffffff" _
                                    & """ fillColor=""" & "#01ffffff" _
                                    & """ lineWidth=""" & LineWidth _
                                    & """ lineStyle=""" & LineStyle _
                                    & """ ZPosition=""" & ZPosition _
                                    & MakeHypertextString(HypertextAddress, InternLink, CurrentDirectory, ObjectLinkIds, ObjectId) _
                                    & """></OVAL>"
            '                        & """ name=""" & NameForAnim
                    End If
                    DecIndent
                End If
            Case LEC_SHAPETYPE_IMAGE
    
                If HasOutline Then
                    strScript = OutlineRect.Script()
                Else
                    strScript = ""
                End If
                
                IncIndent
    
                strScript = strScript & NewLine() & "<IMAGE x=""" & ConvertDoubleToString(x) _
                            & """ y=""" & ConvertDoubleToString(y) _
                            & """ width=""" & ConvertDoubleToString(width) _
                            & """ height=""" & ConvertDoubleToString(height) _
                            & """ filename=""" & ImageFileName & """ length=""0" _
                            & """ ZPosition=""" & ZPosition _
                            & MakeHypertextString(HypertextAddress, InternLink, CurrentDirectory, ObjectLinkIds, ObjectId) _
                            & """></IMAGE>"
            
                DecIndent
    
            Case LEC_SHAPETYPE_TEXTGROUP
                IncIndent
                If Not g_conversionOptions.NoGroup Then
                    strScript = NewLine() & "<GROUP>" '  name=""" & NameForAnim & """>"
                    IncIndent
                End If
                If m_lecDrawStyle <> LEC_DRAWSTYLE_NONE Then
                    strScript = strScript & NewLine() & "<RECTANGLE x=""" & ConvertDoubleToString(x) _
                                & """ y=""" & ConvertDoubleToString(y) _
                                & """ width=""" & ConvertDoubleToString(width) _
                                & """ height=""" & ConvertDoubleToString(height) _
                                & """ color=""" & m_szLineColor _
                                & """ fillColor=""" & m_szFillColor _
                                & """ lineWidth=""" & LineWidth _
                                & """ lineStyle=""" & LineStyle _
                                & """ ZPosition=""" & ZPosition _
                                & MakeHypertextString(HypertextAddress, InternLink, CurrentDirectory, ObjectLinkIds, ObjectId) _
                                & """></RECTANGLE>"
                End If
    
                For i = 1 To GroupItemNum
                    DecIndent
                    If Not GroupItems(i) Is Nothing And GroupItems(i).m_bVisible Then
                        strScript = strScript & GroupItems(i).Script()
                    End If
                    IncIndent
                Next
                If Not g_conversionOptions.NoGroup Then
                    DecIndent
                    strScript = strScript & NewLine() & "</GROUP>"
                End If
                DecIndent
            Case LEC_SHAPETYPE_USERDEFINEDGROUP
                If Not g_conversionOptions.NoGroup Then
                    IncIndent
                    strScript = NewLine() & "<GROUP>" '  name=""" & NameForAnim & """>"
                End If
                For i = 1 To GroupItemNum
                    If GroupItems(i).m_bVisible Then
                        strScript = strScript & GroupItems(i).Script()
                    End If
                Next
                If Not g_conversionOptions.NoGroup Then
                    strScript = strScript & NewLine() & "</GROUP>"
                    DecIndent
                End If
            Case Else
                'ErrLog LEC_ERRORTYPE_UNKNOWN, "Unknown object type."
        End Select
    
        If ContainText Then
            strScript = strScript & TextInShape.Script()
        End If
    End If

    Script = strScript
End Function

'
' Properties
'

Public Sub SetLineAttributes(pptShape As Shape, Optional DoNotUseArrow As Boolean = False)
    
    With pptShape
        If .Line.transparency = 1 Then
            m_szLineColor = "none"
        Else
            If .Line.transparency < 0 Then
                m_szLineColor = GetARGBColorString(0, .Line.ForeColor)
            Else
                m_szLineColor = GetARGBColorString(.Line.transparency, .Line.ForeColor)
            End If
        End If
        
        If .Line.Weight > 0 Then
            LineWidth = CLng(.Line.Weight)
        Else
            LineWidth = 1
        End If
        
        LineStyle = MLBLineStyle(.Line)

        If Not DoNotUseArrow Then
            arrowStyle = MLBArrowStyle(.Line)
            arrowConfig = MLBArrowConfig(.Line)
        End If
        
    End With

End Sub

Public Function SetGraphstyle(shp As Shape) As LecDrawStyle
'    If shp.Fill.Visible = msoTrue Then
'        m_lecDrawStyle = LEC_DRAWSTYLE_FILLED
'        SetFillAttributes shp
'        m_szLineColor = FillColor
'        LineWidth = 1
'        LineStyle = " "
'    End If
    On Error Resume Next
    
    m_lecDrawStyle = LEC_DRAWSTYLE_NONE

    If shp.Fill.Visible = msoTrue Then
        m_lecDrawStyle = LEC_DRAWSTYLE_FILLED
        SetFillAttributes shp
        m_szLineColor = m_szFillColor
        'If shp.Fill.Type <> msoFillBackground Or shp.Fill.Type <> msoFillSolid Then

    End If

    If shp.Line.Visible = msoTrue Then
        m_lecDrawStyle = m_lecDrawStyle + LEC_DRAWSTYLE_OUTLINE
        SetLineAttributes shp
    End If

    If shp.ActionSettings.Count >= ppMouseClick Then
        If HypertextAddress <> "" Or InternLink <> "" And m_lecDrawStyle = LEC_DRAWSTYLE_NONE Then
            m_lecDrawStyle = LEC_DRAWSTYLE_TRANSPARENT
        End If
    End If
    
    SetGraphstyle = m_lecDrawStyle
End Function

Public Function SetGraphmode(shp As Shape) As Boolean
    If shp.Visible = msoFalse Then
        m_bVisible = False
    ElseIf SetGraphstyle(shp) = LEC_DRAWSTYLE_NONE And shp.HasTextFrame = msoFalse Then
        m_bVisible = False
    Else
        m_bVisible = True
    End If

    SetGraphmode = Not m_bVisible
End Function

'
'
'

Public Sub SetNewAnchor(shp As Shape, Optional UseUserDefinedSize As Boolean = False)

    Dim l As Single
    Dim r As Single
    Dim t As Single
    Dim b As Single

    Dim dummy As Boolean

    Select Case shp.Type
        Case MsoShapeType.msoCallout
            Select Case shp.Callout.Type
                Case MsoCalloutType.msoCalloutOne, MsoCalloutType.msoCalloutTwo
                    SetVertOfCalloutTwo shp, dummy
                Case MsoCalloutType.msoCalloutThree
                    SetVertOfCalloutThree shp, dummy
                Case MsoCalloutType.msoCalloutFour
                    SetVertOfCalloutFour shp, dummy
            End Select
'        Case MsoShapeType.msoAutoShape
'            Select Case shp.AutoShapeType
'                Case MsoAutoShapeType.msoShapeRectangularCallout, MsoAutoShapeType.msoShapeRoundedRectangularCallout
'            End Select
    End Select

    VertNum = VertNum + 4
    ReDim Preserve Vert(1 To VertNum) As aofNode
    If UseUserDefinedSize Then
        Vert(VertNum - 3).x = x
        Vert(VertNum - 3).y = y
        Vert(VertNum - 2).x = x + width
        Vert(VertNum - 2).y = y
        Vert(VertNum - 1).x = x
        Vert(VertNum - 1).y = y + height
        Vert(VertNum).x = x + width
        Vert(VertNum).y = y + height
    Else
        Vert(VertNum - 3).x = shp.Left
        Vert(VertNum - 3).y = shp.Top
        Vert(VertNum - 2).x = shp.Left + shp.width
        Vert(VertNum - 2).y = shp.Top
        Vert(VertNum - 1).x = shp.Left
        Vert(VertNum - 1).y = shp.Top + shp.height
        Vert(VertNum).x = shp.Left + shp.width
        Vert(VertNum).y = shp.Top + shp.height
        SetSize shp         'important!  necessary in nodesrotate
    End If

    
    NodesRotate shp.Rotation

    l = Vert(1).x
    r = Vert(1).x
    t = Vert(1).y
    b = Vert(1).y

    Dim i As Long
    For i = 2 To VertNum
        If l > Vert(i).x Then
            l = Vert(i).x
        ElseIf r < Vert(i).x Then
            r = Vert(i).x
        End If
        If t > Vert(i).y Then
            t = Vert(i).y
        ElseIf b < Vert(i).y Then
            b = Vert(i).y
        End If
    Next
    
    x = l
    y = t

    If g_conversionOptions.WithImageSize Then
        width = r - l
        height = b - t
    Else
        width = 0
        height = 0
    End If

    VertNum = 0
    Erase Vert
End Sub

Public Sub NewSetNewAnchor(shp As Shape, Optional UseUserDefinedSize As Boolean = False)

    Dim l As Single
    Dim r As Single
    Dim t As Single
    Dim b As Single

    SetShapeVertices shp
    NewRotateNodes shp

    l = Vert(1).x
    r = Vert(1).x
    t = Vert(1).y
    b = Vert(1).y

    Dim i As Long
    For i = 2 To VertNum
        If l > Vert(i).x Then
            l = Vert(i).x
        ElseIf r < Vert(i).x Then
            r = Vert(i).x
        End If
        If t > Vert(i).y Then
            t = Vert(i).y
        ElseIf b < Vert(i).y Then
            b = Vert(i).y
        End If
    Next

    x = l
    y = t

    If g_conversionOptions.WithImageSize Then
        width = r - l
        height = b - t
    Else
        width = 0
        height = 0
    End If

    VertNum = 0
End Sub

''''''''''''''''''''''''''''''''''''
' Private functions and procedures '
''''''''''''''''''''''''''''''''''''

'
' Perform PowerPoint shapes
'

Private Sub PerformTextBox(sld As Slide, pptShape As Shape, hasText As Boolean, Optional paragraphDescription As String = "")

    SetSize pptShape
    
    Dim bShapeHasBackground As Boolean: bShapeHasBackground = False
    With pptShape
        If .Fill.Visible = msoTrue Then
            If .Fill.Type <> msoFillSolid Then
            
                If hasText Then
                    ImportShapeTextAsText sld, pptShape, paragraphDescription
                End If
                
                Dim bSizecalculated As Boolean
                ImportShapeBackgroundAsImage pptShape, bSizecalculated
               
                Exit Sub
                
            End If
            
            m_lecDrawStyle = LEC_DRAWSTYLE_FILLED
            SetFillAttributes pptShape
            m_szLineColor = m_szFillColor
            bShapeHasBackground = True
        End If
        
        If .Line.Visible = msoTrue Then
            m_lecDrawStyle = m_lecDrawStyle + LEC_DRAWSTYLE_OUTLINE
            SetLineAttributes pptShape
            bShapeHasBackground = True
        End If
        
    End With
    
    ImportShapeAsText sld, pptShape, paragraphDescription
    
    If m_lecShapeType = LEC_SHAPETYPE_NONE And bShapeHasBackground Then
        m_lecShapeType = LEC_SHAPETYPE_RECTANGLE
    End If
    
End Sub

Public Sub PerformTableCell(sld As Slide, pptShape As Shape)

    SetSize pptShape
 
    ImportShapeAsText sld, pptShape, ""
    
    If m_lecShapeType = LEC_SHAPETYPE_NONE Then
        m_lecShapeType = LEC_SHAPETYPE_RECTANGLE
    End If
    
End Sub

Public Sub PerformTemplateTextbox(sld As Slide, shp As Shape, _
                                                Optional dateTime As String = "", _
                                                Optional footer As String = "", _
                                                Optional slideNum As String)

    Dim tmpShp As Shape
    Set tmpShp = g_LecturnityDocument.m_tempSlide.Shapes.AddTextbox(msoTextOrientationHorizontal, _
                                                                    shp.Left, shp.Top, shp.width, shp.height)

    SetReplaceText dateTime, footer, CStr(sld.slideNumber)

    On Error Resume Next

    CloneTextFrame tmpShp, shp

    If g_lApplicationVersion <> 2007 Then
        Dim tmpTr As TextRange
        Dim tmpTrNew As TextRange
        Dim nTmp   As Long
        For Each tmpTr In shp.TextFrame.TextRange.Runs
            If TextContainsAutoTextField(tmpTr.text, nTmp, nTmp) Then
                Set tmpTrNew = tmpShp.TextFrame.TextRange.InsertAfter(ReplaceAutoTextField(tmpTr.text))
            Else
                Set tmpTrNew = tmpShp.TextFrame.TextRange.InsertAfter(tmpTr.text)
            End If
    
            CloneTextRangeSetting tmpTrNew, tmpTr
        Next
    Else
#If COMPILE_VERSION = 2007 Then
        Dim tmpTr2 As TextRange2
        Dim tmpTr2New As TextRange2
        For Each tmpTr2 In shp.TextFrame2.TextRange.Runs
            If TextContainsAutoTextField(tmpTr2.text, nTmp, nTmp) Then
                Set tmpTr2New = tmpShp.TextFrame2.TextRange.InsertAfter(ReplaceAutoTextField(tmpTr2.text))
            Else
                Set tmpTr2New = tmpShp.TextFrame2.TextRange.InsertAfter(tmpTr2.text)
            End If
    
            CloneTextRange2Setting tmpTr2New, tmpTr2
        Next
#End If
    End If

    Perform sld, tmpShp

    tmpShp.Delete
    
    Set tmpShp = Nothing
    
End Sub

Public Sub PerformAsImage(shp As Shape)

    Dim bSizecalculated As Boolean: bSizecalculated = False

    ' The calculated size of shapes with type msoTexteffect is wrong.
    ' The size have to be extracted from the metafile
    If g_lApplicationVersion = 2007 Or shp.Type = msoTextEffect Then
        ImportShapeAsImage_2002 shp, bSizecalculated
    Else
        ImportShapeAsImage shp
    End If
    
    If Not bSizecalculated Then
        If shp.Line.Visible And Not HasOutline Then
            x = shp.Left - shp.Line.Weight
            y = shp.Top - shp.Line.Weight
            width = shp.width + 2 * shp.Line.Weight
            height = shp.height + 2 * shp.Line.Weight
            SetNewAnchor shp, True
        Else
            SetNewAnchor shp
        End If
    End If
    
    ConvertToPNG
    
End Sub

Private Sub PerformGroup(sld As Slide, shp As Shape)

    ' find out if it is better to export shape as image
    Dim iFreeformCount As Long: iFreeformCount = 0
    Dim i As Long
    For i = 1 To shp.GroupItems.Count
        If shp.GroupItems(i).Type = msoFreeform Then
            iFreeformCount = iFreeformCount + 1
        End If
        
        If iFreeformCount > 10 Then
            Dim bSizecalculated As Boolean
            ImportShapeTextAsText sld, shp
            ImportShapeBackgroundAsImage shp, bSizecalculated
            If Not bSizecalculated Then
                SetNewAnchor shp
            End If
            
            Exit Sub
        End If
    Next

    m_lecShapeType = LEC_SHAPETYPE_GROUP
    HasGroupItem = True


#If COMPILE_VERSION = 2007 Then

    GroupItemNum = shp.GroupItems.Count
    If GroupItemNum < 1 Then
        Exit Sub
    End If
    ReDim GroupItems(1 To GroupItemNum) As aofShape

    Dim iGroupIndex As Long: iGroupIndex = 1   ' number of visible shapes
    For i = 1 To shp.GroupItems.Count
        Set GroupItems(iGroupIndex) = New aofShape
        AddHyperlink GroupItems(iGroupIndex)
        GroupItems(iGroupIndex).Perform sld, shp.GroupItems(i)
        If GroupItems(iGroupIndex).m_bVisible Then
            iGroupIndex = iGroupIndex + 1
        End If
    Next
    
    GroupItemNum = iGroupIndex - 1
#Else
    ' duplicate the gourp
    Dim tmpGrp As Shape
    Set tmpGrp = shp.Duplicate(1)
    tmpGrp.Top = shp.Top
    tmpGrp.Left = shp.Left

    GroupItemNum = tmpGrp.GroupItems.Count
    If GroupItemNum < 1 Then
        Exit Sub
    End If
    ReDim GroupItems(1 To GroupItemNum) As aofShape

    ' at first, ungroup
    Dim shpRgn As ShapeRange
    Set shpRgn = tmpGrp.Ungroup

    Dim iGroupIndex As Long: iGroupIndex = 1   ' number of visible shapes
    For i = 1 To shpRgn.Count
        Set GroupItems(iGroupIndex) = New aofShape
        AddHyperlink GroupItems(iGroupIndex)
        GroupItems(iGroupIndex).Perform sld, shpRgn(i)
        If GroupItems(iGroupIndex).m_bVisible Then
            iGroupIndex = iGroupIndex + 1
        End If
    Next
    
    GroupItemNum = iGroupIndex - 1

    shpRgn.Delete
    Set shpRgn = Nothing
    Set tmpGrp = Nothing
#End If


End Sub

#If COMPILE_VERSION = 2007 Then
Private Function TableTextContainsSpecialChars(shp As Shape)
    
    Dim i As Long
    Dim j As Long
    Dim k As Long
    Dim txtRange As TextRange
    Dim txtRange2 As TextRange2
    Dim bFontIsSupported As Boolean: bFontIsSupported = True
    
    For i = 1 To shp.Table.Columns.Count
        For j = 1 To shp.Table.Columns(i).Cells.Count
            If shp.Table.Columns(i).Cells(j).Shape.HasTextFrame Then
                Set txtRange = shp.Table.Columns(i).Cells(j).Shape.TextFrame.TextRange
                Set txtRange2 = shp.Table.Columns(i).Cells(j).Shape.TextFrame2.TextRange
                If txtRange.ParagraphFormat.Bullet.Visible = msoTrue Then
                    TableTextContainsSpecialChars = True
                    Exit Function
                End If
                
                For k = 1 To txtRange2.Characters.Count
                    If txtRange2.Characters(k).Font.Fill.Type <> msoFillSolid Or _
                       txtRange2.Characters(k).Font.Glow.Radius <> 0 Or _
                       txtRange2.Characters(k).Font.Reflection.Type <> msoReflectionTypeNone Or _
                       txtRange2.Characters(k).Font.Line.Visible = msoTrue Or _
                       txtRange2.Characters(k).Font.Shadow.Visible = msoTrue Then
                        TableTextContainsSpecialChars = True
                        Exit Function
                    End If
                Next
                
                For k = 1 To txtRange.Characters.Count
                    bFontIsSupported = FontSupportsCharacter(txtRange, k)
                    If Not bFontIsSupported Then
                        TableTextContainsSpecialChars = True
                        Exit Function
                    End If
                Next
            End If
        Next
    Next
    
    TableTextContainsSpecialChars = False
    
End Function
#End If

Private Sub PerformTable(sld As Slide, shp As Shape)

#If COMPILE_VERSION = 2007 Then
    On Error Resume Next
    
    m_lecShapeType = LEC_SHAPETYPE_IMAGE
    HasGroupItem = True

    SetSize shp
    
    Dim bTextContainsSpecialChars As Boolean
    bTextContainsSpecialChars = TableTextContainsSpecialChars(shp)
    
    If Not bTextContainsSpecialChars Then
        ImportTableBackground shp
        
        ContainText = True
        Set TextInShape = New aofShape
        TextInShape.ImportTableTextAsText sld, shp
    Else
        PerformAsImage shp
    End If
#End If
    
End Sub

Private Sub PerformLine(shp As Shape)

    m_lecShapeType = LEC_SHAPETYPE_LINE

    ' modify the size.
    With shp
        If .HorizontalFlip = msoTrue Then
            x = x + width
            width = -width
        End If
        If .VerticalFlip = msoTrue Then
            y = y + height
            height = -height
        End If

        If .Rotation <> 0 Then
            HasVertices = True
            VertNum = 2
            ReDim Vert(1 To VertNum) As aofNode
            Vert(1).x = x
            Vert(1).y = y
            Vert(2).x = x + width
            Vert(2).y = y + height
            NodesRotate CLng(.Rotation)
            x = Vert(1).x
            y = Vert(1).y
            width = Vert(2).x - Vert(1).x
            height = Vert(2).y - Vert(1).y
        End If
    End With

    SetGraphmode shp

    If Not m_bVisible Then
        Exit Sub
    End If

End Sub

Sub PerformOval(sld As Slide, shp As Shape)

    ImportShapeTextAsText sld, shp
    
    ImportShapeAsOval shp
    
End Sub

Public Sub PerformAutoshape(sld As Slide, shp As Shape, paragraphDescription As String)
'    If shp.Line.BeginArrowheadStyle <> msoArrowheadNone Or _
'        shp.Line.EndArrowheadStyle <> msoArrowheadNone Then
'        m_bConvertToPNG = True
'        ImportAsImage shp
'        NewSetNewAnchor shp
'        Width = 0
'        Height = 0
'        Exit Sub
'    End If
    
    
    ImportShapeTextAsText sld, shp, paragraphDescription
    
    SetShapeVertices shp

    ' Unsupported shapes are imported as Images
    ' There are a lot of problems with the adjustments in PowerPoint 2007
    ' All auto shapes which have these problems are exported as image
    If m_bShpIsUnsupported Or _
       (g_lApplicationVersion = 2007 And _
        shp.AutoShapeType = msoShapeRightArrow Or shp.AutoShapeType = msoShapeLeftArrow) Then
        Dim bSizecalculated As Boolean
        ImportShapeBackgroundAsImage shp, bSizecalculated
        If Not bSizecalculated Then
            'NewRotateNodes shp
            SetNewAnchor shp
        End If
        Exit Sub
    End If

    If m_bShpIsComplex Then
        ParseComplexShapes shp
    Else
        ParseSimpleShape shp
    End If
End Sub

Private Sub PerformPolygon(sld As Slide, shp As Shape, Optional bRotateNodes As Boolean = True)

    ImportShapeTextAsText sld, shp
    
    Dim bSizecalculated As Boolean
    
    
    ' There are problems with PowerPoint2007 calculating the correct bezier points
    If g_lApplicationVersion = 2007 Then
        Dim bHasCurves As Boolean: bHasCurves = False
        Dim i As Long
        For i = 1 To shp.Nodes.Count
            If shp.Nodes(i).SegmentType <> msoSegmentLine Then
                bHasCurves = True
                Exit For
            End If
        Next
        
        If bHasCurves Then
            ImportShapeBackgroundAsImage shp, bSizecalculated
            Exit Sub
        End If
        
    End If
    
    ' There is a problem with the "Deimos"-Layout of powerPoint 2007
    ' Two freehandforms are imported with incorrect positions and dimensions
    ' These freehandform will now be imported as images.
    If g_lApplicationVersion = 2007 Then
        If Round(shp.Left, 2) = -4.22 And Round(shp.Top, 2) = 455.51 And _
           Round(shp.width, 2) = 299.37 And Round(shp.height, 2) = 66 Then
            If UBound(shp.Vertices) = 4 Then
                If Round(shp.Vertices(1, 1), 2) = -4.15 And Round(shp.Vertices(1, 2), 2) = 455.52 And _
                   Round(shp.Vertices(2, 1), 2) = -3.71 And Round(shp.Vertices(2, 2), 2) = 455.57 And _
                   Round(shp.Vertices(3, 1), 2) = -3.81 And Round(shp.Vertices(3, 2), 2) = 455.57 And _
                   Round(shp.Vertices(4, 1), 2) = -4.15 And Round(shp.Vertices(4, 2), 2) = 455.52 Then
                    ImportShapeBackgroundAsImage shp, bSizecalculated
                    Exit Sub
                End If
            End If
        ElseIf Round(shp.Left, 2) = 56.41 And Round(shp.Top, 2) = 393.86 And _
           Round(shp.width, 2) = 299.37 And Round(shp.height, 2) = 113.63 Then
            If UBound(shp.Vertices) = 4 Then
                If Round(shp.Vertices(1, 1), 2) = 56.39 And Round(shp.Vertices(1, 2), 2) = 393.89 And _
                   Round(shp.Vertices(2, 1), 2) = 56.98 And Round(shp.Vertices(2, 2), 2) = 393.91 And _
                   Round(shp.Vertices(3, 1), 2) = 56.82 And Round(shp.Vertices(3, 2), 2) = 393.91 And _
                   Round(shp.Vertices(4, 1), 2) = 56.39 And Round(shp.Vertices(4, 2), 2) = 393.88 Then
                    ImportShapeBackgroundAsImage shp, bSizecalculated
                    Exit Sub
                End If
            End If
        End If
    End If
    
    ImportShapeAsPolygon shp, False, bRotateNodes
    
End Sub

Private Sub PerformCallout(sld As Slide, shp As Shape)

    SetSize shp
    SetLineAttributes shp

    Select Case shp.Callout.Type
        Case msoCalloutOne
            ParseCalloutOne sld, shp
        Case msoCalloutTwo
            ParseCalloutTwo sld, shp
        Case msoCalloutThree
            ParseCalloutThree sld, shp
        Case msoCalloutFour
            ParseCalloutFour sld, shp
    End Select

End Sub

Private Sub PerformOLEObject(shp As Shape)
    
    m_bConvertToPNG = False
    m_bIsOLEObject = True
    
    PerformAsImage shp
    
End Sub

'
' Import PowerPoint shapes
'

Public Sub ImportShapeAsText(sld As Slide, shp As Shape, Optional paragraphDescription As String = "")

    'On Error Resume Next
    
    Dim totalParaNum As Long: totalParaNum = shp.TextFrame.TextRange.paragraphs.Count
    If totalParaNum = 0 Then
        Exit Sub
    End If
    
    If g_lApplicationVersion = 2007 Then
#If COMPILE_VERSION = 2007 Then
        If shp.TextFrame2.TextRange.Font.Fill.Type <> msoFillSolid Or _
           shp.TextFrame2.TextRange.Font.Glow.Radius <> 0 Or _
           shp.TextFrame2.TextRange.Font.Reflection.Type <> msoReflectionTypeNone Or _
           shp.TextFrame2.TextRange.Font.Line.Visible = msoTrue Or _
           shp.TextFrame2.TextRange.Font.Shadow.Visible = msoTrue Then
            Dim bSizecalculated As Boolean
            ImportShapeTextAsImage sld, shp
            Exit Sub
        End If
#End If
    End If

    Dim usedParagraphs()        As Long
    Dim usedParagraphCount      As Long: usedParagraphCount = -1
    Dim excludedParagraphs()    As Long
    Dim excludedParagraphCount  As Long: excludedParagraphCount = -1
    If paragraphDescription <> "" Then
        usedParagraphCount = 0
        excludedParagraphCount = 0
        Dim tmpStr As String: tmpStr = paragraphDescription
        Dim start As Long: start = 1
        Dim pos As Long: pos = 0
        Dim length As Long: length = Len(tmpStr)
        Dim bUsed As MsoTriState: bUsed = msoTriStateMixed
        Do While length > 0
            pos = InStr(start, tmpStr, ":", vbTextCompare)
            If (pos > 0) Then
                Dim zwStr As String
                zwStr = Left(tmpStr, pos - 1)
                If (zwStr = "-not") Then
                    bUsed = msoFalse
                    ReDim excludedParagraphs(1 To totalParaNum) As Long
                ElseIf zwStr = "-only" Then
                    bUsed = msoTrue
                    ReDim usedParagraphs(1 To totalParaNum) As Long
                ElseIf bUsed = msoFalse Then
                    excludedParagraphCount = excludedParagraphCount + 1
                    excludedParagraphs(excludedParagraphCount) = val(zwStr)
                ElseIf bUsed = msoTrue Then
                    usedParagraphCount = usedParagraphCount + 1
                    usedParagraphs(usedParagraphCount) = val(zwStr)
                End If
                
                tmpStr = Right(tmpStr, length - pos)
                length = Len(tmpStr)
            Else
                length = 0
            End If
        Loop
    End If

    ' search for used paragraphs
'
    Dim i               As Long
    If excludedParagraphCount > 0 Then
        usedParagraphCount = 0
        ReDim usedParagraphs(1 To totalParaNum) As Long
        For i = 1 To totalParaNum
            Dim bFound As Boolean: bFound = False
            Dim j As Long: j = 1
            Do While (Not bFound And j <= excludedParagraphCount)
                If i = excludedParagraphs(j) Then
                    bFound = True
                End If
                j = j + 1
            Loop
            If Not bFound Then
                usedParagraphCount = usedParagraphCount + 1
                usedParagraphs(usedParagraphCount) = i
            End If
        Next
        Erase excludedParagraphs
        excludedParagraphCount = -1
    End If
    
    If usedParagraphCount = -1 Then
        ReDim usedParagraphs(1 To totalParaNum) As Long
        usedParagraphCount = totalParaNum
        For i = 1 To totalParaNum
            usedParagraphs(i) = i
        Next
    End If
    
    If usedParagraphCount = 0 Then
        Exit Sub
    End If
    
    
    m_lecShapeType = LEC_SHAPETYPE_TEXTGROUP
    m_bVisible = True

    On Error Resume Next
    
    With shp.AnimationSettings
        If .Animate = msoTrue Then
            Select Case .TextLevelEffect
                Case ppAnimateByAllLevels, ppAnimateLevelMixed, ppAnimateLevelNone
                Case Else
                    m_bHasSubAnim = True
                    If .AnimateTextInReverse Then
                        m_bAnimInReverse = True
                    End If
            End Select
        End If
    End With

    'cntObj = 0
    
    Dim bIsParaHead As Boolean: bIsParaHead = True
    Dim paraNum As Long: paraNum = 1

    Dim cntObj          As Long
    With shp.TextFrame.TextRange
        GroupItemNum = .Lines.Count * 3

        If GroupItemNum < 1 Then
            GroupItemNum = 1
            HasGroupItem = True
            ReDim GroupItems(1 To GroupItemNum) As aofShape
            Set GroupItems(1) = New aofShape
            AddHyperlink GroupItems(1)
            GroupItems(1).SetBlankText
            Erase usedParagraphs
            Exit Sub
        End If

        HasGroupItem = True

        ReDim GroupItems(1 To GroupItemNum) As aofShape

        'For Each tr In .Lines
        'For Each tr In .Paragraphs
        Dim tr As TextRange
        For i = 1 To usedParagraphCount - 1

            Set tr = .paragraphs(usedParagraphs(i))
            'ParseTextLine tr, bIsParaHead, cntObj, paraNum

            ParseTextParagraph sld, shp, usedParagraphs(i), bIsParaHead, cntObj, paraNum
        Next


        ' the last paragraph
        Set tr = .paragraphs(usedParagraphs(usedParagraphCount))
        If tr.text = "" Or (tr.length = 1 And tr.text = Chr$(13) & Chr$(10)) Then
            ' an empty paragraph
        Else
            ' if the bullet should be converted as image,
            ' add an empty line in the end of text, in order to
            ' extract the bullet of the last line.
            If Not BulletIsText(tr) Then
                tr.InsertAfter vbNewLine
                ParseTextParagraph sld, shp, usedParagraphs(usedParagraphCount), bIsParaHead, cntObj, paraNum, True
            Else
                ParseTextParagraph sld, shp, usedParagraphs(usedParagraphCount), bIsParaHead, cntObj, paraNum, False
            End If
        ' the inserted "vbNewLine" should be deleted RIGHT after "ParseBullet" in function ParseTextparagragh
        End If
       
        Erase usedParagraphs
        
        If GroupItemNum > cntObj Then
            GroupItemNum = cntObj

            If GroupItemNum > 0 Then
                HasGroupItem = True
                ReDim Preserve GroupItems(1 To GroupItemNum) As aofShape
            Else
                HasGroupItem = False
                Erase GroupItems
            End If
        End If
    End With

    If TextHasShadow(shp) Then
        HasTextShadow = True
        ShadowOffX = shp.Shadow.OffsetX
        ShadowOffY = shp.Shadow.OffsetY
        ShadowColor = GetRGBColorString(shp.Shadow.ForeColor)
        SetShadowStatus
    End If

End Sub

' if the object contains text, extract the text as text object
Private Sub ImportShapeTextAsText(sld As Slide, shp As Shape, Optional paragraphDescription As String = "")

    If g_lApplicationVersion = 2007 And shp.Type = msoTable Then
        ContainText = True
        Set TextInShape = New aofShape
        TextInShape.ImportTableTextAsText sld, shp
    ElseIf m_bShpHasConvertableText Then
        ContainText = True
        Set TextInShape = New aofShape
        AddHyperlink TextInShape
        TextInShape.ImportShapeAsText sld, shp, paragraphDescription
    End If
    
End Sub

Public Sub ImportTableTextAsText(sld As Slide, shp As Shape)
  
    m_lecShapeType = LEC_SHAPETYPE_GROUP
    
    SetSize shp
    
    Dim lColumnCount As Long: lColumnCount = shp.Table.Columns.Count
    Dim lRowCount As Long: lRowCount = shp.Table.Rows.Count
    
    Dim lTableItemCount As Long
    lTableItemCount = lColumnCount * lRowCount
    ReDim GroupItems(1 To lTableItemCount) As aofShape
    Dim iGroupIndex As Long: iGroupIndex = 1   ' number of visible shapes
    Dim i As Long
    Dim j As Long
    Dim bIsAlreadyImported As Boolean
    Dim txtRange As TextRange
    Dim txtRange2 As TextRange
    For i = 1 To shp.Table.Columns.Count
        For j = 1 To shp.Table.Columns(i).Cells.Count
            Set txtRange = shp.Table.Columns(i).Cells(j).Shape.TextFrame.TextRange
            bIsAlreadyImported = False
            If j > 1 Then
                Set txtRange2 = shp.Table.Columns(i).Cells(j - 1).Shape.TextFrame.TextRange
                If IsEqual(txtRange, txtRange2) Then
                    bIsAlreadyImported = True
                End If
            End If
            If i > 1 Then
                Set txtRange2 = shp.Table.Columns(i - 1).Cells(j).Shape.TextFrame.TextRange
                If IsEqual(txtRange, txtRange2) Then
                    bIsAlreadyImported = True
                End If
            End If
            If Not bIsAlreadyImported Then
                Set GroupItems(iGroupIndex) = New aofShape
                If shp.Table.Columns(i).Cells(j).Shape.HasTextFrame Then
                    GroupItems(iGroupIndex).PerformTableCell sld, shp.Table.Columns(i).Cells(j).Shape
                    If GroupItems(iGroupIndex).m_bVisible Then
                        iGroupIndex = iGroupIndex + 1
                    End If
                End If
            End If
        Next
    Next
    
    GroupItemNum = iGroupIndex - 1
    If GroupItemNum > 0 Then
        HasGroupItem = True
    End If
    
    MoveTextItems shp.Left, shp.Top
    
End Sub

Sub ImportTextRangeAsImage(shp As Shape, txtSeg As TextRange, maxFntSize As Single)
    
    m_lecShapeType = LEC_SHAPETYPE_IMAGE
    
    ' Duplicate shape
    Dim tmpShape As Shape
    Set tmpShape = shp.Duplicate(1)
    
    On Error GoTo ExpError:
    
    ' Reduce text in shape to text range string
    Dim iCharLen As Long: iCharLen = txtSeg.length()
    Dim iTextLen As Long: iTextLen = tmpShape.TextFrame.TextRange.length()
    
    If txtSeg.start > 1 Then
        tmpShape.TextFrame.TextRange.Characters(1, txtSeg.start - 1).Delete
    End If

    If iTextLen - iCharLen > 0 Then
        tmpShape.TextFrame.TextRange.Characters(1 + iCharLen, iTextLen - iCharLen).Delete
    End If

    ' Adapt shape parameters
    With tmpShape.TextFrame.TextRange
        x = txtSeg.BoundLeft
        
        .IndentLevel = 1
        .ParagraphFormat.Bullet = msoFalse
        
        Dim lineHeight As Single
        If txtSeg.ParagraphFormat.LineRuleWithin Then
            lineHeight = txtSeg.BoundHeight / txtSeg.ParagraphFormat.SpaceWithin
        Else
            lineHeight = txtSeg.BoundHeight
        End If
        
        Dim yLineOffset As Single: yLineOffset = 0
        If txtSeg.ParagraphFormat.LineRuleWithin Then
            If txtSeg.ParagraphFormat.SpaceWithin >= 1 Then
                yLineOffset = ((maxFntSize - txtSeg.Font.Size) / 3) - ((lineHeight - maxFntSize) / 2)
                If txtSeg.ParagraphFormat.SpaceWithin > 1 Then
                    yLineOffset = yLineOffset - (txtSeg.ParagraphFormat.SpaceWithin - 1) * (maxFntSize)
                End If
            Else
                yLineOffset = (txtSeg.ParagraphFormat.SpaceWithin - 1) * (txtSeg.Font.Size - maxFntSize)
                If maxFntSize > txtSeg.BoundHeight Then
                    yLineOffset = yLineOffset - (txtSeg.BoundHeight - maxFntSize)
                End If
            End If
        Else
            yLineOffset = txtSeg.ParagraphFormat.SpaceWithin
        End If
        
        y = txtSeg.BoundTop - yLineOffset
        
        tmpShape.Left = 0
        tmpShape.Top = 0
        tmpShape.width = txtSeg.BoundWidth
        tmpShape.height = lineHeight
    End With

        
    With tmpShape.TextFrame
        .WordWrap = msoFalse
        .MarginLeft = 0
        .MarginRight = 0
        .MarginTop = 0
        .MarginBottom = 0
        .VerticalAnchor = msoAnchorBottomBaseLine
        With .TextRange.ParagraphFormat
            .LineRuleAfter = msoTrue
            .LineRuleBefore = msoTrue
            .LineRuleWithin = msoTrue
            .SpaceAfter = 0
            .SpaceBefore = 0
            .SpaceWithin = 1
            .Alignment = ppAlignLeft
            .BaseLineAlignment = ppBaselineAlignBaseline
        End With
    End With

    If g_conversionOptions.WithImageSize Then
        width = tmpShape.width
        height = tmpShape.height
    Else
        width = 0
        height = 0
    End If

    ' Export text as emf file
    Dim result As Long
    
    
    Dim szImagePrefix As String
    szImagePrefix = CreateImagePrefix()
    With g_conversionOptions
        ImageFileName = szImagePrefix & .ExpTextSuffix
        tmpShape.Export .WBFilePath & ImageFileName, .ExpTextFormat
    End With

    ' Delete temporary shape
    tmpShape.Delete
    Set tmpShape = Nothing

    Exit Sub

ExpError:
    If Err.Number = -2147467259 Then
        g_conversionOptions.FailInfo = Err.Number 'Err.Description
        'MsgBox Err.Description
        g_conversionOptions.FailMsg = g_szMsgOverwriteImage & g_conversionOptions.WBFilePath & ImageFileName
        g_conversionOptions.Failed = True
    End If
    Resume Next
End Sub

Private Sub ImportBulletAsImage(shp As Shape, iParagraphIndex As Long, tr As TextRange, imgPath As String, maxFntSize As Single)

    ' Duplicate shape
    Dim tmpShape As Shape
    Set tmpShape = shp.Duplicate(1)
    
    ' Delete all text except bullet
    Dim iDel As Long: iDel = 1
    Dim i As Long
    For i = 1 To tmpShape.TextFrame.TextRange.paragraphs.Count
        If i <> iParagraphIndex Then
            tmpShape.TextFrame.TextRange.paragraphs(iDel).Delete
        Else
            iDel = 2
        End If
    Next
    
    ' Adapt shape parameters
    With tmpShape.TextFrame
        .TextRange.text = "  "
        .TextRange.ParagraphFormat.Bullet.Font.color.RGB = tr.ParagraphFormat.Bullet.Font.color.RGB
        ' the second blank should have the maxFntSize to simulate the real textrange.
        .TextRange.Characters(2, 1).Font.Size = maxFntSize ' that's why the text contains 2 blanks.
        .WordWrap = msoFalse        ' make the new shape size to fit the text size.
        .TextRange.ParagraphFormat.Alignment = tr.ParagraphFormat.Alignment
        .TextRange.Font.Underline = msoFalse
        
        If g_conversionOptions.WithImageSize Then
            width = .TextRange.BoundLeft + .TextRange.BoundWidth '+ .MarginRight
            height = .TextRange.BoundHeight
            
            If .TextRange.ParagraphFormat.Alignment <> ppAlignLeft Then
                .TextRange.ParagraphFormat.Alignment = ppAlignRight
'                offx = tr.BoundLeft - tr.Parent.Parent.Left - w
                tmpShape.width = tr.BoundLeft - tr.Parent.Parent.Left + .TextRange.BoundWidth + .MarginLeft ' + .MarginRight
                width = tmpShape.width
            End If
            
            tmpShape.width = width
            tmpShape.height = height
        Else
            width = 0
            height = 0
        End If
    End With
    
    'If g_lApplicationVersion = 2007 Then
        tmpShape.TextFrame.MarginTop = 0
        tmpShape.TextFrame.MarginBottom = 0
        tmpShape.Line.Visible = msoFalse
    'End If
    
    On Error GoTo ExpError:
    
    ' Export bullet as emf file
    imgPath = GetBulletImageName(tmpShape)
    tmpShape.Export g_conversionOptions.WBFilePath & imgPath, g_conversionOptions.ExpTextFormat
    
    'If g_lApplicationVersion = 2007 Then
        Dim zX As Long, zY As Long, zWidth As Long, zHeight As Long
        Dim result As Boolean
        result = GetBulletDimension(g_conversionOptions.WBFilePath & imgPath, zX, zY, zWidth, zHeight)
        If result Then
            width = zWidth
            height = zHeight
        End If
    'End If
    
    ' Delete temporary shape
    tmpShape.Delete
    Set tmpShape = Nothing
    
    Exit Sub
ExpError:
    If Err.Number = -2147467259 Then
        g_conversionOptions.FailInfo = Err.Number 'Err.Description
        'MsgBox Err.Description
        g_conversionOptions.Failed = True
        g_conversionOptions.FailMsg = g_szMsgOverwriteImage & g_conversionOptions.WBFilePath & imgPath
    End If
    Resume Next
End Sub


' if the object contains text, extract the text as text object
Private Sub ImportShapeTextAsImage(sld As Slide, shp As Shape)

    Dim tmpShape As Shape: Set tmpShape = shp.Duplicate(1)
    With tmpShape
        ' save shape settings
        Dim tw As Long: tw = shp.width
        Dim th As Long: th = shp.height
        Dim tl  As Long: tl = shp.Left
        Dim tt As Long: tt = shp.Top
        
        .Fill.transparency = 1
        .Line.Visible = msoFalse
        '.Fill.ForeColor.RGB = RGB(255, 255, 255)
        '.Fill.BackColor.RGB = RGB(255, 255, 255)

        ' set shape as original size
        ' but this make the presentation modified.
        .LockAspectRatio = msoFalse
        .width = tw
        .height = th
        .Left = tl
        .Top = tt
    End With

    Dim bSizecalculated As Boolean
    ImportShapeAsImage_2002 tmpShape, bSizecalculated
    
    tmpShape.Delete
    Set tmpShape = Nothing

End Sub

Private Function ExportShapeAsPNG(shp As Shape, szImagePrefix As String, ByRef bSizecalculated As Boolean) As Boolean

    On Error Resume Next
    
    Dim result As Boolean: result = False
    Dim zX As Long, zY As Long, zWidth As Long, zHeight As Long
    
    With g_conversionOptions
      ' in the following cases it is difficult to calculate the correct position and dimension
       ' of the image. In this case it is better to export image as EMF and to get the correct
       ' values from the EMF file.
       
       Dim bRetrieveDimension As Boolean: bRetrieveDimension = m_bShpHas3D Or m_bShpHasShadow
#If COMPILE_VERSION = 2007 Then
       bRetrieveDimension = True
'       shp.Reflection.Type <> msoReflectionTypeNone Or _
'                            shp.Glow.Radius > 0 Or _
'                            m_bShpHas3D Or _
'                            m_bShpHasShadow Or _
'                            shp.Rotation <> 0
#End If
    
        ImageFileName = szImagePrefix & .ExpImageSuffix
        Dim lNewSlideWidth As Long: lNewSlideWidth = g_lSlideWidth
        Dim lNewSlideHeight As Long: lNewSlideHeight = g_lSlideHeight
        If Not (shp.Fill.Visible And (shp.Fill.Type = msoFillPatterned)) Then
            lNewSlideWidth = g_lSlideWidth * 3
            lNewSlideHeight = g_lSlideHeight * 3
        End If
        If g_lApplicationVersion = 2007 And bRetrieveDimension Then
            Call shp.Export(.WBFilePath & ImageFileName, .ExpImageFormat, _
                            lNewSlideWidth, lNewSlideHeight)
        Else
            Call shp.Export(.WBFilePath & ImageFileName, .ExpImageFormat)
         End If
        
        If .ExpImageFormat = ppShapeFormatPNG Then
            result = RewriteImage(.WBFilePath, ImageFileName, szImagePrefix, .ExpImageSuffix)
        End If
       
     
    
       If result And bRetrieveDimension Then
           Dim szEmfName As String: szEmfName = szImagePrefix & .ExpMetafileSuffix
           Call shp.Export(.WBFilePath & szEmfName, .ExpMetafileFormat)
           result = GetMetafileDimension(.WBFilePath, szImagePrefix, .ExpMetafileSuffix, zX, zY, zWidth, zHeight)
           If result Then
               x = zX
               y = zY
               width = zWidth
               height = zHeight
               bSizecalculated = True
           End If
       End If
    End With
    
    ExportShapeAsPNG = result
    
End Function

Private Function ExportShapeAsMetafile(shp As Shape, szImagePrefix As String, bDoWithoutGrid As Boolean, ByRef bSizecalculated As Boolean) As Boolean
     
    On Error Resume Next
    
    Dim zX As Long, zY As Long, zWidth As Long, zHeight As Long
    Dim result As Boolean: result = False
    
    With g_conversionOptions
        ImageFileName = szImagePrefix & .ExpMetafileSuffix
        Call shp.Export(.WBFilePath & ImageFileName, .ExpMetafileFormat)
        If bDoWithoutGrid Then
            result = ExportMetafileWithoutGrid(.WBFilePath, ImageFileName, szImagePrefix, .ExpMetafileSuffix, zX, zY, zWidth, zHeight)
        Else
            result = ExportMetafile(.WBFilePath, ImageFileName, szImagePrefix, .ExpMetafileSuffix, zX, zY, zWidth, zHeight)
        End If
                    
        If result Then
            x = zX
            y = zY
            width = zWidth
            height = zHeight
            bSizecalculated = True
        End If
    End With
    
    ExportShapeAsMetafile = result
    
End Function


Public Sub ImportShapeAsImage_2002(shp As Shape, ByRef bSizecalculated As Boolean)

    m_lecShapeType = LEC_SHAPETYPE_IMAGE
    HasOutline = False

    If ImageIsEmpty(shp) Then
        m_bVisible = False
        Exit Sub
    End If
    
    Dim bTryEmfExport As Boolean: bTryEmfExport = True
#If COMPILE_VERSION = 2007 Then
    If g_lApplicationVersion = 2007 Then
        If (shp.AutoShapeType = msoShapeRectangle And (shp.Type = msoPicture Or shp.Type = msoLinkedPicture)) Then
            bTryEmfExport = False
        End If

    End If
#End If
    
    bSizecalculated = False
    
    On Error GoTo ExpError:
    
    With g_conversionOptions
    
        Dim szImagePrefix As String
        szImagePrefix = CreateImagePrefix()
        
        Dim bShapeIsNoPicture As Boolean
        bShapeIsNoPicture = (shp.Type <> msoLinkedPicture And shp.Type <> msoPicture)
        
        Dim result As Boolean: result = False
        ' If the shape is not a picture, try to export it as EMF or WMF
        ' The quality of pictures is better if they are exported as PNG
        If bShapeIsNoPicture Then
            Dim bHasChart As Boolean: bHasChart = False
            Dim bHasSmartArt As Boolean: bHasSmartArt = False
            Dim bTextHas3d As Boolean: bTextHas3d = False
            Dim bHasPattern As Boolean: bHasPattern = False
            
#If COMPILE_VERSION = 2007 Then
            bHasChart = shp.HasChart
            bTextHas3d = shp.TextFrame2.ThreeD.Visible
            bHasPattern = shp.Fill.Visible And (shp.Fill.Type = msoFillPatterned)
            If shp.Type = msoSmartArt Then
                bHasSmartArt = True
            Else
                If shp.Type = msoPlaceholder Then
                    If shp.PlaceholderFormat.ContainedType = msoSmartArt Then
                        bHasSmartArt = True
                    End If
                End If
            End If
#End If
            If g_lApplicationVersion = 2007 And (bHasChart Or m_bShpHas3D Or bHasSmartArt Or bTextHas3d Or bHasPattern) Then
                ' There is a problem with the emf export of PowerPoint 2007
                ' Shapes with a chart are drawn with a grid.
                ' Shapes with 3D are drawn with a grid.
                ' Some Smart Art shapes are drawn with a grid.
                Dim bShapeHasTransparency As Boolean
                bShapeHasTransparency = shp.Fill.Visible And _
                                        shp.Fill.Type = msoFillSolid And _
                                        shp.Fill.transparency <> 0
                
                If Not bShapeHasTransparency And bHasChart Then
                    result = ExportShapeAsMetafile(shp, szImagePrefix, True, bSizecalculated)
                Else
                    result = ExportShapeAsPNG(shp, szImagePrefix, bSizecalculated)
                End If
            Else
                result = ExportShapeAsMetafile(shp, szImagePrefix, False, bSizecalculated)
            End If
            
        Else ' picture
        
            Dim bExtractablePicture As Boolean: bExtractablePicture = False
            Dim bHasTransparentPixel As Boolean: bHasTransparentPixel = False
            If g_lApplicationVersion <> 2007 And _
                shp.PictureFormat.TransparentBackground = msoTrue Then
                bHasTransparentPixel = True
            End If
            bExtractablePicture = Not bHasTransparentPixel And _
                                  shp.Rotation = 0 And _
                                  Not m_bShpHas3D And Not m_bShpHasShadow
#If COMPILE_VERSION = 2007 Then
            If bExtractablePicture Then
                bExtractablePicture = bTryEmfExport And _
                                      shp.Glow.Radius = 0 And _
                                      shp.Reflection.Type = msoReflectionTypeNone And _
                                      shp.SoftEdge.Type = msoSoftEdgeTypeNone
            End If
#End If
            If bExtractablePicture Then
                ImageFileName = szImagePrefix & .ExpMetafileSuffix
                Call shp.Export(.WBFilePath & ImageFileName, .ExpMetafileFormat)
                result = ExportImage(.WBFilePath, ImageFileName, szImagePrefix, .ExpMetafileSuffix)
            End If
        End If
            
        ' if the shape type is picture or placeholder or
        ' if there is no image on clipboard export shape
        If Not result Then
            result = ExportShapeAsPNG(shp, szImagePrefix, bSizecalculated)
        Else
            ' Image is written as PNG or JPG, no conversion necessary
            m_bConvertToPNG = False
        End If
       
    End With
    
    Exit Sub
    
ExpError:
    If Err.Number = -2147467259 Then
        g_conversionOptions.FailInfo = Err.Number 'Err.Description
        'MsgBox Err.Description
        g_conversionOptions.FailMsg = g_szMsgOverwriteImage & g_conversionOptions.WBFilePath & ImageFileName
        g_conversionOptions.Failed = True
    End If
    Resume Next
End Sub

Public Sub ImportShapeAsImage(shp As Shape)

    m_lecShapeType = LEC_SHAPETYPE_IMAGE
    HasOutline = False

    If ImageIsEmpty(shp) Then
        m_bVisible = False
        Exit Sub
    End If
    
    SetSize shp
    
    If Not g_conversionOptions.WithImageSize Then
        width = 0
        height = 0
    End If

    On Error GoTo ExpError:
    
    With g_conversionOptions
    
        Dim szImagePrefix As String
        szImagePrefix = CreateImagePrefix()
    
        If m_bConvertToPNG Then
        
            Dim result As Boolean: result = False
            Dim bConvertableShape As Boolean: bConvertableShape = False
            
            If shp.Type = msoPlaceholder Then
                bConvertableShape = True
            End If
            
            If (shp.Type = msoLinkedPicture Or _
                shp.Type = msoPicture) Then
                If (shp.PictureFormat.TransparentBackground <> msoTrue) And _
                   (shp.Rotation = 0) Then
                    bConvertableShape = True
                End If
            End If
            
            ' Convert emf (PPT 2002/2003) or wmf (PPT 2000) to png/jpg
            If bConvertableShape Then
                ImageFileName = szImagePrefix & .ExpMetafileSuffix
                Call shp.Export(.WBFilePath & ImageFileName, .ExpMetafileFormat)
                result = ExportImage(.WBFilePath, ImageFileName, szImagePrefix, .ExpMetafileSuffix)
                
                If False Then ' result Then : Bugfix 3920
                    Set OutlineRect = New aofShape
                    OutlineRect.ImportShapeAsRectangle shp
                    OutlineRect.CalculateVerticesWithLineWidth shp
                    HasOutline = True
                End If
            End If
            
            ' if the shape type is not picture or placeholder or
            ' if there is no image on clipboard export shape
            If Not result Then
            
                ImageFileName = szImagePrefix & .ExpImageSuffix
                Call shp.Export(.WBFilePath & ImageFileName, .ExpImageFormat)
                
                If .ExpImageFormat = ppShapeFormatPNG Then
                    result = RewriteImage(.WBFilePath, ImageFileName, szImagePrefix, .ExpImageSuffix)
                End If
                
            Else
                ' Image is written as PNG or JPG, no conversion necessary
                m_bConvertToPNG = False
            End If
            
        Else
        
            ImageFileName = szImagePrefix & .ExpTextSuffix
            Call shp.Export(.WBFilePath & ImageFileName, .ExpTextFormat)
            result = CheckIfMetafileIsEmpty(.WBFilePath & ImageFileName)
            If Not result Then
                ImageFileName = szImagePrefix & .ExpImageSuffix
                Call shp.Export(.WBFilePath & ImageFileName, .ExpImageFormat)
                If .ExpImageFormat = ppShapeFormatPNG Then
                    result = RewriteImage(.WBFilePath, ImageFileName, szImagePrefix, .ExpImageSuffix)
                End If
            End If
            
        End If
    End With
    
    Exit Sub
    
ExpError:
    If Err.Number = -2147467259 Then
        g_conversionOptions.FailInfo = Err.Number 'Err.Description
        'MsgBox Err.Description
        'g_conversionOptions.FailMsg = Err.Description
        g_conversionOptions.FailMsg = g_szMsgOverwriteImage & g_conversionOptions.WBFilePath & ImageFileName
        g_conversionOptions.Failed = True
    End If
    Resume Next
End Sub

Private Sub ImportShapeBackgroundAsImage(shp As Shape, ByRef bSizecalculated As Boolean)
    
    bSizecalculated = False
    
    If g_lApplicationVersion = 2007 Or _
      (g_lApplicationVersion <> 2000 And shp.Type <> msoPicture And shp.Type <> msoLinkedPicture) Then
        
        If Not m_bShpHasConvertableText Then
            ImportShapeAsImage_2002 shp, bSizecalculated
        Else
            ImportShapeAsImageWithoutText_2002 shp, bSizecalculated
        End If
        
    Else
    
        If Not m_bShpHasConvertableText Then
            ImportShapeAsImage shp
        Else
            ImportShapeAsImageWithoutText shp
        End If
        
    End If
    
End Sub

Private Sub ImportTableBackground(shp As Shape)
    
#If COMPILE_VERSION = 2007 Then
    On Error Resume Next
    
    Dim tw As Long      ' shape width
    Dim th As Long      ' shape height
    Dim tl  As Long     ' shape Left
    Dim tt As Long      ' shape top
    
    Dim tmpShape As Shape
    
    Set tmpShape = shp.Duplicate(1)
    
    With tmpShape
        ' save shape settings
        tw = shp.width
        th = shp.height
        tl = shp.Left
        tt = shp.Top
                               
        Dim i As Long
        Dim j As Long
        Dim k As Long
        
        Dim origRange As TextRange
        
        For i = 1 To .Table.Columns.Count
            For j = 1 To .Table.Rows.Count
                With .Table.Columns(i).Cells(j).Shape
                ' The text is imported separately, so make it invisible.
                    If .TextFrame.TextRange.ActionSettings(ppMouseClick).Action = ppActionHyperlink Then
                        ' Changing the Action is only possible for empty TextRange
                        .TextFrame.DeleteText
                        .TextFrame.TextRange.ActionSettings(ppMouseClick).Action = ppActionNone
                        Set origRange = shp.Table.Columns(i).Cells(j).Shape.TextFrame.TextRange
                        For k = 1 To origRange.Characters.Count
                            .TextFrame.TextRange.InsertAfter (origRange.Characters(k))
                            CloneTextRangeSetting .TextFrame.TextRange.Characters(k), origRange.Characters(k)
                        Next
                    End If
                    .TextFrame2.TextRange.Font.Fill.Visible = msoFalse
                    .TextFrame2.TextRange.Font.Line.Visible = msoFalse
                    .TextFrame2.TextRange.Font.UnderlineStyle = msoNoUnderline
                End With
            Next
        Next

        ' set shape as original size
        ' but this make the presentation modified.
        .LockAspectRatio = msoFalse
        .width = tw
        .height = th
        .Left = tl
        .Top = tt
    End With
    
    Dim bSizecalculated As Boolean: bSizecalculated = False
    ImportShapeAsImage_2002 tmpShape, bSizecalculated

    tmpShape.Delete
    Set tmpShape = Nothing
    
#End If
    
End Sub
' do not extract the text, only export the shape (without text) as image
Private Sub ImportShapeAsImageWithoutText_2002(shp As Shape, ByRef bSizecalculated As Boolean)

    Dim tw As Long      ' shape width
    Dim th As Long      ' shape height
    Dim tl  As Long     ' shape Left
    Dim tt As Long      ' shape top
    
    If shp.Fill.Visible = msoFalse And shp.Line.Visible = msoFalse Then
        Exit Sub
    End If
    
    Dim tmpShape As Shape
    
    bSizecalculated = False
    
    Set tmpShape = shp.Duplicate(1)
    
    With tmpShape
        ' save shape settings
        tw = shp.width
        th = shp.height
        tl = shp.Left
        tt = shp.Top
                                    
#If COMPILE_VERSION = 2007 Then
        If g_lApplicationVersion = 2007 Then
            .TextFrame2.TextRange.Font.Fill.Visible = msoFalse
        End If
#End If
        If g_lApplicationVersion <> 2007 Then
            .TextFrame.TextRange.Delete
        End If

        ' set shape as original size
        ' but this make the presentation modified.
        .LockAspectRatio = msoFalse
        .width = tw
        .height = th
        .Left = tl
        .Top = tt
    End With
    
    ImportShapeAsImage_2002 tmpShape, bSizecalculated

    tmpShape.Delete
    Set tmpShape = Nothing
    
End Sub


Private Sub ImportShapeAsImageWithoutText(shp As Shape)
    Dim tw As Long      ' shape width
    Dim th As Long      ' shape height
    Dim tl  As Long     ' shape Left
    Dim tt As Long      ' shape top
    Dim tr As MsoTriState   ' LockAspectRatio

    Dim tmpShape As Shape
    
    Set tmpShape = shp.Duplicate(1)
    With tmpShape
        ' save shape settings
        tw = shp.width
        th = shp.height
        tl = shp.Left
        tt = shp.Top
        
        .TextFrame.TextRange.Delete

        ' set shape as original size
        ' but this make the presentation modified.
        .LockAspectRatio = msoFalse
        .width = tw
        .height = th
        .Left = tl
        .Top = tt
    End With
    
    ImportShapeAsImage tmpShape
    
    tmpShape.Delete
    Set tmpShape = Nothing
End Sub

Sub ImportShapeAsOval(shp As Shape)

    If shp.Rotation <> 0 Or _
       Not IsSolidFilled(shp) Then
        Dim bSizecalculated As Boolean
        ImportShapeBackgroundAsImage shp, bSizecalculated
        If Not bSizecalculated Then
            NewSetNewAnchor shp
        End If
        Exit Sub
    End If

    m_lecShapeType = LEC_SHAPETYPE_CIRCLE
    SetSize shp
    SetGraphmode shp
    
End Sub

Sub ImportShapeAsRectangle(shp As Shape)

' Only used by ImportAsImage to get the border rectangle.
' The outline information is interesting, not the fill values.

    If shp.Rotation <> 0 Then
        ImportShapeAsFourPointsRect shp
        Exit Sub
    End If

    m_lecShapeType = LEC_SHAPETYPE_RECTANGLE
    SetSize shp

    If SetGraphmode(shp) Then    ' lineart and fillart are set here
        'ErrLog LEC_ERRORTYPE_INVISIBLESHAPE, "invisible Rect"
        Exit Sub
    End If

End Sub

Sub ImportShapeAsPolygon(shp As Shape, Optional UserDefinedNodes As Boolean = False, Optional bRotateNodes As Boolean = True)
        
    If shp.Type <> msoCallout Then
        If Not IsSolidFilled(shp) Or UBound(shp.Vertices) > 100 Or Not IsSolidLine(shp) Then
            Dim bSizecalculated As Boolean
            ImportShapeBackgroundAsImage shp, bSizecalculated
            If Not bSizecalculated Then
                SetNewAnchor shp
                ReadNodes shp
            End If
            Exit Sub
        End If
    End If

    m_lecShapeType = LEC_SHAPETYPE_POLYGON
    'SetSize shp

    SetLineAttributes shp

    If SetGraphmode(shp) Then    ' lineart and fillart are set here
        'ErrLog LEC_ERRORTYPE_INVISIBLESHAPE, "invisible Polygon"
        Exit Sub
    End If


    If Not UserDefinedNodes Then
        ReadNodes shp
        If bRotateNodes Then
            NodesRotate shp.Rotation
        End If
    End If

    PrintPointsString

    'Erase Vert
    HasVertices = False

End Sub

Sub ImportShapeAsFourPointsRect(shp As Shape)

    VertNum = 5
    ReDim Vert(1 To VertNum) As aofNode

    With shp

        Vert(1).x = .Left
        Vert(1).y = .Top
        Vert(2).x = .Left + .width
        Vert(2).y = .Top
        Vert(3).x = .Left + .width
        Vert(3).y = .Top + .height
        Vert(4).x = .Left
        Vert(4).y = .Top + .height
        Vert(5).x = .Left
        Vert(5).y = .Top

        SetSize shp
        NodesRotate .Rotation
    End With
    
    ImportShapeAsPolygon shp, True
    If shp.Type = msoCallout Then
        If shp.Callout.Border = msoFalse Then
            m_szLineColor = "none"
        End If
    End If

End Sub

'
' Properties
'

Private Sub GetBoundingRectDimension(shp As Shape, brl As Single, brt As Single, brw As Single, brh As Single)
    InitVertices 4
    SetVerticesRect shp
    NodesRotate shp.Rotation
    brl = Vert(1).x
    brt = Vert(1).y
    brw = brl
    brh = brt
    Dim i As Long
    For i = 2 To 4
        If brl > Vert(i).x Then
            brl = Vert(i).x
        ElseIf brw < Vert(i).x Then
            brw = Vert(i).x
        End If
        If brt > Vert(i).y Then
            brt = Vert(i).y
        ElseIf brh < Vert(i).y Then
            brh = Vert(i).y
        End If
    Next i
    brw = brw - brl
    brh = brh - brt

End Sub

Private Sub SetShapeProperties(shp As Shape)
    SetSize shp

    m_bExportAutoformAsImage = False
    
    m_bShpHas3D = Has3DEffect(shp)
    m_bShpHasShadow = HasShadow(shp)
    m_bShpHasText = HasTextInShape(shp)
    m_bShpIsSolidFilled = IsSolidFilled(shp)

    If Not m_bShpHasText Then
        m_bShpHasConvertableText = False
    ElseIf shp.TextFrame.Orientation <> msoTextOrientationHorizontal Then
        m_bShpHasConvertableText = False
    ElseIf shp.Rotation <> 0 Then
        m_bShpHasConvertableText = False
#If COMPILE_VERSION = 2007 Then
    ElseIf shp.TextFrame2.PathFormat <> msoPathTypeNone Then
        m_bShpHasConvertableText = False
    ElseIf shp.TextFrame2.TextRange.Font.Fill.Type <> msoFillSolid Then
        m_bShpHasConvertableText = False
    ElseIf shp.TextFrame2.TextRange.Font.Glow.Radius <> 0 Then
        m_bShpHasConvertableText = False
    ElseIf shp.TextFrame2.TextRange.Font.Reflection.Type <> msoReflectionTypeNone Then
        m_bShpHasConvertableText = False
    ElseIf shp.TextFrame2.TextRange.Font.Shadow.Visible = msoTrue Then
        m_bShpHasConvertableText = False
#End If
    Else
        m_bShpHasConvertableText = True
    End If

    ' if there is unconvertable text, the resulting image remains WMF format.
    If m_bShpHasText And Not m_bShpHasConvertableText Then
        m_bConvertToPNG = False
    End If
    
    m_bIsOLEObject = False

    ' set ShpIsComplex
    Select Case shp.AutoShapeType
        Case msoShapeStripedRightArrow, _
            msoShapeFlowchartConnector, _
            msoShapeDonut, _
            msoShapeFlowchartOr, _
            msoShapeCube, _
            msoShapeFlowchartSummingJunction, _
            msoShapeCan, msoShapeFlowchartMagneticDisk, _
            msoShapeBevel, msoShapeActionButtonCustom, _
            msoShapeDoubleBracket, _
            msoShapeDoubleBrace, _
            msoShapeFoldedCorner, _
            msoShapeSmileyFace, _
            msoShapeCurvedRightArrow, _
            msoShapeCurvedLeftArrow, _
            msoShapeCurvedUpArrow, _
            msoShapeCurvedDownArrow, _
            msoShapeOvalCallout, msoShapeCloudCallout
               m_bShpIsComplex = True
        Case msoShapeMixed
            Select Case shp.ConnectorFormat.Type
                Case msoConnectorStraight, _
                     msoConnectorElbow, _
                     msoConnectorCurve
                        m_bShpIsComplex = False
                Case Else
                        m_bShpIsComplex = False
            End Select
        Case Else
            m_bShpIsComplex = False
    End Select
End Sub

Private Function GetArrowStyle(Style As MsoArrowheadStyle) As String

    Select Case Style
        Case msoArrowheadOpen
            GetArrowStyle = "2"
        Case msoArrowheadStealth
            GetArrowStyle = "3"
        Case msoArrowheadDiamond
            GetArrowStyle = "4"
        Case msoArrowheadOval
            GetArrowStyle = "5"
        Case Else
            GetArrowStyle = "1"
    End Select
End Function

Private Function GetArrowDimension(length As MsoArrowheadLength, width As MsoArrowheadWidth) As String
    
    GetArrowDimension = "5"
    If width = msoArrowheadNarrow Then
        If length = msoArrowheadShort Then
            GetArrowDimension = "1"
        ElseIf length = msoArrowheadLengthMedium Then
            GetArrowDimension = "2"
        ElseIf length = msoArrowheadLong Then
            GetArrowDimension = "3"
        End If
    End If
    
    If width = msoArrowheadWidthMedium Then
        If length = msoArrowheadShort Then
            GetArrowDimension = "4"
        ElseIf length = msoArrowheadLengthMedium Then
            GetArrowDimension = "5"
        ElseIf length = msoArrowheadLong Then
            GetArrowDimension = "6"
        End If
    End If
    
    If width = msoArrowheadWide Then
        If length = msoArrowheadShort Then
            GetArrowDimension = "7"
        ElseIf length = msoArrowheadLengthMedium Then
            GetArrowDimension = "8"
        ElseIf length = msoArrowheadLong Then
            GetArrowDimension = "9"
        End If
    End If
    
End Function

Private Function MLBArrowConfig(ln As LineFormat) As String
    MLBArrowConfig = ""
    If ln.BeginArrowheadStyle = msoArrowheadNone Then
        MLBArrowConfig = MLBArrowConfig & "00"
    Else
        MLBArrowConfig = MLBArrowConfig & GetArrowStyle(ln.BeginArrowheadStyle) & GetArrowDimension(ln.BeginArrowheadLength, ln.BeginArrowheadWidth)
    End If
    
    If ln.EndArrowheadStyle = msoArrowheadNone Then
        MLBArrowConfig = MLBArrowConfig & "00"
    Else
        MLBArrowConfig = MLBArrowConfig & GetArrowStyle(ln.EndArrowheadStyle) & GetArrowDimension(ln.EndArrowheadLength, ln.EndArrowheadWidth)
    End If
    
End Function

Private Function MLBArrowStyle(ln As LineFormat) As String
    If ln.BeginArrowheadStyle <> msoArrowheadNone Then
        If ln.EndArrowheadStyle <> msoArrowheadNone Then
            MLBArrowStyle = "both"
        Else
            MLBArrowStyle = "first"
        End If
    Else
        If ln.EndArrowheadStyle <> msoArrowheadNone Then
            MLBArrowStyle = "last"
        Else
            MLBArrowStyle = "none"
        End If
    End If
End Function

Private Function MLBLineStyle(ln As LineFormat) As String
    Dim str As String
    Select Case ln.DashStyle
        Case MsoLineDashStyle.msoLineSolid
            str = " "
        Case MsoLineDashStyle.msoLineRoundDot
            str = "."
        Case MsoLineDashStyle.msoLineSquareDot
            str = ","
        Case MsoLineDashStyle.msoLineDash
            str = "-"
        Case MsoLineDashStyle.msoLineLongDash
            str = "_"
        Case MsoLineDashStyle.msoLineDashDot
            str = ".-"
        Case MsoLineDashStyle.msoLineDashDotDot
            str = "..-"
        Case MsoLineDashStyle.msoLineLongDashDot
            str = ".-"
#If COMPILE_VERSION = 2007 Then
        Case MsoLineDashStyle.msoLineLongDashDotDot
            str = "..-"
        Case MsoLineDashStyle.msoLineSysDash
            str = "-"
        Case MsoLineDashStyle.msoLineSysDashDot
            str = ".-"
        Case MsoLineDashStyle.msoLineSysDot
            str = "."
#End If
'        Case MsoLineDashStyle.msoLineDashStyleMixed
'            str = " "
        Case Else
            str = " "
    End Select
    MLBLineStyle = str
End Function

Public Sub SetFillAttributes(shp As Shape)
    If shp.Fill.transparency = 1 Then
        m_szFillColor = "none"
    Else
        m_szFillColor = GetARGBColorString(shp.Fill.transparency, shp.Fill.ForeColor)
    End If
End Sub

Private Function IsSolidFilled(shp As Shape) As Boolean
    On Error GoTo NoFillSetting
    If shp.Fill.Visible = msoFalse Then
        IsSolidFilled = True
        Exit Function
    End If

    If shp.Fill.Type = msoFillSolid Or shp.Fill.Type = msoFillBackground Then
        IsSolidFilled = True
    Else
        IsSolidFilled = False
    End If
    Exit Function
NoFillSetting:
    IsSolidFilled = False
    Exit Function
End Function

Private Function IsSolidLine(shp As Shape) As Boolean
    On Error GoTo NoLineSetting
    
    If shp.Line.Visible = msoFalse Then
        IsSolidLine = True
        Exit Function
    End If

    If shp.Line.DashStyle = msoLineSolid Then
        IsSolidLine = True
    Else
        IsSolidLine = False
    End If
    
    Exit Function
    
NoLineSetting:

    IsSolidLine = True
    Exit Function
    
End Function

Public Sub MoveTextItems(lOffX As Long, lOffY As Long)

    Dim i As Long
    If HasGroupItem And GroupItemNum > 0 Then
        For i = 1 To GroupItemNum
            GroupItems(i).x = GroupItems(i).x + lOffX
            GroupItems(i).y = GroupItems(i).y + lOffY
            GroupItems(i).MoveTextItems lOffX, lOffY
        Next
    End If
    
    If HasTextItem And TextItemNum > 0 Then
        For i = 1 To TextItemNum
            TextItems(i).x = TextItems(i).x + lOffX
            TextItems(i).y = TextItems(i).y + lOffY
        Next
    End If

End Sub

'
' Text
'

Private Function HasTextInShape(shp As Shape) As Boolean
    On Error Resume Next
    With shp
        If .HasTextFrame = msoFalse Then
            HasTextInShape = False
        ElseIf .TextFrame.hasText = msoFalse Then
            HasTextInShape = False
        ElseIf .TextFrame.TextRange.text = "" Then
            HasTextInShape = False
        Else
            HasTextInShape = True
        End If
    End With

End Function

Private Function TextContainsAutoTextField(txt As String, bg As Long, ed As Long) As Boolean
    On Error Resume Next

    Dim pos As Long

    pos = InStr(1, txt, Chr$(139), vbTextCompare)
    If pos < 1 Then
        TextContainsAutoTextField = False
        Exit Function
    Else
        bg = pos
    End If

    pos = InStr(1, txt, Chr$(155), vbTextCompare)
    If pos < 1 Then
        TextContainsAutoTextField = False
        Exit Function
    Else
        ed = pos
    End If
    
    TextContainsAutoTextField = True
    
End Function

Private Function IsAnimatedText(paragraphDescription) As Boolean

    Dim bIsAnimation As Boolean: bIsAnimation = False
    If paragraphDescription <> "" Then
        Dim tmpStr As String: tmpStr = paragraphDescription
        Dim start As Long: start = 1
        Dim pos As Long: pos = 0
        Dim length As Long: length = Len(tmpStr)
        Do While length > 0
            pos = InStr(start, tmpStr, ":", vbTextCompare)
            If (pos > 0) Then
                Dim zwStr As String
                zwStr = Left(tmpStr, pos - 1)
                If (zwStr = "-not") Then
                    bIsAnimation = False
                    Exit Do
                ElseIf zwStr = "-only" Then
                    bIsAnimation = True
                    Exit Do
                End If
                
                tmpStr = Right(tmpStr, length - pos)
                length = Len(tmpStr)
            Else
                length = 0
            End If
        Loop
    End If
    IsAnimatedText = bIsAnimation
End Function

Private Function TextHasShadow(shp As Shape) As Boolean
'--- deprecated---
'    If HasShadow(shp) Then
'        ' if the shape is not filled. the shadow applies to the text within the shape
'        If shp.Fill.Visible = msoFalse Then
'            TextHasShadow = True
'        Else
'            TextHasShadow = False
'        End If
'    Else
'        TextHasShadow = False
'    End If
    On Error Resume Next
    
    Dim bTextHasShadow As Boolean: bTextHasShadow = False
    
    Select Case shp.Shadow.Type
        Case msoShadow1, msoShadow2, msoShadow5, msoShadow6, msoShadow14
            bTextHasShadow = True
        Case Else
            bTextHasShadow = False
    End Select
    
    TextHasShadow = bTextHasShadow
    
End Function

' to replace the special text field in template
' now, it only replaces the page number field (German version)
Private Function ReplaceAutoTextField(txt As String) As String
    On Error Resume Next
    Dim strTmp  As String

    strTmp = Replace(txt, g_szDateAndTime, StrDate, Compare:=vbTextCompare)
    strTmp = Replace(strTmp, g_szFooter, StrFooter, Compare:=vbTextCompare)
    strTmp = Replace(strTmp, g_szSlideNumber, StrSlideNumber, Compare:=vbTextCompare)   'g_lCurrentPageNumber)
    
    ReplaceAutoTextField = strTmp
End Function


'
' Shadow
'

Private Function HasShadow(shp As Shape) As Boolean
    On Error GoTo ShadowError

    If shp.Shadow.Visible <> msoFalse Then
        HasShadow = True
    Else
        HasShadow = False
    End If
    Exit Function

ShadowError:
    HasShadow = False
    Exit Function
End Function

Private Sub AddShadowItem()
    If HasShadowItem Then
        ShadowItemNum = ShadowItemNum + 1
    Else
        ShadowItemNum = 1
        HasShadowItem = True
    End If

    ReDim Preserve ShadowItems(1 To ShadowItemNum) As aofShape
    Set ShadowItems(ShadowItemNum) = New aofShape
    AddHyperlink ShadowItems(ShadowItemNum)
End Sub

' col1 is the original color (fc)
' col2 is the brighter color
Private Sub GetShadowColors(fc As ColorFormat, col1 As String, col2 As String)
    Dim r As Long, g As Long, b As Long
    Dim rt As Long, gt As Long, bt As Long

    r = fc Mod 256
    g = CLng(fc / 256 - 0.5) Mod 256
    b = CLng(fc / 65536 - 0.5)

    col1 = GetHexColor(r, g, b)

    col2 = GetHexColor(IIf(r < 154, r + 102, 255), IIf(g < 154, g + 102, 255), IIf(b < 154, b + 102, 255))

End Sub

' col1 is the brighter color
' col2 is the darker color (60% of fc)
Private Sub GetShadow17Colors(fc As ColorFormat, col1 As String, col2 As String)
    Dim r As Long, g As Long, b As Long
    Dim rt As Long, gt As Long, bt As Long

    r = fc Mod 256
    g = CLng(fc / 256 - 0.5) Mod 256
    b = CLng(fc / 65536 - 0.5)

    col1 = GetHexColor(255 - CLng((255 - r) * 0.6), 255 - CLng((255 - g) * 0.6), 255 - CLng((255 - b) * 0.6))

    col2 = GetHexColor(CLng(r * 0.6), CLng(g * 0.6), CLng(b * 0.6))

End Sub

Private Sub SetShadowOffset(shp As Shape)
    Dim sl  As Single, st As Single, sw As Single, sh As Single
    Dim lm  As Single, rm As Single, bm As Single

    SetShapeVertices shp
    NewRotateNodes shp
    NewSetBoundingPoints    ' generate the bounding points.
    BPoints.GetDimension sl, st, sw, sh     ' get the dimesion of the shape

    Dim xoff As Single, yoff As Single
    xoff = shp.Shadow.OffsetX
    yoff = shp.Shadow.OffsetY

    ' there are still some problems with shadow no. 3,4,7,8,11,12,15,16
    ' if the shape is not Rectangle or it was rotated, the size of the shadow
    ' may be incorrect. In this case, the special transform functions of
    ' such kind of shadows should be make. So far, we use a simplier solution,
    ' the transparent part of the image should not be cut away.
    Select Case shp.Shadow.Type
        Case msoShadow1, msoShadow2, msoShadow5, msoShadow6, msoShadow14
            x = sl + IIf(xoff > 0, 0, xoff)
            y = st + IIf(yoff > 0, 0, yoff)
            width = sw + Abs(xoff)
            height = sh + Abs(yoff)
        Case MsoShadowType.msoShadow9   ' width/height of shadow is 0.75 * width/height of shape
            x = sl + IIf(xoff > 0, 0, xoff)
            y = st + IIf(yoff > 0, 0, yoff)
            If xoff < 0 Or xoff > sw * 0.25 Then
                width = sw + Abs(xoff)
            Else
                width = sw
            End If
            If yoff < 0 Or yoff > sh * 0.25 Then
                height = sh + Abs(yoff)
            Else
                height = sh
            End If
        Case MsoShadowType.msoShadow10  ' width/height of shadow is 1.25 * width/height of shape
            x = sl + IIf(xoff - sw * 1.25 > 0, 0, xoff - sw * 0.25)
            y = st + IIf(yoff - sh * 1.25 > 0, 0, yoff - sh * 0.25)
            If xoff < 0 Then
                width = sw * 1.25 - xoff    '
            ElseIf xoff < sw * 0.25 Then
                width = sw
            Else
                width = sw + xoff
            End If
            If yoff < 0 Then
                height = sh * 1.25 - yoff
            ElseIf yoff < sh * -0.25 Then
                height = sh
            Else
                height = sh + yoff
            End If
        Case MsoShadowType.msoShadow13    ' this shadow has 3 layer, so, the offset is xoff * 3
            x = sl + IIf(xoff > 0, 0, xoff * 3)
            y = st + IIf(yoff > 0, 0, yoff * 3)
            width = sw + xoff * 3
            height = sh + yoff * 3
        Case msoShadow17, msoShadow18
            x = sl - Abs(xoff)
            y = st - Abs(yoff)
            width = sw + Abs(xoff) * 2
            height = sh + Abs(yoff) * 2
        Case MsoShadowType.msoShadow19
            x = sl
            y = st
            width = sw
            height = sh
        Case MsoShadowType.msoShadow20
            x = sl
            y = st
            width = sw
            height = sh * 2
        Case msoShapeMixed
            ' in this case, in order to get the correct image size, the shape should be
            ' exported as GIF (width=0, height=0), BUT, the position of the GIF
            ' may be incorrect.
            ' We do not have any solution about this. Because once OffsetX or
            ' OffsetY is modified by the user, the ShadowType was set to ShaodwMixed,
            ' therefore, the shadow type information is lost.
            x = sl + IIf(xoff > 0, 0, xoff)
            y = st + IIf(yoff > 0, 0, yoff)
            width = sw + Abs(xoff)
            height = sh + Abs(yoff)
            m_iCutTransOff = 0
        Case Else   ' 3, 4, 7, 8, 11, 12, 15, 16
            GetSlopeShadowDimension shp.Shadow.Type, sl, st, sw, sh, x, y, width, height
    End Select
End Sub


' Suppose all unsupported autoshapes are rectangles.
Private Sub GetSlopeShadowDimension(shdTyp As Long, sl As Single, st As Single, sw As Single, sh As Single, _
                                l As Single, t As Single, w As Single, h As Single)
    Dim i As Long, num As Long
    Dim x0 As Single, y0 As Single, xr As Single, yr As Single

    num = BPoints.Count
    If num < 1 Then
        Exit Sub
    End If

    Select Case shdTyp
        Case 3
            For i = 1 To num
                BPoints.GetPoint i, x0, y0
                Shadow3Transform st + sh, x0, y0, xr, yr
                BPoints.Add xr, yr
            Next
        Case 4
            For i = 1 To num
                BPoints.GetPoint i, x0, y0
                Shadow4Transform st + sh, x0, y0, xr, yr
                BPoints.Add xr, yr
            Next
        Case 7
            For i = 1 To num
                BPoints.GetPoint i, x0, y0
                Shadow7Transform st + sh, x0, y0, xr, yr
                BPoints.Add xr, yr
            Next
        Case 8
            For i = 1 To num
                BPoints.GetPoint i, x0, y0
                Shadow8Transform st + sh, x0, y0, xr, yr
                BPoints.Add xr, yr
            Next
        Case 11
            For i = 1 To num
                BPoints.GetPoint i, x0, y0
                Shadow11Transform sl, st + sh, x0, y0, xr, yr
                BPoints.Add xr, yr
            Next
        Case 12
            For i = 1 To num
                BPoints.GetPoint i, x0, y0
                Shadow12Transform sl + sw, st + sh, x0, y0, xr, yr
                BPoints.Add xr, yr
            Next
        Case 15
            For i = 1 To num
                BPoints.GetPoint i, x0, y0
                Shadow15Transform sl, st + sh, x0, y0, xr, yr
                BPoints.Add xr, yr
            Next
        Case 16
            For i = 1 To num
                BPoints.GetPoint i, x0, y0
                Shadow16Transform sl + sw, st + sh, x0, y0, xr, yr
                BPoints.Add xr, yr
            Next
    End Select
    BPoints.GetDimension l, t, w, h
End Sub


Private Sub GenerateSimpleShadowItems(shp As Shape)
    Dim i As Long
    Dim sl  As Single, st As Single, sw As Single, sh As Single
    Dim ShadowLineColor As String, ShadowFillColor As String
    Dim col1 As String, col2 As String, col3 As String

    'NewSetBoundingPoints            ' set all bounding points.

    ' Now we no longer need Vert(), therefore it can be safely
    ' cleared and use it to calculate the Bounding Rectangle's dimension.
    GetBoundingRectDimension shp, sl, st, sw, sh

    ShadowFillColor = GetRGBColorString(shp.Shadow.ForeColor)
    ShadowLineColor = ShadowFillColor

    Select Case shp.Shadow.Type
    Case msoShadow1, msoShadow2, msoShadow5, msoShadow6, msoShadow14    ' simple shadow
        AddShadowItem
        MakeShadow Me, ShadowItems(ShadowItemNum), _
                sl, st, sw, sh, shp.Shadow.OffsetX, shp.Shadow.OffsetY, _
                ShadowFillColor, ShadowLineColor, msoShadow1
    Case MsoShadowType.msoShadow13    ' this shadow has 2 layer, so, the offset is xoff * 3
        GetShadowColors shp.Shadow.ForeColor, col1, col2
        AddShadowItem
        MakeShadow Me, ShadowItems(ShadowItemNum), _
                sl, st, sw, sh, shp.Shadow.OffsetX * 2, shp.Shadow.OffsetY * 2, _
                col2, col2, msoShadow1
        AddShadowItem
        MakeShadow Me, ShadowItems(ShadowItemNum), _
                sl, st, sw, sh, shp.Shadow.OffsetX, shp.Shadow.OffsetY, _
                col1, col1, msoShadow1
    Case msoShadow17, msoShadow18     ' 2 layers
        GetShadow17Colors shp.Fill.ForeColor, col1, col2
        AddShadowItem
        MakeShadow Me, ShadowItems(ShadowItemNum), _
                sl, st, sw, sh, shp.Shadow.OffsetX, shp.Shadow.OffsetY, _
                col2, col2, msoShadow1
        AddShadowItem
        MakeShadow Me, ShadowItems(ShadowItemNum), _
                sl, st, sw, sh, -shp.Shadow.OffsetX, -shp.Shadow.OffsetY, _
                col1, col1, msoShadow1
    Case Else
        AddShadowItem
        MakeShadow Me, ShadowItems(ShadowItemNum), _
                sl, st, sw, sh, shp.Shadow.OffsetX, shp.Shadow.OffsetY, _
                ShadowFillColor, ShadowLineColor, shp.Shadow.Type
    End Select

End Sub

Private Sub GenerateComplexShadowItems(shp As Shape)
    Dim i As Long
    Dim sl  As Single, st As Single, sw As Single, sh As Single
    Dim ShadowLineColor As String, ShadowFillColor As String
    Dim col1 As String, col2 As String

    GetBoundingRectDimension shp, sl, st, sw, sh
    ShadowFillColor = GetRGBColorString(shp.Shadow.ForeColor)
' so strange! it seems that line color in shadow can be set, but no
' respective properties in ShadowFormat. Here we use fill color instead.
    ShadowLineColor = ShadowFillColor
    For i = 1 To GroupItemNum
        Select Case shp.Shadow.Type
        Case msoShadow1, msoShadow2, msoShadow5, msoShadow6, msoShadow14    ' simple shadow
            AddShadowItem
            MakeShadow GroupItems(i), ShadowItems(ShadowItemNum), _
                    sl, st, sw, sh, shp.Shadow.OffsetX, shp.Shadow.OffsetY, _
                    ShadowFillColor, ShadowLineColor, msoShadow1
        Case MsoShadowType.msoShadow13    ' this shadow has 2 layers, so, the offset is xoff * 2
            GetShadowColors shp.Shadow.ForeColor, col1, col2
            AddShadowItem
            MakeShadow GroupItems(i), ShadowItems(ShadowItemNum), _
                    sl, st, sw, sh, shp.Shadow.OffsetX * 2, shp.Shadow.OffsetY * 2, _
                    col2, col2, msoShadow1
            AddShadowItem
            MakeShadow GroupItems(i), ShadowItems(ShadowItemNum), _
                    sl, st, sw, sh, shp.Shadow.OffsetX, shp.Shadow.OffsetY, _
                    col1, col1, msoShadow1
        Case msoShadow17, msoShadow18    ' 2 shadow layers
            GetShadow17Colors shp.Fill.ForeColor, col1, col2
            AddShadowItem
            MakeShadow GroupItems(i), ShadowItems(ShadowItemNum), _
                    sl, st, sw, sh, shp.Shadow.OffsetX, shp.Shadow.OffsetY, _
                    col2, col2, msoShadow1
            AddShadowItem
            MakeShadow GroupItems(i), ShadowItems(ShadowItemNum), _
                    sl, st, sw, sh, -shp.Shadow.OffsetX, -shp.Shadow.OffsetY, _
                    col1, col1, msoShadow1
        Case Else
            AddShadowItem
            MakeShadow GroupItems(i), ShadowItems(ShadowItemNum), _
                    sl, st, sw, sh, shp.Shadow.OffsetX, shp.Shadow.OffsetY, _
                    ShadowFillColor, ShadowLineColor, shp.Shadow.Type
        End Select
    Next
End Sub


' oObj: the original object (aofShape)
' sObj: the shadwo object (aofShape)
Private Sub MakeShadow(oObj As aofShape, sObj As aofShape, _
        sl As Single, st As Single, sw As Single, sh As Single, _
        xoff As Single, yoff As Single, _
        ShadowFillColor As String, ShadowLineColor As String, _
        shpType As Long)

    If sObj.GetShapeType() = LEC_SHAPETYPE_IMAGE Then
        Exit Sub
    End If
    
    Dim i As Long
    Dim x0 As Single
    Dim y0 As Single
    Dim xr As Single
    Dim yr As Single
    Select Case shpType
        Case 1 'msoShadow1, msoShadow2, msoShadow5, msoShadow6, msoShadow14,msoShadow13,msoShadow17,msoShadow18
            For i = 1 To oObj.BPoints.Count
                oObj.BPoints.GetPoint i, x0, y0
                sObj.BPoints.Add (x0 + xoff), (y0 + yoff)
            Next
        Case 9 'MsoShadowType.msoShadow9   ' width/height of shadow is 0.75 * width/height of shape
            For i = 1 To oObj.BPoints.Count
                oObj.BPoints.GetPoint i, x0, y0
                sObj.BPoints.Add ((x0 - sl) * 0.75 + sl + xoff), _
                                 ((y0 - st) * 0.75 + st + yoff)
            Next
        Case 10 'MsoShadowType.msoShadow10  ' width/height of shadow is 1.25 * width/height of shape
            For i = 1 To oObj.BPoints.Count
                oObj.BPoints.GetPoint i, x0, y0
                sObj.BPoints.Add ((x0 - (sl + sw)) * 1.25 + (sl + sw) + xoff), _
                                 ((y0 - (st + sh)) * 1.25 + (st + sh) + yoff)
            Next
        Case MsoShadowType.msoShadow3
            For i = 1 To oObj.BPoints.Count
                oObj.BPoints.GetPoint i, x0, y0
                Shadow3Transform (st + sh), x0, y0, xr, yr
                sObj.BPoints.Add (xr + xoff), (yr + yoff)
            Next
        Case MsoShadowType.msoShadow4
            For i = 1 To oObj.BPoints.Count
                oObj.BPoints.GetPoint i, x0, y0
                Shadow4Transform (st + sh), x0, y0, xr, yr
                sObj.BPoints.Add (xr + xoff), (yr + yoff)
            Next
        Case MsoShadowType.msoShadow7
            For i = 1 To oObj.BPoints.Count
                oObj.BPoints.GetPoint i, x0, y0
                Shadow7Transform (st + sh), x0, y0, xr, yr
                sObj.BPoints.Add (xr + xoff), (yr + yoff)
            Next
        Case MsoShadowType.msoShadow8
            For i = 1 To oObj.BPoints.Count
                oObj.BPoints.GetPoint i, x0, y0
                Shadow8Transform (st + sh), x0, y0, xr, yr
                sObj.BPoints.Add (xr + xoff), (yr + yoff)
            Next
        Case MsoShadowType.msoShadow11
            For i = 1 To oObj.BPoints.Count
                oObj.BPoints.GetPoint i, x0, y0
                Shadow11Transform sl, (st + sh), x0, y0, xr, yr
                sObj.BPoints.Add (xr + xoff), (yr + yoff)
            Next
        Case MsoShadowType.msoShadow12
            For i = 1 To oObj.BPoints.Count
                oObj.BPoints.GetPoint i, x0, y0
                Shadow12Transform (sl + sw), (st + sh), x0, y0, xr, yr
                sObj.BPoints.Add (xr + xoff), (yr + yoff)
            Next
        Case MsoShadowType.msoShadow15
            For i = 1 To oObj.BPoints.Count
                oObj.BPoints.GetPoint i, x0, y0
                Shadow15Transform sl, (st + sh), x0, y0, xr, yr
                sObj.BPoints.Add (xr + xoff), (yr + yoff)
            Next
        Case MsoShadowType.msoShadow16
            For i = 1 To oObj.BPoints.Count
                oObj.BPoints.GetPoint i, x0, y0
                Shadow16Transform (sl + sw), (st + sh), x0, y0, xr, yr
                sObj.BPoints.Add (xr + xoff), (yr + yoff)
            Next
        Case MsoShadowType.msoShadow19
            For i = 1 To oObj.BPoints.Count
                oObj.BPoints.GetPoint i, x0, y0
                Shadow19Transform (sl + sw / 2), (st + sh), x0, y0, xr, yr
                sObj.BPoints.Add (xr + xoff), (yr + yoff)
            Next
        Case MsoShadowType.msoShadow20
            For i = 1 To oObj.BPoints.Count
                oObj.BPoints.GetPoint i, x0, y0
                sObj.BPoints.Add (x0 + xoff), _
                                 ((st + sh) * 2 - y0)
            Next
        'Case Else
            ' msoShadowMixed should be exported into images in Function
            ' Perform(). NOT HERE!!!
    End Select

    With sObj
        .PointsString = .BPoints.PrintString()
        .m_szFillColor = ShadowFillColor
        .m_szLineColor = ShadowLineColor

        .SetShapeType (oObj.GetShapeType())
        .m_lecDrawStyle = oObj.m_lecDrawStyle
        .LineStyle = oObj.LineStyle
        .LineWidth = oObj.LineWidth
        .arrowStyle = oObj.arrowStyle
        .arrowConfig = oObj.arrowConfig
        .IsClosedPolyline = oObj.IsClosedPolyline
    End With
End Sub

' do the point transform of shadow3
' bottom: bottom of the rotated bounding rectantle.
' x0, y0: original coordinate.
' xr, yr: results
Private Sub Shadow3Transform(bottom As Single, x0 As Single, y0 As Single, xr As Single, yr As Single)
    xr = x0 - (bottom - y0) * Tan(PI / 3) / 2
    yr = (y0 + bottom) / 2
End Sub

Private Sub Shadow4Transform(bottom As Single, x0 As Single, y0 As Single, xr As Single, yr As Single)
    xr = x0 + (bottom - y0) * Tan(PI / 3) / 2
    yr = (y0 + bottom) / 2
End Sub

' do the point transform of shadow7, vertical mirror of shadow3
Private Sub Shadow7Transform(bottom As Single, x0 As Single, y0 As Single, xr As Single, yr As Single)
    xr = x0 - (bottom - y0) * Tan(PI / 3) / 2
    yr = (bottom - y0) / 2 + bottom
End Sub

' do the point transform of shadow8, vertical mirror of shadow4
Private Sub Shadow8Transform(bottom As Single, x0 As Single, y0 As Single, xr As Single, yr As Single)
    xr = x0 + (bottom - y0) * Tan(PI / 3) / 2
    yr = (bottom - y0) / 2 + bottom
End Sub

' do the point transform of shadow11
' bottom: bottom of the rotated bounding rectantle.
' Leftmost: Left border of the rotated bounding rectangle
' x0, y0: original coordinate.
' xr, yr: results
Private Sub Shadow11Transform(leftmost As Single, bottom As Single, x0 As Single, y0 As Single, xr As Single, yr As Single)
    ' The transform follow these rules:
    ' a) shadow lines of all (parallel) vertical lines intersect at one certain Point:
    '     D (leftmost-d0, bottom-h0), here d0 = 119, h0 = 83.
    '    or: the shadow of point (x, Infinite) is D.
    ' b) lines through points and their shadows intersect as another certain Point:
    '     H (leftmost-d0, bottom)
    ' So, point(x0, y0)'s shadow (xr, yr) satisfy:
    '     xr = x0 - (x0 -leftmost + d0) *(bottom - y0)/(h0 + bottom - y0)
    '     yr = bottom - ((bottom - y0)  h0)/(bottom - y0 + h0)
    Dim d0 As Single, h0 As Single
    d0 = 119
    h0 = 83
    xr = x0 - (x0 - leftmost + d0) * (bottom - y0) / (h0 + bottom - y0)
    yr = bottom - ((bottom - y0) * h0) / (bottom - y0 + h0)
End Sub

' do the point transform of shadow15, vertical mirror of shadow11
Private Sub Shadow15Transform(leftmost As Single, bottom As Single, x0 As Single, y0 As Single, xr As Single, yr As Single)
    Dim d0 As Single, h0 As Single
    d0 = 119
    h0 = 83
    xr = x0 - (x0 - leftmost + d0) * (bottom - y0) / (h0 + bottom - y0)
    yr = bottom + ((bottom - y0) * h0) / (bottom - y0 + h0)
End Sub

' do the point transform of shadow12
' bottom: bottom of the rotated bounding rectantle.
' rightmost: right border of the rotated bounding rectangle
' x0, y0: original coordinate.
' xr, yr: results
Private Sub Shadow12Transform(rightmost As Single, bottom As Single, x0 As Single, y0 As Single, xr As Single, yr As Single)
    ' The transform follow these rules:
    ' a) shadow lines of all (parallel) vertical lines intersect at one certain Point:
    '     D (rightmost+d0, bottom-h0), here d0 = 119, h0 = 83.
    '    or: the shadow of point (x, Infinite) is D.
    ' b) lines through points and their shadows intersect as another certain Point:
    '     H (rightmost+d0, bottom)
    ' So, point(x0, y0)'s shadow (xr, yr) satisfy:
    '     xr = x0 + (rightmost + d0 -x0) *(bottom - y0)/(h0 + bottom - y0)
    '     yr = bottom - ((bottom - y0)  h0)/(bottom - y0 + h0)
    Dim d0 As Single, h0 As Single
    d0 = 119
    h0 = 83
    xr = x0 + (rightmost + d0 - x0) * (bottom - y0) / (h0 + bottom - y0)
    yr = bottom - ((bottom - y0) * h0) / (bottom - y0 + h0)
End Sub

' do the point transform of shadow16, vertical mirror of shadow12
Private Sub Shadow16Transform(rightmost As Single, bottom As Single, x0 As Single, y0 As Single, xr As Single, yr As Single)
    ' The transform follow these rules:
    ' a) shadow lines of all (parallel) vertical lines intersect at one certain Point:
    '     D (rightmost+d0, bottom-h0), here d0 = 119, h0 = 83.
    '    or: the shadow of point (x, Infinite) is D.
    ' b) lines through points and their shadows intersect as another certain Point:
    '     H (rightmost+d0, bottom)
    ' So, point(x0, y0)'s shadow (xr, yr) satisfy:
    '     xr = x0 + (rightmost + d0 -x0) *(bottom - y0)/(h0 + bottom - y0)
    '     yr = bottom - ((bottom - y0)  h0)/(bottom - y0 + h0)
    Dim d0 As Single, h0 As Single
    d0 = 119
    h0 = 83
    xr = x0 + (rightmost + d0 - x0) * (bottom - y0) / (h0 + bottom - y0)
    yr = bottom + ((bottom - y0) * h0) / (bottom - y0 + h0)
End Sub

' do the point transform of shadow19
' middle: horizonal middle point of the rotated bounding rectangle
' bottom: bottom of the rotated bounding rectantle.
' x0, y0: original coordinate.
' xr, yr: results
Private Sub Shadow19Transform(middle As Single, bottom As Single, x0 As Single, y0 As Single, xr As Single, yr As Single)
    ' The transform follow these rules:
    ' a) shadow lines of all (parallel) vertical lines intersect at one certain Point:
    '     D (middle, bottom-h0), here , h0 = 83.
    '    or: the shadow of point (x, Infinite) is D.
    ' b) lines through points and their shadows intersect as another certain Point:
    '     H (middle, bottom+h0)
    ' So, point(x0, y0)'s shadow (xr, yr) satisfy:
    '     xr = middle - 2 * h0 * ( middle - x0)/(bottom - y0 + 2h0)
    '     yr = bottom - ((bottom - y0) * h0)/(bottom - y0 + 2h0)
    Dim h0 As Single
    h0 = 83
    xr = middle - 2 * h0 * (middle - x0) / (bottom - y0 + 2 * h0)
    yr = bottom - ((bottom - y0) * h0) / (bottom - y0 + 2 * h0)
End Sub

Public Sub SetShadowStatus()
    Dim i As Long
    If HasGroupItem Then
        For i = 1 To GroupItemNum
            With GroupItems(i)
                .HasTextShadow = HasTextShadow
                .ShadowOffX = ShadowOffX
                .ShadowOffY = ShadowOffY
                .ShadowColor = ShadowColor
                .SetShadowStatus
            End With
        Next
    End If
End Sub

Private Function GetMaxFontSize(tr As TextRange) As Single
    Dim i As Long
    Dim c As TextRange
    Dim fntSize As Single

    If tr.length < 1 Then
        GetMaxFontSize = 0
        Exit Function
    End If
    GetMaxFontSize = tr.Characters(1).Font.Size
    For i = 2 To tr.length
        Set c = tr.Characters(i)
        Select Case AscW(c)
            Case 11, 13
            Case Else
                fntSize = c.Font.Size
                If fntSize > GetMaxFontSize Then
                    If (tr.Characters(i).Font.Subscript = msoTrue Or tr.Characters(i).Font.Superscript) Then
                        Dim off As Single
                        off = fntSize - GetMaxFontSize
                        If (off > (GetMaxFontSize / 2)) Then
                            GetMaxFontSize = GetMaxFontSize + off / 2
                        End If
                    Else
                        GetMaxFontSize = fntSize
                    End If
                End If
        End Select
    Next
    Set c = Nothing
End Function

' if this is the last paragraph, a linefeed should be added at the end of text range,
' this line feed should be removed before converting the text.
' "bRemoveLastChr" is true, if the line feed was added (in function ImportShapeAsText())
Private Sub ParseTextParagraph(sld As Slide, shp As Shape, iParagraphIndex As Long, ByRef bIsParaHead As Boolean, ByRef cntObj As Long, ByRef paraNum As Long, Optional bRemoveLastChr As Boolean = False)

    Dim txtSeg          As TextRange
    Dim start           As Long
    Dim chrLen          As Long
    Dim bReachedLineEnd As Boolean
    Dim bTabBegin       As Boolean
    Dim bIsFirstSeg     As Boolean
    Dim bSpecialChr     As Boolean
    Dim MaxFontSize     As Single
    
    Dim trPara As TextRange

    Dim tr As TextRange
    
#If COMPILE_VERSION = 2007 Then
    ' There is a member "Allcaps" in Font2. If "Allcaps" is true all
    ' characters are displayed as upper characters
    Dim tr2 As TextRange2
#End If

    Dim j As Long

    Set trPara = shp.TextFrame.TextRange.paragraphs(iParagraphIndex)
    
    If Len(trPara.text) = 0 Or _
       Len(trPara.text) = 1 And Asc(trPara.text) = 13 Then
        Exit Sub
    End If

    If trPara.ParagraphFormat.Alignment = ppAlignJustify Then
        SetObjectWarningMessage NOT_SUPPORTED_JUSTIFY, sld.slideNumber
    End If

    ' test if there is a bullet
    With trPara
        If .ParagraphFormat.Bullet.Visible = msoFalse Or .length = 0 _
            Or (.length = 1 And .text = Chr$(13) & Chr$(10)) Then
        Else
            cntObj = cntObj + 1
            If cntObj > GroupItemNum Then           ' ensure the array is large enough
                GroupItemNum = GroupItemNum + ITEM_INCREMENT
                ReDim Preserve GroupItems(1 To GroupItemNum) As aofShape
            End If

            MaxFontSize = GetMaxFontSize(trPara.Lines(1))
            Set GroupItems(cntObj) = New aofShape
            AddHyperlink GroupItems(cntObj)
            GroupItems(cntObj).ParseBullet shp, iParagraphIndex, trPara, paraNum, MaxFontSize   ' here paraNum is no longer useful
        End If

        ' remove the last linefeed that was added in "ImportShapeAsText"
        If bRemoveLastChr Then
            .Characters(.length, 1).Delete
        End If
    End With
    

    Set trPara = shp.TextFrame.TextRange.paragraphs(iParagraphIndex)
    Dim bAllCaps As Boolean
    For j = 1 To trPara.Lines.Count

        Set tr = trPara.Lines(j)
        MaxFontSize = GetMaxFontSize(tr)

        bIsFirstSeg = True
        start = 1
        Do      ' begin to convert text
            Dim fontFamily As String
            bAllCaps = False
            If g_lApplicationVersion = 2007 Then
#If COMPILE_VERSION = 2007 Then
                Set tr2 = shp.TextFrame2.TextRange.paragraphs(iParagraphIndex).Lines(j)
                Set txtSeg = FindTextSegment_2007(shp, iParagraphIndex, j, fontFamily, _
                                                  tr, tr2, start, chrLen, bReachedLineEnd, _
                                                  bTabBegin, bSpecialChr, bAllCaps)
#End If
            Else
                Set txtSeg = FindTextSegment(shp, iParagraphIndex, j, fontFamily, _
                                             tr, start, chrLen, bReachedLineEnd, _
                                             bTabBegin, bSpecialChr)
            End If

            
'            Set txtSeg = tr.Characters(start)
'            If start = tr.length Then
'                bReachedLineEnd = True
'            End If
'            chrLen = 1

            If chrLen <= 0 Then
                'Invisible = True
                If cntObj > 0 Then
                    GroupItems(cntObj).ClearItems
                End If
                Exit Do
'                Exit Sub
            End If

            With txtSeg
                If bSpecialChr Then
                    cntObj = cntObj + 1
                    If cntObj > GroupItemNum Then           ' ensure the array is large enough
                        GroupItemNum = GroupItemNum + ITEM_INCREMENT
                        ReDim Preserve GroupItems(1 To GroupItemNum) As aofShape
                    End If

                    If cntObj > 1 Then
                        GroupItems(cntObj - 1).ClearItems
                    End If

                    Set GroupItems(cntObj) = New aofShape
                    AddHyperlink GroupItems(cntObj)

                    GroupItems(cntObj).ImportTextRangeAsImage shp, txtSeg, MaxFontSize
                    GroupItems(cntObj).TextIndentLevel = txtSeg.IndentLevel
                    GroupItems(cntObj).ParaIndex = paraNum
                    SetObjectWarningMessage NOT_SUPPORTED_SPECIALCHAR, sld.slideNumber

                    bIsFirstSeg = True
                Else
                    If bIsFirstSeg Or (bTabBegin And txtSeg.text <> "") Then

                        If bTabBegin Then
                            SetObjectWarningMessage NOT_SUPPORTED_TABULATOR, sld.slideNumber
                        End If
    
                        cntObj = cntObj + 1
                        If cntObj > GroupItemNum Then           ' ensure the array is large enough
                            GroupItemNum = GroupItemNum + ITEM_INCREMENT
                            ReDim Preserve GroupItems(1 To GroupItemNum) As aofShape
                        End If

                        If cntObj > 1 Then
                            GroupItems(cntObj - 1).ClearItems
                        End If

                        Set GroupItems(cntObj) = New aofShape
                        AddHyperlink GroupItems(cntObj)
                        Dim spcBefore As Single: spcBefore = 0
                        
                        If g_lApplicationVersion = 2007 Then
                            Dim fRealFontHeight As Double: fRealFontHeight = 1
                            If j = 1 And iParagraphIndex > 1 Then
                                If shp.TextFrame.TextRange.paragraphs(iParagraphIndex).ParagraphFormat.LineRuleBefore Then
                                    If txtSeg.Font.NameAscii = "" Then
                                        txtSeg.Font.NameAscii = "Arial"
                                    End If
                                    Dim fAscent As Double: fAscent = CalculateTextAscent(txtSeg.Font.NameAscii, MaxFontSize, txtSeg.Font.Bold, txtSeg.Font.Italic)
                                    Dim fDescent As Double: fDescent = CalculateTextDescent(txtSeg.Font.NameAscii, MaxFontSize, txtSeg.Font.Bold, txtSeg.Font.Italic)
                                    fRealFontHeight = fAscent + fDescent
                                End If
                                spcBefore = shp.TextFrame.TextRange.paragraphs(iParagraphIndex).ParagraphFormat.SpaceBefore * fRealFontHeight
                            End If
                        End If
                        GroupItems(cntObj).ParseTextSegment sld, txtSeg, tr, paraNum, fontFamily, MaxFontSize, bAllCaps, spcBefore
                        StrSlideNumber = sld.slideNumber
                        GroupItems(cntObj).SetReplaceText StrDate, StrFooter, StrSlideNumber

                        bIsFirstSeg = False

                    Else
                        GroupItems(cntObj).InsertAsTextItem sld, txtSeg, fontFamily, bAllCaps
                    End If
                End If      'bSpecialChr
            End With
            
            start = start + chrLen
            
        Loop Until bReachedLineEnd
    Next

    If cntObj >= 1 Then
        GroupItems(cntObj).ClearItems
    End If

    If tr.length = 0 Then
        bIsParaHead = True
        paraNum = paraNum + 1
    ElseIf Asc(Mid(tr.text, tr.length, 1)) = 13 Then    ' a paragraph is ended by a linefeed
        bIsParaHead = True
        paraNum = paraNum + 1
    Else
        bIsParaHead = False
    End If

    Set tr = Nothing
End Sub

Public Sub ParseTextSegment(sld As Slide, txtSeg As TextRange, tr As TextRange, para As Long, _
                            fontFamily As String, maxFntSize As Single, bAllCaps As Boolean, spcBefore As Single)
  
    With txtSeg

        m_lecShapeType = LEC_SHAPETYPE_TEXT
        m_lecTextShapeType = LEC_TEXTSHAPETYPE_ATOM

        ParaIndex = para
        x = .BoundLeft
        
        If .Font.NameAscii = "" Then
            .Font.NameAscii = "Arial"
        End If
        Dim fAscent As Double: fAscent = CalculateTextAscent(.Font.NameAscii, maxFntSize, .Font.Bold, .Font.Italic)
        Dim fDescent As Double: fDescent = CalculateTextDescent(.Font.NameAscii, maxFntSize, .Font.Bold, .Font.Italic)

        
        Dim fRealFontHeight As Double: fRealFontHeight = fAscent + fDescent
        
        If g_lApplicationVersion = 2007 Then
            Dim spcWithin As Single: spcWithin = .ParagraphFormat.SpaceWithin
            If .ParagraphFormat.LineRuleWithin Then
                spcWithin = (.ParagraphFormat.SpaceWithin - 1) * 0.75 * fRealFontHeight
            Else
                spcWithin = (spcWithin - fRealFontHeight) * 0.75
            End If
            y = .BoundTop + fAscent + spcBefore + spcWithin
        Else
        Dim yDiff As Double
        yDiff = (.BoundHeight - fRealFontHeight) * (5 / 6)
        
        y = .BoundTop + fAscent + yDiff
        End If

        width = .BoundWidth
        height = .BoundHeight

        TextIndentLevel = .IndentLevel
        HasTextItem = True
        TextItemNum = 1

        If tr.length < 1 Then
            Exit Sub
        End If

        ReDim TextItems(1 To tr.length) As aofTextItem       ' reach the maximum

        Set TextItems(TextItemNum) = New aofTextItem
        AddHyperlinkToText TextItems(TextItemNum)
        TextItems(TextItemNum).Perform sld, txtSeg, fontFamily, bAllCaps
    End With
End Sub

Sub SetBlankText()
    m_lecShapeType = LEC_SHAPETYPE_TEXT
    HasTextItem = True
    TextItemNum = 1
    ReDim TextItems(1 To 1) As aofTextItem
    Set TextItems(1) = New aofTextItem
    AddHyperlinkToText TextItems(1)

End Sub

Private Function FindTextSegment(shp As Shape, iParagraphIndex As Long, iLine As Long, szFontFamily As String, ByVal tr As TextRange, start As Long, chrLen As Long, _
            bReachedLineEnd As Boolean, bTabBegin As Boolean, bSpecialChr As Boolean) As TextRange
    Dim i           As Long
    Dim firstFnt    As Font
    Dim curFnt      As Font
    Dim chrVal      As Long
    Dim bIsSpecial  As Boolean
    Dim curText     As TextRange
    Dim hyperlinkAddress As String
    Dim internLinkValue As String
    
    bTabBegin = False
    bReachedLineEnd = True

    Dim textLength As Long: textLength = tr.length
    If tr.Characters(textLength).text = Chr$(13) Or _
       tr.Characters(textLength).text = Chr$(11) Or _
       tr.Characters(textLength).text = Chr$(13) & Chr$(10) Then
        textLength = textLength - 1
    End If
    
    Dim bNoChr As Boolean: bNoChr = True
    For i = start To textLength
        If Asc(tr.Characters(i).text) <> 9 And Asc(tr.Characters(i).text) <> 11 Then      ' tabstop
            bNoChr = False
            Exit For
        Else
            bTabBegin = True
        End If
    Next

    If bNoChr Then          ' all the chars are tabstops
        'Set FindTextSegment = ""
        chrLen = 0
        Exit Function
    End If

    start = i

    If textLength >= start Then
        ' determine the first character
        Set curText = tr.Characters(start, 1)
        
       'chrVal = AscW(tr.Characters(start, 1).Text)      ' one character
        chrVal = AscW(curText.text)
        If curText.ActionSettings.Count >= ppMouseClick Then
            hyperlinkAddress = curText.ActionSettings.Item(ppMouseClick).Hyperlink.address
            internLinkValue = curText.ActionSettings.Item(ppMouseClick).Hyperlink.SubAddress
        End If

        If IsMathFont(curText) Then
            bSpecialChr = True
        Else
            bSpecialChr = False
        End If
        
        Dim fontFamily As String: fontFamily = ""
        Dim firstFontFamily As String: firstFontFamily = ""
        
        Set firstFnt = tr.Characters(start).Font
        
        Dim bFontIsSupported As Boolean
        bFontIsSupported = GetCorrectedFontfamily(shp, iParagraphIndex, iLine, tr, start, firstFontFamily)
        If (Not bFontIsSupported) Then
            bSpecialChr = True
        End If
        
        For i = start + 1 To textLength
            Set curText = tr.Characters(i, 1)
            With curText                'tr.Characters(i, 1)
                chrVal = AscW(.text)
                Set curFnt = .Font
            End With
            
            bIsSpecial = IsMathFont(curText)
            
            fontFamily = ""
            bFontIsSupported = GetCorrectedFontfamily(shp, iParagraphIndex, iLine, tr, i, fontFamily)
            If (Not bFontIsSupported) Then
                bIsSpecial = True
            End If
                
            If tr.Characters(i, 1).ActionSettings.Item(1).Hyperlink.address <> hyperlinkAddress Then
                bReachedLineEnd = False
                Exit For
            End If
            
            If tr.Characters(i, 1).ActionSettings.Item(1).Hyperlink.SubAddress <> internLinkValue Then
                bReachedLineEnd = False
                Exit For
            End If
            
            Dim bSameFont As Boolean
            bSameFont = IsSameFontsetting(firstFnt, curFnt, firstFontFamily, fontFamily)
            
            If (bIsSpecial <> bSpecialChr Or Not bSameFont) Then     ' segment end
                    bReachedLineEnd = False
                    Exit For
            Else
                If Not bSpecialChr Then                 ' ascii character, continue
                    If Not bSameFont Or chrVal = 9 Then   'Or Asc(tr.Characters(i).Text) = 9 Then
                        bReachedLineEnd = False
                        Exit For
                    End If
                End If
            End If
        Next
        chrLen = i - start
    Else
        chrLen = 1
    End If

    szFontFamily = firstFontFamily
    Set FindTextSegment = tr.Characters(start, chrLen)

End Function

#If COMPILE_VERSION = 2007 Then

Private Function FindTextSegment_2007(shp As Shape, iParagraphIndex As Long, iLine As Long, _
                                     szFontFamily As String, ByVal tr As TextRange, ByVal tr2 As TextRange2, _
                                     start As Long, chrLen As Long, bReachedLineEnd As Boolean, _
                                     bTabBegin As Boolean, bSpecialChr As Boolean, ByRef bAllCaps As Boolean) As TextRange
    
    
    bTabBegin = False
    bReachedLineEnd = True

    Dim textLength As Long: textLength = tr.length
    If tr.Characters(textLength).text = Chr$(13) Or _
       tr.Characters(textLength).text = Chr$(11) Or _
       tr.Characters(textLength).text = Chr$(13) & Chr$(10) Then
        textLength = textLength - 1
    End If
    
    Dim i As Long
    Dim bNoChr As Boolean: bNoChr = True
    For i = start To textLength
        If Asc(tr.Characters(i).text) <> 9 And Asc(tr.Characters(i).text) <> 11 Then      ' tabstop
            bNoChr = False
            Exit For
        Else
            bTabBegin = True
        End If
    Next

    If bNoChr Then          ' all the chars are tabstops
        'Set FindTextSegment = ""
        chrLen = 0
        Exit Function
    End If

    start = i

    Dim curText     As TextRange
    Dim curText2    As TextRange2
    Dim chrVal      As Long
    Dim hyperlinkAddress As String
    Dim internLinkValue As String
    Dim bIsSpecial  As Boolean
    
    If textLength >= start Then
        ' determine the first character
        Set curText = tr.Characters(start, 1)
        Set curText2 = tr2.Characters(start, 1)
        
       'chrVal = AscW(tr.Characters(start, 1).Text)      ' one character
        chrVal = AscW(curText.text)
        If curText.ActionSettings.Count >= ppMouseClick Then
            hyperlinkAddress = curText.ActionSettings.Item(ppMouseClick).Hyperlink.address
            internLinkValue = curText.ActionSettings.Item(ppMouseClick).Hyperlink.SubAddress
        End If

        If IsMathFont(curText) Then
            bSpecialChr = True
        Else
            bSpecialChr = False
        End If
        
        If Not TextIsSolidFilled(shp) Then
            bSpecialChr = True
        End If
        
        Dim fontFamily As String: fontFamily = ""
        Dim firstFontFamily As String: firstFontFamily = ""
        
        Dim firstFnt As Font
        Set firstFnt = tr.Characters(start).Font
        
        Dim firstFnt2 As Font2
        Set firstFnt2 = tr2.Characters(start).Font
        
        Dim bFontIsSupported As Boolean
        bFontIsSupported = GetCorrectedFontfamily(shp, iParagraphIndex, iLine, tr, start, firstFontFamily)
        If (Not bFontIsSupported) Then
            bSpecialChr = True
        End If
        
        Dim curFnt As Font
        Dim curFnt2 As Font2
        For i = start + 1 To textLength
            Set curText = tr.Characters(i, 1)
            Set curText2 = tr2.Characters(i, 1)
            
            chrVal = AscW(curText.text)
            Set curFnt = curText.Font
            
            Set curFnt2 = curText2.Font
            
            bIsSpecial = IsMathFont(curText)
            
            If Not TextIsSolidFilled(shp) Then
                bIsSpecial = True
            End If
            
            fontFamily = ""
            bFontIsSupported = GetCorrectedFontfamily(shp, iParagraphIndex, iLine, tr, i, fontFamily)
            If (Not bFontIsSupported) Then
                bIsSpecial = True
            End If
                
            If tr.Characters(i, 1).ActionSettings.Item(1).Hyperlink.address <> hyperlinkAddress Then
                bReachedLineEnd = False
                Exit For
            End If
            
            If tr.Characters(i, 1).ActionSettings.Item(1).Hyperlink.SubAddress <> internLinkValue Then
                bReachedLineEnd = False
                Exit For
            End If
            
            Dim bSameFont As Boolean
            bSameFont = IsSameFontsetting(firstFnt, curFnt, firstFontFamily, fontFamily)
            If bSameFont Then
                bSameFont = IsSameFontsetting_2007(firstFnt2, curFnt2, firstFontFamily, fontFamily)
            End If
            
            If (bIsSpecial <> bSpecialChr Or Not bSameFont) Then     ' segment end
                    bReachedLineEnd = False
                    Exit For
            Else
                If Not bSpecialChr Then                 ' ascii character, continue
                    If Not bSameFont Or chrVal = 9 Then   'Or Asc(tr.Characters(i).Text) = 9 Then
                        bReachedLineEnd = False
                        Exit For
                    End If
                End If
            End If
        Next
        chrLen = i - start
    Else
        chrLen = 1
    End If

    bAllCaps = tr2.Characters(start, 1).Font.Allcaps
    szFontFamily = firstFontFamily
    Set FindTextSegment_2007 = tr.Characters(start, chrLen)

End Function

#End If

#If COMPILE_VERSION = 2007 Then

Private Function TextIsSolidFilled(shp As Shape) As Boolean

    On Error Resume Next
    Dim bTextIsSolidFilled As Boolean: bTextIsSolidFilled = True
    
    With shp.TextFrame2.TextRange.Font
        If .Fill.Visible = msoTrue And (.Fill.Type = msoFillSolid Or .Fill.Type = msoFillBackground) And _
           .Line.Visible = msoFalse Then
            bTextIsSolidFilled = True
        Else
            bTextIsSolidFilled = False
        End If
    End With

    TextIsSolidFilled = bTextIsSolidFilled
    
End Function

#End If

Private Function GetCorrectedFontfamily(shp As Shape, iParagraphIndex As Long, iLine As Long, txtSeg As TextRange, start As Long, fontFamily As String) As Boolean

    Dim result As Boolean
    
    
    If FontSupportsCharacter(txtSeg, start) Then
        fontFamily = txtSeg.Characters(start).Font.NameAscii
        GetCorrectedFontfamily = True
        Exit Function
    End If

    
    Dim imagePath As String

    Dim tmpShape As Shape
    Set tmpShape = shp.Duplicate(1)

    On Error GoTo ExpError:
    
    Dim i As Long
    If iParagraphIndex > 1 Then
        For i = 1 To iParagraphIndex - 1
            tmpShape.TextFrame.TextRange.paragraphs(1).Delete
        Next
    End If
    
    If iLine > 1 Then
        For i = 1 To iLine - 1
            tmpShape.TextFrame.TextRange.paragraphs(1).Lines(1).Delete
        Next
    End If
    
    
    Dim iCorrectPos As Long: iCorrectPos = start
    If txtSeg.Characters(1).text <> tmpShape.TextFrame.TextRange.Characters(1).text Then
        i = 1
        Do While txtSeg.Characters(i).text = " " And _
                 Asc(tmpShape.TextFrame.TextRange.Characters(1).text) <> 9 And _
                 txtSeg.Characters(i).text <> tmpShape.TextFrame.TextRange.Characters(1).text
            
            iCorrectPos = iCorrectPos - 1
            i = i + 1
        Loop
    End If


    If start > 1 Then
        tmpShape.TextFrame.TextRange.Characters(1, iCorrectPos - 1).Delete
    End If

    Dim iCharLen As Long: iCharLen = 1
    Dim iTextLen As Long: iTextLen = tmpShape.TextFrame.TextRange.length()

    If iTextLen - iCharLen > 0 Then
        tmpShape.TextFrame.TextRange.Characters(1 + iCharLen, iTextLen - iCharLen).Delete
    End If


    With g_conversionOptions
        ImageFileName = .WBFilePath & .ImgFileNamePrefix & "_tmp_char" & .ExpTextSuffix

        tmpShape.Export ImageFileName, .ExpTextFormat
    End With

    tmpShape.Delete
    Set tmpShape = Nothing

    result = GetCorrectFontFamily(ImageFileName, fontFamily)

    If result = 0 Then
        GetCorrectedFontfamily = False
    Else
        GetCorrectedFontfamily = True
    End If
    
    Exit Function

ExpError:

'    If Err.Number = -2147467259 Then
'        g_conversionOptions.FailInfo = Err.Number 'Err.Description
'        'MsgBox Err.Description
'        g_conversionOptions.FailMsg = g_szMsgOverwriteImage & g_conversionOptions.WBFilePath & ImageFileName
'        g_conversionOptions.Failed = True
'    End If
    
    GetCorrectedFontfamily = False
    Exit Function

    
End Function


Private Function IsSpecialChr(val As Long) As Boolean

    On Error Resume Next
    
    Dim result As Boolean
    result = IsSpecialCharacter(val)
    
    If result Then
        IsSpecialChr = True
    Else
        IsSpecialChr = False
    End If
    
    On Error GoTo 0
    
'    Select Case val
'        Case 8364, 8218, 402, 8222, 8230, 8224, 8225, _
'             710, 8240, 352, 8249, 338, 381, 8216, _
'             8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, _
'             353, 8250, 339, 382, 376
'                 IsSpecialChr = False
'        Case Else
'            If val > 255 Or val < 0 Then
'                IsSpecialChr = True
'            Else
'                IsSpecialChr = False
'            End If
'    End Select
End Function

Private Function IsMathFont(tr As TextRange) As Boolean

    If InStr(1, tr.Font.Name, "Math", vbTextCompare) > 0 Then
        IsMathFont = True
    Else
        IsMathFont = False
    End If
    IsMathFont = False
End Function

Private Function IsSameFontsetting(fstFnt As Font, fnt As Font, szFirstFontFamily As String, szFontFamily As String) As Boolean
    
    Dim firstFontFamily As String
    If szFirstFontFamily = "" Then
        firstFontFamily = fstFnt.NameAscii
    Else
        firstFontFamily = szFirstFontFamily
    End If
    
    Dim fontFamily As String
    If szFontFamily = "" Then
        fontFamily = fnt.NameAscii
    Else
        fontFamily = szFontFamily
    End If
    
    If fstFnt.Bold <> fnt.Bold Or _
        fstFnt.Italic <> fnt.Italic Or _
        fstFnt.Underline <> fnt.Underline Or _
        fstFnt.Emboss <> fnt.Emboss Or _
        fstFnt.Shadow <> fnt.Shadow Or _
        fstFnt.color.RGB <> fnt.color.RGB Or _
        firstFontFamily <> fontFamily Or _
        fstFnt.Size <> fnt.Size Or _
        fstFnt.Subscript <> fnt.Subscript Or _
        fstFnt.Superscript <> fnt.Superscript Or _
        fstFnt.BaselineOffset <> fnt.BaselineOffset Then
            IsSameFontsetting = False
    Else
            IsSameFontsetting = True
    End If
    
End Function

#If COMPILE_VERSION = 2007 Then
Private Function IsSameFontsetting_2007(fstFnt As Font2, fnt As Font2, szFirstFontFamily As String, szFontFamily As String) As Boolean
    
    Dim firstFontFamily As String
    If szFirstFontFamily = "" Then
        firstFontFamily = fstFnt.NameAscii
    Else
        firstFontFamily = szFirstFontFamily
    End If
    
    Dim fontFamily As String
    If szFontFamily = "" Then
        fontFamily = fnt.NameAscii
    Else
        fontFamily = szFontFamily
    End If
    
    If fstFnt.Bold <> fnt.Bold Or _
       fstFnt.Italic <> fnt.Italic Or _
       firstFontFamily <> fontFamily Or _
       fstFnt.Size <> fnt.Size Or _
       fstFnt.Subscript <> fnt.Subscript Or _
       fstFnt.Superscript <> fnt.Superscript Or _
       fstFnt.BaselineOffset <> fnt.BaselineOffset Or _
       fstFnt.Caps <> fnt.Caps Or _
       fstFnt.Allcaps <> fnt.Allcaps Or _
       fstFnt.DoubleStrikeThrough <> fnt.DoubleStrikeThrough Or _
       fstFnt.Fill.Type <> fnt.Fill.Type Or _
       fstFnt.Glow.Radius <> fnt.Glow.Radius Or _
       fstFnt.Reflection.Type <> fnt.Reflection.Type Then
        IsSameFontsetting_2007 = False
    Else
        IsSameFontsetting_2007 = True
    End If
    
End Function
#End If

Sub ClearItems()
    If TextItemNum > 0 Then
        ReDim Preserve TextItems(1 To TextItemNum) As aofTextItem
    End If
End Sub

Sub InsertAsTextItem(sld As Slide, txtSeg As TextRange, fontFamily As String, bAllCaps As Boolean)
    TextItemNum = TextItemNum + 1
    Set TextItems(TextItemNum) = New aofTextItem
    AddHyperlinkToText TextItems(TextItemNum)
    TextItems(TextItemNum).Perform sld, txtSeg, fontFamily, bAllCaps
End Sub

Function BulletIsText(tr As TextRange) As Boolean
    With tr.ParagraphFormat.Bullet
        If .Visible = msoFalse Then
            BulletIsText = True
            Exit Function
        End If

        Select Case .Type
            Case ppBulletNumbered
                BulletIsText = True
            Case ppBulletPicture
                BulletIsText = False
            Case Else
                If IsSupportedFont(.Font) Then
                    BulletIsText = True
                Else
                    BulletIsText = False
                End If
        End Select
    End With
End Function

Private Function IsSupportedFont(ft As Font) As Boolean
    IsSupportedFont = True
    'Dim fname As String
    'fname = ft.NameAscii
    'If InStr(1, fname, "Times", vbTextCompare) > 0 Then
    '    IsSupportedFont = True
    'ElseIf InStr(1, fname, "Arial", vbTextCompare) > 0 Then
    '    IsSupportedFont = True
    'ElseIf InStr(1, fname, "Courier", vbTextCompare) > 0 Then
    '    IsSupportedFont = True
    'ElseIf InStr(1, fname, "Symbol", vbTextCompare) > 0 Then
    '    IsSupportedFont = True
    'Else
    '    IsSupportedFont = False
    'End If
End Function


Sub ParseBullet(shp As Shape, iParagraphIndex As Long, tr As TextRange, para As Long, maxFntSize As Single)
    
    If BulletIsText(tr) Then
        ParseBulletAsText shp, iParagraphIndex, tr, para, maxFntSize
        Exit Sub
    End If
    
    m_lecShapeType = LEC_SHAPETYPE_IMAGE
  
    m_bConvertToPNG = False
    ImportBulletAsImage shp, iParagraphIndex, tr, ImageFileName, maxFntSize
        
    x = tr.Parent.Parent.Left
    If g_lApplicationVersion = 2007 Then
        Dim spcBefore As Single: spcBefore = 0
        If iParagraphIndex > 1 Then
            Dim fRealFontHeight As Double: fRealFontHeight = 1
            If tr.ParagraphFormat.LineRuleBefore Then
                If tr.Font.NameAscii = "" Then
                    tr.Font.NameAscii = "Arial"
                End If
                Dim fAscent As Double: fAscent = CalculateTextAscent(tr.Font.NameAscii, maxFntSize, tr.Font.Bold, tr.Font.Italic)
                Dim fDescent As Double: fDescent = CalculateTextDescent(tr.Font.NameAscii, maxFntSize, tr.Font.Bold, tr.Font.Italic)
                fRealFontHeight = fAscent + fDescent
            End If
            spcBefore = tr.ParagraphFormat.SpaceBefore * fRealFontHeight
        End If
        y = tr.BoundTop + spcBefore
    Else
        y = tr.BoundTop '+ .Parent.MarginTop '+ SpcBefore
    End If
        
End Sub

Sub ParseBulletAsText(shp As Shape, iParagraphIndex As Long, tr As TextRange, para As Long, maxFntSize As Single)
    Dim fntSize     As Long
    Dim OffX        As Long
    Dim offY        As Long
    Dim tf          As TextFrame
    Dim boffx       As Long         ' the offset of bullet to the shape border

    m_lecShapeType = LEC_SHAPETYPE_TEXT
    m_lecTextShapeType = LEC_TEXTSHAPETYPE_BULLET

    ParaIndex = para
    TextItemNum = 1
    ReDim TextItems(1 To 1) As aofTextItem
    Set TextItems(1) = New aofTextItem

    ' we must do so because sometims the tr.ParagraphFormat.Bullet.Font.Size = -2
    fntSize = CLng(tr.ParagraphFormat.Bullet.RelativeSize _
                * maxFntSize)


    If fntSize <= 0 Then
        fntSize = maxFntSize
    End If
    
    Set tf = tr.Parent

    Dim tmpBullet As Shape
    Dim tmpStr As String
    ' in fact, if no indent, g_lIndentLevel = -2 (0xFFFFFFFE)
    ' PowerPoint support 5 indent levels.
    ' PowerPoint 2007 supports 9 indent levels.
    If ((tr.IndentLevel < 1 Or tr.IndentLevel > 5) And g_lApplicationVersion <> 2007) Or _
       ((tr.IndentLevel < 1 Or tr.IndentLevel > 9) And g_lApplicationVersion = 2007) Then
        OffX = 0
    Else
        'If g_lApplicationVersion = 2007 Then
            Dim tmpShape As Shape
            Set tmpShape = shp.Duplicate(1)
            Dim iDel As Long: iDel = 1
            Dim i As Long
            
            Dim paraCount As Long
            paraCount = tmpShape.TextFrame.TextRange.paragraphs.Count
            
            For i = 1 To paraCount
                If i <> iParagraphIndex Then
                    If (i + 1) <= paraCount Then
                        If (tmpShape.TextFrame.TextRange.paragraphs(iDel + 1).Characters(0, 1) = " ") Then
                            tmpShape.TextFrame.TextRange.paragraphs(iDel + 1).Characters(0, 1).Delete
                        End If
                    End If
                    tmpShape.TextFrame.TextRange.paragraphs(iDel).Delete
                Else
                    iDel = 2
                End If
            Next
                
            Dim firstMargin As Long
            Dim leftMargin As Long
            
            With tmpShape.TextFrame.Ruler.Levels(tr.IndentLevel)
                boffx = IIf(.firstMargin < .leftMargin, .firstMargin, .leftMargin)
                firstMargin = .firstMargin
                leftMargin = .leftMargin
            End With
            tmpShape.Delete
            Set tmpShape = Nothing
            
            Set tmpBullet = g_LecturnityDocument.m_tempSlide.Shapes.AddTextbox(msoTextOrientationHorizontal, 0, 0, 200, 100)
            
            With tmpBullet.TextFrame.TextRange
                .Font.Size = tr.ParagraphFormat.Bullet.Font.Size
                'If tr.ParagraphFormat.Bullet.UseTextFont = msoTrue Then
                    '.Font.Name = tr.ParagraphFormat.Bullet.Font.NameAscii
                'Else
                    '.Font.Name = tr.ParagraphFormat.Bullet.Font.Name
                'End If
                
'                If tr.ParagraphFormat.Bullet.Font.NameAscii = "" Then
'                    .Font.Name = "Arial"
'                Else
'                    .Font.Name = tr.ParagraphFormat.Bullet.Font.NameAscii
'                End If
                
                If g_lApplicationVersion = 2007 Then
                    .Font.Bold = msoFalse
                    .Font.Italic = msoFalse
                Else
                    .Font.Bold = tr.ParagraphFormat.Bullet.Font.Bold
                    .Font.Italic = tr.ParagraphFormat.Bullet.Font.Italic
                End If
                .Font.Underline = msoFalse
                
                Dim FontName As String
                With tr.ParagraphFormat.Bullet
                    If .UseTextFont = msoTrue Then
                        FontName = TextItems(1).GetFontFamily(tr.Characters(0).Font)
                    Else
                        If (tr.ParagraphFormat.Bullet.Type = ppBulletNumbered) Then
                            FontName = TextItems(1).GetFontFamily(.Font)
                        Else
                            FontName = TextItems(1).MLBFamily(.Font)
                        End If
                    End If
                End With
                .Font.Name = FontName
                
                If (tr.ParagraphFormat.Bullet.Type = ppBulletNumbered) Then
                    .text = TextItems(1).GetNumBulletString(tr.ParagraphFormat.Bullet)
                    width = .Characters(0, .Characters.length).BoundWidth
                Else
                    .text = ChrW(tr.ParagraphFormat.Bullet.Character)
                    width = .Characters(0, .Characters.length).BoundWidth
                End If
                
                
            End With
            
            tmpBullet.Delete
            Set tmpBullet = Nothing
             
            OffX = Abs(leftMargin - firstMargin)
            
            If (OffX < width) Then
                OffX = width
            End If
            
            OffX = -OffX
    'Else
    '    If tf.HorizontalAnchor <> msoAnchorCenter And _
    '            (tr.ParagraphFormat.Alignment = ppAlignLeft Or _
    '             tr.ParagraphFormat.Alignment = ppAlignJustify) Then
    '        ' if the text aligns to Left, we can get the bullet's absolut position.
    '        ' And we can always get the absolute position of the TextRange.
    '        ' So, in this case, OffX is accurate. Both Bullet position and Text Position
    '        ' are accurate.
    '
    '        boffx = IIf(tf.Ruler.Levels(tr.IndentLevel).firstMargin < tf.Ruler.Levels(tr.IndentLevel).leftMargin, _
    '            tf.Ruler.Levels(tr.IndentLevel).firstMargin, tf.Ruler.Levels(tr.IndentLevel).leftMargin)

    '        OffX = -tr.Font.Size
    '
    '    Else
    '        ' If the text aligns to right or middle, we can not get the bullets's absolut
    '        ' position. In this Case, OffX is the distance between the LeftMargin and FirstMargin,
    '        ' theoretically, the distance between the bullet and the first character.
    '        OffX = tf.Ruler.Levels(tr.IndentLevel).leftMargin - tf.Ruler.Levels(tr.IndentLevel).firstMargin

    '        If OffX > 0 Then
    '            OffX = -OffX
    '        End If

    '        ' But, if OffX < the "real width" of the bullet. The bullet and the text (in
    '        ' Assistant) may overlap each other.
    '        ' In PowerPoint, even if the OffX < the width of the bullet, the bullet and the text
    '        ' won't overlap each other, because the text are shifted to fit the bullet.
    '        ' For us, the problem is, we do not know the exact width of the bullet, so that
    '        ' we cannot avoid the possible overlapping.
    '        ' We suppose that the bullet width is 60% of its height:
    '
    '        Set tmpBullet = g_LecturnityDocument.m_tempSlide.Shapes.AddTextbox(msoTextOrientationHorizontal, 0, 0, 100, 100)
    '        With tmpBullet.TextFrame.TextRange
    '            tmpStr = ChrW(tr.ParagraphFormat.Bullet.Character)
    '            .text = tmpStr
    '            .Font.Size = tr.ParagraphFormat.Bullet.Font.Size
    '            If tr.ParagraphFormat.Bullet.UseTextFont = msoTrue Then
    '                .Font.Name = tr.ParagraphFormat.Bullet.Font.NameAscii
    '            Else
    '                .Font.Name = tr.ParagraphFormat.Bullet.Font.Name
    '            End If
    '            .Font.Bold = tr.ParagraphFormat.Bullet.Font.Bold
    '            .Font.Italic = tr.ParagraphFormat.Bullet.Font.Italic
    '            .Font.Underline = msoFalse
    '            If -OffX < .BoundWidth Then
    '                OffX = -.BoundWidth
    '            End If
    '        End With
    '        tmpBullet.Delete
    '        Set tmpBullet = Nothing
    '
    '        'If OffX >= -fntSize * 0.6 Then
    '        '    OffX = -fntSize * 0.6  ' shift Left the width of the bullet.
    '        'End If
    '        ' In brief, if the OffX > the width of the bullet, the positions are accurate,
    '        ' otherwise, the position is not accurate.
    '    End If
    'End If
    End If

    With tr

        x = .Characters(0, 1).BoundLeft + OffX
        'y = .BoundTop + .Font.Size

        If g_lApplicationVersion = 2007 Then
            If .Font.NameAscii = "" Then
                .Font.NameAscii = "Arial"
            End If
            Dim fAscent As Double: fAscent = CalculateTextAscent(.Font.NameAscii, maxFntSize, .Font.Bold, .Font.Italic)
            Dim fDescent As Double: fDescent = CalculateTextDescent(.Font.NameAscii, maxFntSize, .Font.Bold, .Font.Italic)
    
            Dim fRealFontHeight As Double: fRealFontHeight = fAscent + fDescent
            Dim spcWithin As Single: spcWithin = .ParagraphFormat.SpaceWithin
            If .ParagraphFormat.LineRuleWithin Then
                spcWithin = (.ParagraphFormat.SpaceWithin - 1) * 0.75 * fRealFontHeight
            Else
                spcWithin = (spcWithin - fRealFontHeight) * 0.75
            End If
            Dim spcBefore As Single: spcBefore = 0
            If iParagraphIndex > 1 Then
            If .ParagraphFormat.LineRuleBefore Then
                    spcBefore = .ParagraphFormat.SpaceBefore * fRealFontHeight
                Else
                    spcBefore = .ParagraphFormat.SpaceBefore
                End If
            End If
            y = .BoundTop + fAscent + spcBefore + spcWithin
        Else
            If .ParagraphFormat.LineRuleWithin Then
                ' the spacewithin depends on the max font size in the line.
                y = .BoundTop + .ParagraphFormat.SpaceWithin * maxFntSize   '.Font.Size
            Else
                y = .BoundTop + maxFntSize
        End If
        width = .BoundWidth
        End If

        height = .BoundHeight
        TextIndentLevel = .IndentLevel


    End With

    AddHyperlinkToText TextItems(1)
    
    TextItems(1).PerformAsBullet tr, fntSize, x, width

End Sub

Private Function GetBulletImageName(shp As Shape) As String
    On Error Resume Next
    Dim bulName As String
    With shp.TextFrame
        With .TextRange.ParagraphFormat.Bullet
            If .UseTextFont = msoTrue Then
                bulName = .Font.NameAscii
            Else
                bulName = .Font.Name
            End If
            bulName = bulName & "_" & (.Font.color.RGB) & "_" & .Character
        End With
        With .Ruler.Levels(.TextRange.IndentLevel)
            bulName = bulName & "_" & .firstMargin & "_" & .leftMargin
        End With
    End With

    bulName = bulName & "_" & CLng(shp.width) & "_" & CLng(shp.height)

    If shp.Shadow.Visible = msoTrue Then
        bulName = bulName & "_shd_" & shp.Shadow.Type
    Else
        bulName = bulName & "_noshd"
    End If

    bulName = bulName & g_conversionOptions.ExpImageSuffix

    GetBulletImageName = bulName
End Function

'
' Parse PowerPoint Shapes
'

Sub CalculateVerticesWithLineWidth(shp As Shape)

    With shp

        If shp.Line.Visible Then
            Dim fHalfLineWidth As Single: fHalfLineWidth = .Line.Weight / 2

            If VertNum = 5 Then
                Vert(1).x = .Left - fHalfLineWidth
                Vert(1).y = .Top - fHalfLineWidth
                Vert(2).x = .Left + .width + fHalfLineWidth
                Vert(2).y = .Top - fHalfLineWidth
                Vert(3).x = .Left + .width + fHalfLineWidth
                Vert(3).y = .Top + .height + fHalfLineWidth
                Vert(4).x = .Left - fHalfLineWidth
                Vert(4).y = .Top + .height + fHalfLineWidth
                Vert(5).x = .Left - fHalfLineWidth
                Vert(5).y = .Top - fHalfLineWidth
            End If
            
            x = .Left - fHalfLineWidth
            y = .Top - fHalfLineWidth
            width = .width + 2 * fHalfLineWidth
            height = .height + 2 * fHalfLineWidth
        End If
        
        NodesRotate .Rotation
    End With
End Sub


'
' Set shape as
'

'
' Unsorted
'
Sub PrintPointsString()
    NewSetBoundingPoints
    IsClosedPolyline = BPoints.IsClosed()
    PointsString = BPoints.PrintString()
End Sub

Sub NodesRotate(rotAng As Long)
    Dim c11     As Double
    Dim c12     As Double
    Dim c21     As Double
    Dim c22     As Double
    Dim d1      As Double
    Dim d2      As Double
    Dim ang     As Double

    Dim nx      As Double
'    Dim ny      As Double

    If rotAng = 0 Then
        Exit Sub
    End If

    ang = -rotAng * PI / 180
    c11 = Cos(ang)
    c12 = Sin(ang)
    c21 = -c12
    c22 = c11

    Dim x0      As Double
    Dim y0      As Double

    x0 = x + width / 2
    y0 = y + height / 2

    d1 = x0 - x0 * c11 - y0 * c12
    d2 = y0 - x0 * c21 - y0 * c22

    Dim i        As Long

    For i = 1 To VertNum
        With Vert(i)
            nx = .x
            .x = c11 * .x + c12 * .y + d1
            .y = c21 * nx + c22 * .y + d2
        End With
    Next

End Sub

Private Sub ReadNodes(shp As Shape)

    
    'Dim ndsNum  As Long
    
    On Error Resume Next
    
    'ndsNum = shp.Nodes.Count
    VertNum = UBound(shp.Vertices)
    
    If Err.Number <> 0 Then
        'ErrLog LEC_ERRORTYPE_POLYGONNONODES, "No Vertrics!"
    End If
    
    '    If ndsNum = 0 Then ' some freeforms have no Nodes, then read Vertices instead
    If VertNum = 0 Then
        'ErrLog LEC_ERRORTYPE_NONODES, "Polygon no vertices"
        Exit Sub
    End If
    
    HasVertices = True
    ReDim Vert(1 To VertNum) As aofNode

    Dim minx As Double: minx = shp.Vertices(1, 1)
    Dim maxx As Double: maxx = shp.Vertices(1, 1)
    Dim miny As Double: miny = shp.Vertices(1, 2)
    Dim maxy As Double: maxy = shp.Vertices(1, 2)
        
    Dim i As Long
    For i = 1 To VertNum    ' read the vertices and find the bounds of the vertices
        Vert(i).x = shp.Vertices(i, 1)
        Vert(i).y = shp.Vertices(i, 2)

        If Vert(i).x < minx Then
            minx = Vert(i).x
        ElseIf Vert(i).x > maxx Then
            maxx = Vert(i).x
        End If

        If Vert(i).y < miny Then
            miny = Vert(i).y
        ElseIf Vert(i).y > maxy Then
            maxy = Vert(i).y
        End If

        Vert(i).SegType = shp.Nodes(i).SegmentType     ' error may raise here (harmless)
    Next

    Err.Clear       ' clear errors

    Dim xx As Double: xx = maxx - minx        ' actual width
    Dim yy As Double: yy = maxy - miny        ' actual height

    Dim ratw    As Double
    Dim rath    As Double
    If Abs(xx) < 0.000001 Then
        ratw = 1
    Else
        ratw = shp.width / xx
    End If
    
    If Abs(yy) < 0.000001 Then
        rath = 1
    Else
        rath = shp.height / yy
    End If
    
    Dim shftx   As Double: shftx = shp.Left - minx * ratw
    Dim shfty   As Double: shfty = shp.Top - miny * rath

    If Abs(ratw - 1) > 0.0005 Or Abs(rath - 1) > 0.0005 _
        Or Abs(shftx) > 0.001 Or Abs(shfty) > 0.001 Then
        For i = 1 To VertNum
            Vert(i).x = Vert(i).x * ratw + shftx
            Vert(i).y = Vert(i).y * rath + shfty
        Next
    End If
    
        FlipNodes Vert, VertNum, shp
        'NodesRotate shp.Rotation    ' moved to setpolygon
'    Else
'       Read from Nodes in ver 2.095 ~ 2.096
'    End If

End Sub

Sub SetSize(shp As Shape)
    On Error GoTo SetSizeError
    x = shp.Left
    y = shp.Top
    width = shp.width
    height = shp.height
    
    Exit Sub
SetSizeError:
    x = 0
    y = 0
    width = 0
    height = 0
    Exit Sub
End Sub

Function ImageIsEmpty(shp As Shape) As Boolean

    On Error GoTo GetSizeError
    
    ImageIsEmpty = False
    
    If m_bShpHas3D Or m_bShpHasShadow Then
        'width and height of the image are not equal with width and height of shape
        ImageIsEmpty = False
    ElseIf shp.width = 0 Or shp.height = 0 Then
        ImageIsEmpty = True
    End If
    
    Exit Function
    
GetSizeError:
    ImageIsEmpty = False
    
End Function

Private Sub SetVerticesCurvedDownArrow(shp As Shape)
    Dim r1 As Single
    Dim r2 As Single
    Dim r3 As Single
    Dim wstr As Double      ' width of the strip
    Dim xoff As Double      ' s offset of the strip

    Dim dest As aofNode, A As aofNode, b As aofNode, c As aofNode, d As aofNode, pntNum As Long, th As Long
    Dim i As Long, t As Double, aw As Single, j As Long
    Dim num1 As Long

    On Error Resume Next
    r1 = shp.Adjustments(1)     ' upper side of the arrow
    If Err.Number <> 0 Then
        r1 = 0.6
    End If
    r2 = shp.Adjustments(2)     ' bottom side of the arrow neck
    If Err.Number <> 0 Then
        r2 = 0.9
    End If
    r3 = shp.Adjustments(3)     ' arrow size
    If Err.Number <> 0 Then
        r3 = 0.3333333
    End If

    wstr = shp.width * (2 * r2 - r1 - 1)
    xoff = shp.width * (r1 - r2 + 1) / 2

    With shp            ' arrow part
        A.x = .Left + xoff + wstr
        A.y = .Top
        b.x = A.x + xoff / 2
        b.y = A.y
        c.x = .Left + .width * r2
        c.y = .Top + .height / 2
        d.x = c.x
        d.y = .Top + .height

        pntNum = IIf(.height > xoff, xoff, .height)
        ReDim v(1 To pntNum + 1, 1 To 2) As Double

        th = .Top + .height * r3        ' top of arrow head
        aw = .width * (1 - r2)         ' the width of arrow shoulder.
        For i = 1 To pntNum
            t = 1# * i / pntNum
            bezier dest, t, A, b, c, d
            If dest.y > th Then
                j = i - 1               ' number of points
                Exit For
            Else
                v(i, 1) = dest.x
                v(i, 2) = dest.y
            End If
        Next

        num1 = 2 * j + 6
        InitVertices num1 + 9

        Vert(1).x = .Left + xoff
        Vert(1).y = .Top
        Vert(2).x = Vert(1).x + wstr
        Vert(2).y = .Top

        For i = 1 To j             ' bottom edge of the strip
            Vert(i + 2).x = v(i, 1)
            Vert(i + 2).y = v(i, 2)
        Next

        ' arrow
        Vert(j + 3).x = Vert(j + 2).x + aw
        Vert(j + 3).y = Vert(j + 2).y
        Vert(j + 4).x = .Left + .width * (1 + r1) / 2
        Vert(j + 4).y = .Top + .height
        Vert(j + 5).x = Vert(j + 2).x - wstr - aw
        Vert(j + 5).y = Vert(j + 2).y

        For i = 1 To j             ' top edge of the strip
            Vert(j + 5 + i).x = v(j + 1 - i, 1) - wstr
            Vert(j + 5 + i).y = v(j + 1 - i, 2)
        Next

        Vert(num1) = Vert(1)
        Erase v

        Vert(num1 + 1).x = .Left + xoff
        Vert(num1 + 1).y = .Top
        Vert(num1 + 2).x = Vert(num1 + 1).x + wstr
        Vert(num1 + 2).y = Vert(num1 + 1).y
        Vert(num1 + 2).SegType = msoSegmentCurve
        Vert(num1 + 3).x = Vert(num1 + 2).x - xoff / 2
        Vert(num1 + 3).y = Vert(num1 + 2).y
        Vert(num1 + 3).SegType = msoSegmentCurve
        Vert(num1 + 4).x = .Left + wstr
        Vert(num1 + 4).y = .Top + .height / 2
        Vert(num1 + 4).SegType = msoSegmentCurve
        Vert(num1 + 5).x = Vert(num1 + 4).x
        Vert(num1 + 5).y = .Top + .height
        Vert(num1 + 6).x = .Left
        Vert(num1 + 6).y = .Top + .height
        Vert(num1 + 6).SegType = msoSegmentCurve
        Vert(num1 + 7).x = .Left
        Vert(num1 + 7).y = Vert(num1 + 4).y
        Vert(num1 + 7).SegType = msoSegmentCurve
        Vert(num1 + 8).x = .Left + xoff / 2
        Vert(num1 + 8).y = .Top
        Vert(num1 + 8).SegType = msoSegmentCurve
        Vert(num1 + 9) = Vert(num1 + 1)
   End With

End Sub

Private Sub ParseCurvedDownArrow(shp As Shape)
    ParseCurvedRightArrow shp
End Sub
Private Sub SetVerticesCurvedUpArrow(shp As Shape)
    Dim r1 As Single
    Dim r2 As Single
    Dim r3 As Single
    Dim wstr As Double      ' width of the strip
    Dim xoff As Double      ' s offset of the strip
    Dim dest As aofNode, A As aofNode, b As aofNode, c As aofNode, d As aofNode, pntNum As Long, th As Long
    Dim i As Long, t As Double, aw As Single, j As Long
    Dim num1 As Long

    On Error Resume Next
    r1 = shp.Adjustments(1)     ' upper side of the arrow
    If Err.Number <> 0 Then
        r1 = 0.6
    End If
    r2 = shp.Adjustments(2)     ' bottom side of the arrow neck
    If Err.Number <> 0 Then
        r2 = 0.9
    End If
    r3 = shp.Adjustments(3)     ' arrow size
    If Err.Number <> 0 Then
        r3 = 0.3333333
    End If

    wstr = shp.width * (2 * r2 - r1 - 1)
    xoff = shp.width * (r1 - r2 + 1) / 2

    With shp            ' arrow part
        A.x = .Left + xoff + wstr
        A.y = .Top + .height
        b.x = A.x + xoff / 2
        b.y = A.y
        c.x = .Left + .width * r2
        c.y = .Top + .height / 2
        d.x = c.x
        d.y = .Top

        pntNum = IIf(.height > xoff, xoff, .height)
        ReDim v(1 To pntNum + 1, 1 To 2) As Double

        th = .Top + .height * r3        ' bottom of arrow head
        aw = .width * (1 - r2)         ' the width of arrow shoulder.
        For i = 1 To pntNum
            t = 1# * i / pntNum
            bezier dest, t, A, b, c, d
            If dest.y < th Then
                j = i - 1               ' number of points
                Exit For
            Else
                v(i, 1) = dest.x
                v(i, 2) = dest.y
            End If
        Next

        num1 = 2 * j + 6
        InitVertices num1 + 9

        Vert(1).x = .Left + xoff
        Vert(1).y = .Top + .height
        Vert(2).x = Vert(1).x + wstr
        Vert(2).y = .Top + .height

        For i = 1 To j             ' bottom edge of the strip
            Vert(i + 2).x = v(i, 1)
            Vert(i + 2).y = v(i, 2)
        Next

        ' arrow
        Vert(j + 3).x = Vert(j + 2).x + aw
        Vert(j + 3).y = Vert(j + 2).y
        Vert(j + 4).x = .Left + .width * (1 + r1) / 2
        Vert(j + 4).y = .Top
        Vert(j + 5).x = Vert(j + 2).x - wstr - aw
        Vert(j + 5).y = Vert(j + 2).y

        For i = 1 To j             ' top edge of the strip
            Vert(j + 5 + i).x = v(j + 1 - i, 1) - wstr
            Vert(j + 5 + i).y = v(j + 1 - i, 2)
        Next

        Vert(num1) = Vert(1)
        Erase v

        Vert(num1 + 1).x = .Left + xoff
        Vert(num1 + 1).y = .Top + .height
        Vert(num1 + 2).x = Vert(num1 + 1).x + wstr
        Vert(num1 + 2).y = Vert(num1 + 1).y
        Vert(num1 + 2).SegType = msoSegmentCurve
        Vert(num1 + 3).x = Vert(num1 + 2).x - xoff / 2
        Vert(num1 + 3).y = Vert(num1 + 2).y
        Vert(num1 + 3).SegType = msoSegmentCurve
        Vert(num1 + 4).x = .Left + wstr
        Vert(num1 + 4).y = .Top + .height / 2
        Vert(num1 + 4).SegType = msoSegmentCurve
        Vert(num1 + 5).x = Vert(num1 + 4).x
        Vert(num1 + 5).y = .Top
        Vert(num1 + 6).x = .Left
        Vert(num1 + 6).y = .Top
        Vert(num1 + 6).SegType = msoSegmentCurve
        Vert(num1 + 7).x = .Left
        Vert(num1 + 7).y = Vert(4).y
        Vert(num1 + 7).SegType = msoSegmentCurve
        Vert(num1 + 8).x = .Left + xoff / 2
        Vert(num1 + 8).y = .Top + .height
        Vert(num1 + 8).SegType = msoSegmentCurve
        Vert(num1 + 9) = Vert(num1 + 1)
   End With
End Sub

Private Sub ParseCurvedUpArrow(shp As Shape)
    ParseCurvedLeftArrow shp
End Sub

Private Sub SetVerticesCurvedLeftArrow(shp As Shape)
    Dim r1 As Single
    Dim r2 As Single
    Dim r3 As Single
    Dim wstr As Double      ' width of the strip
    Dim yoff As Double      ' y offset of the strip

    Dim dest As aofNode, A As aofNode, b As aofNode, c As aofNode, d As aofNode, pntNum As Long, th As Long
    Dim i As Long, t As Double, aw As Single, j As Long
    Dim num1 As Long

    On Error Resume Next
    r1 = shp.Adjustments(1)     ' upper side of the arrow
    If Err.Number <> 0 Then
        r1 = 0.6
    End If
    r2 = shp.Adjustments(2)     ' bottom side of the arrow neck
    If Err.Number <> 0 Then
        r2 = 0.9
    End If
    r3 = shp.Adjustments(3)     ' arrow size
    If Err.Number <> 0 Then
        r3 = 0.3333333
    End If

    wstr = shp.height * (2 * r2 - r1 - 1)
    yoff = shp.height * (r1 - r2 + 1) / 2

    With shp            ' arrow part
        A.x = .Left + .width
        A.y = .Top + yoff + wstr
        b.x = .Left + .width
        b.y = A.y + yoff / 2
        c.x = .Left + .width / 2
        c.y = .Top + .height * r2
        d.x = .Left
        d.y = c.y

        pntNum = IIf(.width > yoff, yoff, .width)
        ReDim v(1 To pntNum + 1, 1 To 2) As Double

        th = .Left + .width * r3        ' right side of arrow head
        aw = .height * (1 - r2)         ' the width of arrow shoulder.
        For i = 1 To pntNum
            t = 1# * i / pntNum
            bezier dest, t, A, b, c, d
            If dest.x < th Then
                j = i - 1               ' number of points
                Exit For
            Else
                v(i, 1) = dest.x
                v(i, 2) = dest.y
            End If
        Next

        num1 = 2 * j + 6
        InitVertices num1 + 9

        Vert(1).x = .Left + .width
        Vert(1).y = .Top + yoff
        Vert(2).x = .Left + .width
        Vert(2).y = Vert(1).y + wstr

        For i = 1 To j             ' bottom edge of the strip
            Vert(i + 2).x = v(i, 1)
            Vert(i + 2).y = v(i, 2)
        Next

        ' arrow
        Vert(j + 3).x = Vert(j + 2).x
        Vert(j + 3).y = Vert(j + 2).y + aw
        Vert(j + 4).x = .Left
        Vert(j + 4).y = .Top + .height * (1 + r1) / 2
        Vert(j + 5).x = Vert(j + 3).x
        Vert(j + 5).y = Vert(j + 2).y - wstr - aw

        For i = 1 To j             ' top edge of the strip
            Vert(j + 5 + i).x = v(j + 1 - i, 1)
            Vert(j + 5 + i).y = v(j + 1 - i, 2) - wstr
        Next

        Vert(num1) = Vert(1)
        Erase v

        ' darker part of the strip
        Vert(num1 + 1).x = .Left + .width
        Vert(num1 + 1).y = .Top + yoff
        Vert(num1 + 2).x = Vert(num1 + 1).x
        Vert(num1 + 2).y = Vert(num1 + 1).y + wstr
        Vert(num1 + 2).SegType = msoSegmentCurve
        Vert(num1 + 3).x = Vert(num1 + 2).x
        Vert(num1 + 3).y = Vert(num1 + 2).y - yoff / 2
        Vert(num1 + 3).SegType = msoSegmentCurve
        Vert(num1 + 4).x = .Left + .width / 2
        Vert(num1 + 4).y = .Top + wstr
        Vert(num1 + 4).SegType = msoSegmentCurve
        Vert(num1 + 5).x = .Left
        Vert(num1 + 5).y = Vert(num1 + 4).y
        Vert(num1 + 6).x = Vert(num1 + 5).x
        Vert(num1 + 6).y = .Top
        Vert(num1 + 6).SegType = msoSegmentCurve
        Vert(num1 + 7).x = Vert(num1 + 4).x
        Vert(num1 + 7).y = .Top
        Vert(num1 + 7).SegType = msoSegmentCurve
        Vert(num1 + 8).x = .Left + .width
        Vert(num1 + 8).y = .Top + yoff / 2
        Vert(num1 + 8).SegType = msoSegmentCurve
        Vert(num1 + 9) = Vert(num1 + 1)
   End With
End Sub

Private Sub ParseCurvedLeftArrow(shp As Shape)
    Dim colorDark As String ' color of the darker part of the strip
    Dim colorNormal As String
    Dim colorDumm As String

    NewRotateNodes shp
    SetGraphstyle shp

    If m_lecDrawStyle > LEC_DRAWSTYLE_OUTLINE Then
        SetRelatedColors shp.Fill.ForeColor, colorDumm, colorDumm, colorDark, colorDumm
        If shp.Fill.transparency = 1 Then
            colorNormal = "none"
        Else
            colorNormal = GetARGBColorString(shp.Fill.transparency, shp.Fill.ForeColor)
        End If
    Else
        colorDark = "none"
        colorNormal = "none"
    End If

    AddGroupItem    ' the arrow part
    With GroupItems(GroupItemNum)
        .SetShapeType (LEC_SHAPETYPE_POLYGON)
        .SetGraphstyle shp
        .m_szFillColor = colorNormal
        .InitVerts 1, VertNum - 9, Vert, True
        .PrintPointsString
    End With

    AddGroupItem    ' darker part of the strip, the last 9 vertices
    With GroupItems(GroupItemNum)
        .SetShapeType (LEC_SHAPETYPE_POLYGON)
        .SetGraphstyle shp
        .m_szFillColor = colorDark
        .InitVerts VertNum - 8, 9, Vert, True
        .PrintPointsString
    End With

    m_lecShapeType = LEC_SHAPETYPE_USERDEFINEDGROUP

End Sub

Private Sub SetVerticesCurvedRightArrow(shp As Shape)
    Dim r1 As Single
    Dim r2 As Single
    Dim r3 As Single
    Dim wstr As Double      ' width of the strip
    Dim yoff As Double      ' y offset of the strip
    Dim dest As aofNode, A As aofNode, b As aofNode, c As aofNode, d As aofNode, pntNum As Long, th As Long
    Dim i As Long, t As Double, aw As Single, j As Long
    Dim num1 As Long

    On Error Resume Next
    r1 = shp.Adjustments(1)     ' upper side of the arrow
    If Err.Number <> 0 Then
        r1 = 0.6
    End If
    r2 = shp.Adjustments(2)     ' bottom side of the arrow neck
    If Err.Number <> 0 Then
        r2 = 0.9
    End If
    r3 = shp.Adjustments(3)     ' arrow size
    If Err.Number <> 0 Then
        r3 = 0.6666667
    End If

    wstr = shp.height * (2 * r2 - r1 - 1)
    yoff = shp.height * (r1 - r2 + 1) / 2

    With shp            ' arrow part
        A.x = .Left
        A.y = .Top + yoff + wstr
        b.x = .Left
        b.y = A.y + yoff / 2
        c.x = .Left + .width / 2
        c.y = .Top + .height * r2
        d.x = .Left + .width
        d.y = c.y

        pntNum = IIf(.width > yoff, yoff, .width)
        ReDim v(1 To pntNum + 1, 1 To 2) As Double

        th = .Left + .width * r3        ' Left side of arrow head
        aw = .height * (1 - r2)         ' the width of arrow shoulder.
        For i = 1 To pntNum
            t = 1# * i / pntNum
            bezier dest, t, A, b, c, d
            If dest.x > th Then
                j = i - 1
                Exit For
            Else
                v(i, 1) = dest.x
                v(i, 2) = dest.y
            End If
        Next

        ' The arrow part has 2*j+6 vertices, the dark strip part has 9 vertices.
        num1 = 2 * j + 6
        ' IMPORTANT:
        ' In fact, the dark strip part is beneath the arrow part.
        ' So, in ParseCurvedRightArrow(), the last 9 vertices should be assigned
        ' to the first groupitem, the leading others should be assigned to the
        ' second.
        InitVertices num1 + 9

        Vert(1).x = .Left
        Vert(1).y = .Top + yoff
        Vert(2).x = .Left
        Vert(2).y = Vert(1).y + wstr

        For i = 1 To j             ' bottom edge of the strip
            Vert(i + 2).x = v(i, 1)
            Vert(i + 2).y = v(i, 2)
        Next

        ' arrow
        Vert(j + 3).x = Vert(j + 2).x
        Vert(j + 3).y = Vert(j + 2).y + aw
        Vert(j + 4).x = .Left + .width
        Vert(j + 4).y = .Top + .height * (1 + r1) / 2
        Vert(j + 5).x = Vert(j + 3).x
        Vert(j + 5).y = Vert(j + 2).y - wstr - aw

        For i = 1 To j             ' top edge of the strip
            Vert(j + 5 + i).x = v(j + 1 - i, 1)
            Vert(j + 5 + i).y = v(j + 1 - i, 2) - wstr
        Next

        Vert(num1) = Vert(1)
        Erase v

        ' darker part of the strip has 9 vertices
        Vert(num1 + 1).x = .Left
        Vert(num1 + 1).y = .Top + yoff
        Vert(num1 + 2).x = .Left
        Vert(num1 + 2).y = Vert(num1 + 1).y + wstr
        Vert(num1 + 2).SegType = msoSegmentCurve
        Vert(num1 + 3).x = .Left
        Vert(num1 + 3).y = Vert(num1 + 2).y - yoff / 2
        Vert(num1 + 3).SegType = msoSegmentCurve
        Vert(num1 + 4).x = .Left + .width / 2
        Vert(num1 + 4).y = .Top + wstr
        Vert(num1 + 4).SegType = msoSegmentCurve
        Vert(num1 + 5).x = .Left + .width
        Vert(num1 + 5).y = Vert(num1 + 4).y
        Vert(num1 + 6).x = Vert(num1 + 5).x
        Vert(num1 + 6).y = .Top
        Vert(num1 + 6).SegType = msoSegmentCurve
        Vert(num1 + 7).x = Vert(num1 + 4).x
        Vert(num1 + 7).y = .Top
        Vert(num1 + 7).SegType = msoSegmentCurve
        Vert(num1 + 8).x = .Left
        Vert(num1 + 8).y = .Top + yoff / 2
        Vert(num1 + 8).SegType = msoSegmentCurve
        Vert(num1 + 9) = Vert(num1 + 1)
   End With

End Sub
Private Sub ParseCurvedRightArrow(shp As Shape)
    Dim colorDark As String ' color of the darker part of the strip
    Dim colorNormal As String
    Dim colorDumm As String

    NewRotateNodes shp
    SetGraphstyle shp

    If m_lecDrawStyle > LEC_DRAWSTYLE_OUTLINE Then
        SetRelatedColors shp.Fill.ForeColor, colorDumm, colorDumm, colorDark, colorDumm
        colorNormal = GetRGBColorString(shp.Fill.ForeColor)
    Else
        colorDark = "none"
        colorNormal = "none"
    End If

    AddGroupItem    ' darker part of the strip, the last 9 vertices
    With GroupItems(GroupItemNum)
        .SetShapeType (LEC_SHAPETYPE_POLYGON)
        .SetGraphstyle shp
        .m_szFillColor = colorDark
        .InitVerts VertNum - 8, 9, Vert, True
        .PrintPointsString
    End With

    AddGroupItem    ' the arrow part
    With GroupItems(GroupItemNum)
        .SetShapeType (LEC_SHAPETYPE_POLYGON)
        .SetGraphstyle shp
        .m_szFillColor = colorNormal
        .InitVerts 1, VertNum - 9, Vert, True
        .PrintPointsString
    End With

    m_lecShapeType = LEC_SHAPETYPE_USERDEFINEDGROUP

End Sub

Private Sub SetVerticesMoon(shp As Shape)
    Dim ratio As Single

    InitVertices 13
    With shp
        On Error Resume Next
        ratio = shp.Adjustments(1)
        If Err.Number <> 0 Then
            ratio = 0.5
        End If
        Vert(1).x = .Left + .width
        Vert(1).y = .Top
        Vert(1).SegType = msoSegmentCurve
        Vert(2).x = .Left + .width / 2
        Vert(2).y = .Top
        Vert(2).SegType = msoSegmentCurve
        Vert(3).x = .Left
        Vert(3).y = .Top + .height / 4
        Vert(3).SegType = msoSegmentCurve
        Vert(4).x = .Left
        Vert(4).y = .Top + .height / 2
        Vert(4).SegType = msoSegmentCurve
        Vert(5).x = .Left
        Vert(5).y = .Top + .height * 0.75
        Vert(5).SegType = msoSegmentCurve
        Vert(6).x = Vert(2).x
        Vert(6).y = .Top + .height

        Vert(7).x = Vert(1).x
        Vert(7).y = Vert(6).y
        Vert(7).SegType = msoSegmentCurve
        Vert(8).x = .Left + (1 + ratio) * .width / 2
        Vert(8).y = .Top + .height * (1 - ratio / 4)
        Vert(8).SegType = msoSegmentCurve
        Vert(9).x = .Left + .width * ratio
        Vert(9).y = Vert(5).y
        Vert(9).SegType = msoSegmentCurve
        Vert(10).x = Vert(9).x
        Vert(10).y = Vert(4).y
        Vert(10).SegType = msoSegmentCurve
        Vert(11).x = Vert(10).x
        Vert(11).y = Vert(3).y
        Vert(11).SegType = msoSegmentCurve
        Vert(12).x = Vert(8).x
        Vert(12).y = .Top + .height * ratio / 4
        Vert(12).SegType = msoSegmentCurve
        Vert(13) = Vert(1)
    End With
End Sub

Private Sub SetVerticesLightningBolt(shp As Shape)
    InitVertices 12
    With shp
        Vert(1).x = .Left
        Vert(1).y = .Top + .height * 0.18
        Vert(2).x = .Left + .width * 0.395
        Vert(2).y = .Top
        Vert(3).x = .Left + .width * 0.6
        Vert(3).y = .Top + .height * 0.285
        Vert(4).x = .Left + .width * 0.514
        Vert(4).y = .Top + .height * 0.3185
        Vert(5).x = .Left + .width * 0.77
        Vert(5).y = .Top + .height * 0.5575
        Vert(6).x = .Left + .width * 0.6875
        Vert(6).y = .Top + .height * 0.602
        Vert(7).x = .Left + .width
        Vert(7).y = .Top + .height
        Vert(8).x = .Left + .width * 0.465
        Vert(8).y = .Top + .height * 0.695
        Vert(9).x = .Left + .width * 0.567
        Vert(9).y = .Top + .height * 0.644
        Vert(10).x = .Left + .width * 0.236
        Vert(10).y = .Top + .height * 0.452
        Vert(11).x = .Left + .width * 0.353
        Vert(11).y = .Top + .height * 0.39
        Vert(12) = Vert(1)
    End With
End Sub
Private Sub SetVerticesSmileyFace(shp As Shape)
    Dim n As Long
    Dim ratio   As Single
    Dim ratioMouth As Single

    On Error Resume Next
    ratioMouth = 0.7645833
    ratio = shp.Adjustments(1)
    If Err.Number <> 0 Then
        ratio = 0.81111111
    End If

    SetVerticesOval shp
    n = VertNum

    ' draw the mouth
    VertNum = n + 7
    ReDim Preserve Vert(1 To VertNum) As aofNode
    Vert(n + 1).x = shp.Left + shp.width * 0.23
    Vert(n + 1).y = shp.Top + shp.height * (ratioMouth * 2 - ratio)
    Vert(n + 1).SegType = msoSegmentCurve
    Vert(n + 2).x = shp.Left + shp.width * 0.3125
    Vert(n + 2).y = shp.Top + shp.height * ratioMouth
    Vert(n + 2).SegType = msoSegmentCurve
    Vert(n + 3).x = shp.Left + shp.width * 0.41
    Vert(n + 3).y = shp.Top + shp.height * ratio
    Vert(n + 3).SegType = msoSegmentCurve
    Vert(n + 4).x = shp.Left + shp.width / 2
    Vert(n + 4).y = Vert(n + 3).y
    Vert(n + 4).SegType = msoSegmentCurve

    Vert(n + 5).x = shp.Left + shp.width * 0.59
    Vert(n + 5).y = Vert(n + 3).y
    Vert(n + 5).SegType = msoSegmentLine
    Vert(n + 6).x = shp.Left + shp.width * 0.6875
    Vert(n + 6).y = Vert(n + 2).y
    Vert(n + 6).SegType = msoSegmentLine
    Vert(n + 7).x = shp.Left + shp.width * 0.77
    Vert(n + 7).y = Vert(n + 1).y
    Vert(n + 7).SegType = msoSegmentLine

End Sub

Private Sub ParseSmileyFace(shp As Shape)
    Dim colorDumm As String
    Dim colorEyes As String
'
'    ' bacause Assistant doesnot support rotated ellipse,
'    ' and neither does converter. So, the rotated face
'    ' should be exported as image.
'    ' this might be supported by Assistant or converter.
'    If shp.Rotation <> 0 Then
'        ImportAsImage shp
'        SetNewAnchor shp
'        Exit Sub
'    End If

    NewRotateNodes shp
    SetGraphstyle shp

    If m_lecDrawStyle > LEC_DRAWSTYLE_OUTLINE Then
        SetRelatedColors shp.Fill.ForeColor, colorDumm, colorDumm, colorEyes, colorDumm
    Else
        colorEyes = "none"
    End If

    AddGroupItem
    With GroupItems(GroupItemNum)      ' face background
        .SetGraphstyle shp
        .InitVerts 1, 13, Vert, True
        .PrintPointsString
        .SetShapeType (LEC_SHAPETYPE_POLYGON)
    End With

    AddGroupItem
    With GroupItems(GroupItemNum)      ' left eye
        .SetVerticesOval shp, True, _
            (shp.Left + shp.width * 0.29), _
            (shp.Top + shp.height * 0.3), _
            shp.width * 0.105, _
            shp.height * 0.105
        .NewRotateNodes shp
        .SetGraphstyle shp
        .m_szFillColor = colorEyes
        .PrintPointsString
        .SetShapeType (LEC_SHAPETYPE_POLYGON)
    End With

    AddGroupItem
    With GroupItems(GroupItemNum)      ' right eye
        .SetVerticesOval shp, True, _
            (shp.Left + shp.width * 0.605 - .width), _
            (shp.Top + shp.height * 0.3), _
            shp.width * 0.105, _
            shp.height * 0.105
        .NewRotateNodes shp
        .SetGraphstyle shp
        .m_szFillColor = colorEyes
        .PrintPointsString
        .SetShapeType (LEC_SHAPETYPE_POLYGON)
    End With

    AddGroupItem
    With GroupItems(GroupItemNum)      ' mouth
        .SetGraphstyle shp
        If .m_lecDrawStyle <> LEC_DRAWSTYLE_NONE Then
            .m_lecDrawStyle = LEC_DRAWSTYLE_OUTLINE
        End If
        .InitVerts 14, 7, Vert, False
        .PrintPointsString
        .SetShapeType (LEC_SHAPETYPE_POLYGON)
    End With

    m_lecShapeType = LEC_SHAPETYPE_USERDEFINEDGROUP

End Sub

Public Sub SetPointsString(str As String)
    PointsString = str
End Sub

Private Sub SetVerticesRoundedRectangularCallout(shp As Shape, Optional bRotateNodes As Boolean = True)

    Dim ratio   As Single
    Dim ratio1  As Single
    Dim ratio2  As Single

    Dim cirRatio    As Single
    Dim shftx   As Long
    Dim shfty   As Long
    Dim shftx1   As Long
    Dim shftx2   As Long
    Dim shfty1   As Long
    Dim shfty2   As Long

    Dim shftx3   As Long
    Dim shfty3   As Long

    Dim InsertIdx   As Long

    InitVertices 41

    With shp
        cirRatio = 0.2
        ratio = 0.12
        shfty = .height * ratio * (1 - cirRatio * 2)
        shftx = .width * ratio * (1 - cirRatio * 2)

        On Error Resume Next
        ratio1 = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio1 = 0.0625
            Err.Clear
        End If
        ratio2 = .Adjustments(2)
        If Err.Number <> 0 Then
            ratio2 = 1.2
        End If
        On Error GoTo 0

        ' the callout point
        shftx3 = .width * ratio1
        shfty3 = .height * ratio2

        shftx1 = .width * 0.17
        shftx2 = .width * 0.42
        shfty1 = .height * 0.17
        shfty2 = .height * 0.42

       'top left corner
        Vert(1).x = .Left
        Vert(1).y = .Top + shfty + shfty
        Vert(1).SegType = msoSegmentCurve
        Vert(2).x = .Left
        Vert(2).y = .Top + shfty
        Vert(2).SegType = msoSegmentCurve
        Vert(3).x = .Left + shftx
        Vert(3).y = .Top
        Vert(3).SegType = msoSegmentCurve
        Vert(4).x = .Left + shftx + shftx
        Vert(4).y = .Top

        'top
        Vert(5).x = .Left + shftx1
        Vert(5).y = .Top
        Vert(6) = Vert(5)
        Vert(7).x = .Left + shftx2
        Vert(7).y = .Top
        Vert(8).x = .Left + .width - shftx2
        Vert(8).y = .Top
        Vert(9) = Vert(8)
        Vert(10).x = .Left + .width - shftx1
        Vert(10).y = .Top

        ' top right corner
        Vert(11).x = .Left + .width - shftx - shftx
        Vert(11).y = .Top
        Vert(11).SegType = msoSegmentCurve
        Vert(12).x = .Left + .width - shftx
        Vert(12).y = .Top
        Vert(12).SegType = msoSegmentCurve
        Vert(13).x = .Left + .width
        Vert(13).y = .Top + shfty
        Vert(13).SegType = msoSegmentCurve
        Vert(14).x = .Left + .width
        Vert(14).y = .Top + shfty + shfty

        'right
        Vert(15).x = .Left + .width
        Vert(15).y = .Top + shfty1
        Vert(16) = Vert(15)
        Vert(17).x = Vert(15).x
        Vert(17).y = .Top + shfty2
        Vert(18).x = Vert(15).x
        Vert(18).y = .Top + .height - shfty2
        Vert(19) = Vert(18)
        Vert(20).x = Vert(15).x
        Vert(20).y = .Top + .height - shfty1

        ' right bottom corner
        Vert(21).x = .Left + .width
        Vert(21).y = .Top + .height - shfty - shfty
        Vert(21).SegType = msoSegmentCurve
        Vert(22).x = Vert(21).x
        Vert(22).y = .Top + .height - shfty
        Vert(22).SegType = msoSegmentCurve
        Vert(23).x = Vert(12).x
        Vert(23).y = .Top + .height
        Vert(23).SegType = msoSegmentCurve
        Vert(24).x = Vert(11).x
        Vert(24).y = .Top + .height

        'bottom
        Vert(25).x = Vert(10).x
        Vert(25).y = .Top + .height
        Vert(26) = Vert(25)
        Vert(27).x = Vert(8).x
        Vert(27).y = Vert(25).y
        Vert(28).x = Vert(7).x
        Vert(28).y = Vert(25).y
        Vert(29) = Vert(28)
        Vert(30).x = Vert(5).x
        Vert(30).y = Vert(25).y

        ' left bottom corner
        Vert(31).x = Vert(4).x
        Vert(31).y = .Top + .height
        Vert(31).SegType = msoSegmentCurve
        Vert(32).x = Vert(3).x
        Vert(32).y = Vert(31).y
        Vert(31).SegType = msoSegmentCurve
        Vert(33).x = .Left
        Vert(33).y = .Top + .height - shfty
        Vert(33).SegType = msoSegmentCurve
        Vert(34).x = .Left
        Vert(34).y = Vert(21).y

        ' left
        Vert(35).x = .Left
        Vert(35).y = Vert(20).y
        Vert(36) = Vert(35)
        Vert(37).x = .Left
        Vert(37).y = Vert(18).y
        Vert(38).x = .Left
        Vert(38).y = Vert(17).y
        Vert(39) = Vert(38)
        Vert(40).x = .Left
        Vert(40).y = Vert(15).y
        Vert(41) = Vert(1)


        Dim r1 As Single
        Dim r2 As Single
        Dim dv As Single

        r1 = ratio1 - 0.5       ' move the coordinate origin to (0.5, 0.5)
        r2 = ratio2 - 0.5

        ' the point in the rect should be ignored.
        If Abs(r1) > 0.5 Or Abs(r2) > 0.5 Then
            If r2 = 0 Then
                If r1 > 0 Then
                    InsertIdx = 19
                Else
                    InsertIdx = 36
                End If
            Else
                dv = r1 / r2
                If r2 > 0 Then
                    If dv < -1 Then
                        InsertIdx = 36
                    ElseIf dv < 0 Then
                        InsertIdx = 29
                    ElseIf dv <= 1 Then
                        InsertIdx = 26
                    ElseIf dv > 1 Then
                        InsertIdx = 19
                    End If
                Else
                    If dv <= -1 Then
                        InsertIdx = 16
                    ElseIf dv <= 0 Then
                        InsertIdx = 9
                    ElseIf dv < 1 Then
                        InsertIdx = 6
                    ElseIf dv >= 1 Then
                        InsertIdx = 39
                    End If
                End If
            End If
            Vert(InsertIdx).x = .Left + shftx3
            Vert(InsertIdx).y = .Top + shfty3
        End If

    End With
End Sub

Public Sub SetRectangleCalloutPoint(shp As Shape)
    Dim ratio1      As Single
    Dim ratio2      As Single

    VertNum = 1
    ReDim Vert(1 To 1) As aofNode

    With shp
        On Error Resume Next
        ratio1 = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio1 = 0.0625
            Err.Clear
        End If
        ratio2 = .Adjustments(2)
        If Err.Number <> 0 Then
            ratio2 = 1.2
        End If
        On Error GoTo 0

        Vert(1).x = .Left + .width * ratio1
        Vert(1).y = .Top + .height * ratio2
    End With
End Sub

Private Sub SetVerticesRectangularCallout(shp As Shape)
    Dim ratio1      As Single
    Dim ratio2      As Single
    Dim shftx       As Long
    Dim shfty       As Long
    Dim shftx1      As Long
    Dim shftx2      As Long
    Dim shfty1      As Long
    Dim shfty2      As Long
    Dim InsertIdx   As Long

    InitVertices 29

    With shp
        On Error Resume Next
        ratio1 = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio1 = 0.0625
            Err.Clear
        End If
        ratio2 = .Adjustments(2)
        If Err.Number <> 0 Then
            ratio2 = 1.2
        End If
        On Error GoTo 0
        
        If g_lApplicationVersion = 2007 Then
            shftx = .width * (ratio1 + 0.5)
            shfty = .height * (ratio2 + 0.5)
        Else
            shftx = .width * ratio1
            shfty = .height * ratio2
        End If

        shftx1 = .width * 0.17
        shftx2 = .width * 0.42
        shfty1 = .height * 0.17
        shfty2 = .height * 0.42

        ' top
        Vert(1).x = .Left
        Vert(1).y = .Top
        Vert(2).x = .Left + shftx1
        Vert(2).y = .Top
        Vert(3) = Vert(2)
        Vert(4).x = .Left + shftx2
        Vert(4).y = .Top
        Vert(8).x = .Left + .width
        Vert(8).y = .Top
        Vert(5).x = Vert(8).x - shftx2
        Vert(5).y = .Top
        Vert(6) = Vert(5)
        Vert(7).x = Vert(8).x - shftx1
        Vert(7).y = .Top

        ' right
        Vert(9).x = Vert(8).x
        Vert(9).y = .Top + shfty1
        Vert(10) = Vert(9)
        Vert(11).x = Vert(9).x
        Vert(11).y = .Top + shfty2
        Vert(15).x = Vert(9).x
        Vert(15).y = .Top + .height
        Vert(12).x = Vert(9).x
        Vert(12).y = Vert(15).y - shfty2
        Vert(13) = Vert(12)
        Vert(14).x = Vert(9).x
        Vert(14).y = Vert(15).y - shfty1

        'bottom
        Vert(16).x = Vert(7).x
        Vert(16).y = Vert(15).y
        Vert(17) = Vert(16)
        Vert(18).x = Vert(5).x
        Vert(18).y = Vert(15).y
        Vert(22).x = Vert(1).x
        Vert(22).y = Vert(15).y
        Vert(19).x = Vert(4).x
        Vert(19).y = Vert(15).y
        Vert(20) = Vert(19)
        Vert(21).x = Vert(2).x
        Vert(21).y = Vert(15).y

        'left
        Vert(23).x = .Left
        Vert(23).y = Vert(14).y
        Vert(24) = Vert(23)
        Vert(25).x = .Left
        Vert(25).y = Vert(12).y
        Vert(26).x = .Left
        Vert(26).y = Vert(11).y
        Vert(27) = Vert(26)
        Vert(28).x = .Left
        Vert(28).y = Vert(9).y
        Vert(29) = Vert(1)

        ' calculate the insert index
        Dim r1 As Single
        Dim r2 As Single
        Dim dv As Single
 
        
        r1 = ratio1
        r2 = ratio2
        
        If g_lApplicationVersion <> 2007 Then
            r1 = ratio1 - 0.5       ' move the coordinate origin to (0.5, 0.5)
            r2 = ratio2 - 0.5
        End If

        Dim bPointInRect As Boolean: bPointInRect = False
        If g_lApplicationVersion <> 2007 Then
            If Not (Abs(r1) > 0.5 Or Abs(r2) > 0.5) Then
                bPointInRect = True
            End If
        End If
        
        ' the point in the rect should be ignored if the PPT version is not 2007
        If Not bPointInRect Then
            If r2 = 0 Then
                If r1 > 0 Then
                    InsertIdx = 13
                Else
                    InsertIdx = 24
                End If
            Else
                dv = r1 / r2
                If r2 > 0 Then
                    If dv < -1 Then
                        InsertIdx = 24
                    ElseIf dv < 0 Then
                        InsertIdx = 20
                    ElseIf dv <= 1 Then
                        InsertIdx = 17
                    ElseIf dv > 1 Then
                        InsertIdx = 13
                    End If
                Else
                    If dv <= -1 Then
                        InsertIdx = 10
                    ElseIf dv <= 0 Then
                        InsertIdx = 6
                    ElseIf dv < 1 Then
                        InsertIdx = 3
                    ElseIf dv >= 1 Then
                        InsertIdx = 27
                    End If
                End If
            End If
            Vert(InsertIdx).x = .Left + shftx
            Vert(InsertIdx).y = .Top + shfty
        End If
    End With
End Sub

Private Sub SetVertices8pointStar(shp As Shape)
    Dim ratio1      As Single
    Dim ratio2      As Single
    Dim shftx1       As Long
    Dim shftx2       As Long
    Dim shftx3       As Long
    Dim shfty1       As Long
    Dim shfty2       As Long
    Dim shfty3       As Long

    InitVertices 17
    With shp
        On Error Resume Next
        ratio1 = .Adjustments(1)
        If g_lApplicationVersion = 2007 Then
            ratio1 = 0.5 - ratio1
        End If
        If Err.Number <> 0 Then
            ratio1 = 0.1173
        End If
        ratio2 = 0.3087 + 0.3827 * ratio1        ' 1/2 - (1/2 - ratio1) * sin(PI/8)
        ratio1 = 0.0381 + 0.9239 * ratio1        ' 1/2 - (1/2 - ratio1) * cos(PI/8)

        shftx1 = .width * ratio1
        shftx2 = .width * 0.1464                ' 1/2 - cos(PI/4) / 2
        shftx3 = .width * ratio2
        shfty1 = .height * ratio1
        shfty2 = .height * 0.1464
        shfty3 = .height * ratio2

        Vert(1).x = .Left
        Vert(1).y = .Top + .height / 2
        Vert(2).x = .Left + shftx1
        Vert(2).y = .Top + shfty3
        Vert(3).x = .Left + shftx2
        Vert(3).y = .Top + shfty2
        Vert(4).x = .Left + shftx3
        Vert(4).y = .Top + shfty1
        Vert(5).x = .Left + .width / 2
        Vert(5).y = .Top
        Vert(6).x = .Left + .width - shftx3
        Vert(6).y = Vert(4).y
        Vert(7).x = .Left + .width - shftx2
        Vert(7).y = Vert(3).y
        Vert(8).x = .Left + .width - shftx1
        Vert(8).y = Vert(2).y

        Vert(9).x = .Left + .width
        Vert(9).y = Vert(1).y
        Vert(10).x = Vert(8).x
        Vert(10).y = .Top + .height - shfty3
        Vert(11).x = Vert(7).x
        Vert(11).y = .Top + .height - shfty2
        Vert(12).x = Vert(6).x
        Vert(12).y = .Top + .height - shfty1
        Vert(13).x = Vert(5).x
        Vert(13).y = .Top + .height
        Vert(14).x = Vert(4).x
        Vert(14).y = Vert(12).y
        Vert(15).x = Vert(3).x
        Vert(15).y = Vert(11).y
        Vert(16).x = Vert(2).x
        Vert(16).y = Vert(10).y

        Vert(17) = Vert(1)

    End With
End Sub

Private Sub SetVertices5pointStar(shp As Shape)
    Dim shftx1       As Long
    Dim shftx2       As Long
    Dim shftx3       As Long
    Dim shfty1       As Long
    Dim shfty2       As Long
    Dim shfty3       As Long

    InitVertices 11
    With shp
        If g_lApplicationVersion = 2007 Then
            Dim adj, xc, yc, ang
            ang = 36 * PI / 180
            adj = .Adjustments(1)
            xc = .Left + 0.5 * .width
            yc = .Top + 0.54 * .height
            
            shftx1 = adj * .width * Sin(ang)
            shftx2 = adj * .width * Sin(ang * 2)
            shfty1 = adj * .height * Cos(ang)
            shfty2 = adj * .height * Cos(ang * 2)
            shfty3 = adj * 1.135 * .height
            
            Vert(1).x = .Left
            Vert(1).y = .Top + .height * 0.4
            Vert(2).x = xc - shftx1
            Vert(2).y = yc - shfty1
            Vert(3).x = .Left + .width / 2
            Vert(3).y = .Top
            Vert(4).x = xc + shftx1
            Vert(4).y = Vert(2).y
            Vert(5).x = .Left + .width
            Vert(5).y = Vert(1).y
            Vert(6).x = xc + shftx2
            Vert(6).y = yc + shfty2
            Vert(7).x = xc + 0.3 * .width
            Vert(7).y = .Top + .height
            Vert(8).x = Vert(3).x
            Vert(8).y = yc + shfty3
            Vert(9).x = xc - 0.3 * .width
            Vert(9).y = Vert(7).y
            Vert(10).x = xc - shftx2
            Vert(10).y = Vert(6).y
            Vert(11) = Vert(1)
        Else
            shftx1 = .width * 0.191
            shftx2 = .width * 0.309
            shftx3 = .width * 0.382
            shfty1 = .height * 0.382
            shfty2 = .height - shfty1
            shfty3 = .height * 0.764
    
            Vert(1).x = .Left
            Vert(1).y = .Top + shfty1
            Vert(2).x = .Left + shftx3
            Vert(2).y = Vert(1).y
            Vert(3).x = .Left + .width / 2
            Vert(3).y = .Top
            Vert(4).x = .Left + .width - shftx3
            Vert(4).y = Vert(2).y
            Vert(5).x = .Left + .width
            Vert(5).y = Vert(2).y
            Vert(6).x = .Left + .width - shftx2
            Vert(6).y = .Top + shfty2
            Vert(7).x = .Left + .width - shftx1
            Vert(7).y = .Top + .height
            Vert(8).x = Vert(3).x
            Vert(8).y = .Top + shfty3
            Vert(9).x = .Left + shftx1
            Vert(9).y = Vert(7).y
            Vert(10).x = .Left + shftx2
            Vert(10).y = Vert(6).y
    
            Vert(11) = Vert(1)
        End If

    End With
End Sub

Private Sub SetVertices4pointStar(shp As Shape)
    Dim ratio       As Single
    Dim shftx       As Long
    Dim shfty       As Long

    InitVertices 9
    With shp
        On Error Resume Next
        ratio = .Adjustments(1)
        If g_lApplicationVersion = 2007 Then
            ratio = 0.5 - ratio
        End If
        If Err.Number <> 0 Then
            ratio = 0.375
        End If
        ratio = 0.5 - (0.25 - 0.5 * ratio) * Sqr(2)
        shftx = .width * ratio
        shfty = .height * ratio

        Vert(1).x = .Left
        Vert(1).y = .Top + .height / 2
        Vert(2).x = .Left + shftx
        Vert(2).y = .Top + shfty
        Vert(3).x = .Left + .width / 2
        Vert(3).y = .Top
        Vert(4).x = .Left + .width - shftx
        Vert(4).y = Vert(2).y
        Vert(5).x = .Left + .width
        Vert(5).y = Vert(1).y
        Vert(6).x = Vert(4).x
        Vert(6).y = .Top + .height - shfty
        Vert(7).x = Vert(3).x
        Vert(7).y = .Top + .height
        Vert(8).x = Vert(2).x
        Vert(8).y = Vert(6).y

        Vert(9) = Vert(1)
    End With
End Sub

Private Sub SetVerticesExplosion2(shp As Shape)

    InitVertices 29
    With shp

        Vert(1).x = .Left
        Vert(1).y = .Top + .height * 0.598
        Vert(7).x = .Left + .width * 0.451
        Vert(7).y = .Top + .height * 0.089
        Vert(13).x = .Left + .width
        Vert(13).y = .Top + .height * 0.311
        Vert(21).x = .Left + .width * 0.538
        Vert(21).y = .Top + .height * 0.873

        Vert(2).x = .Left + .width * 0.183
        Vert(3).x = .Left + .width * 0.055
        Vert(4).x = .Left + .width * 0.249
        Vert(5).x = .Left + .width * 0.207
        Vert(6).x = .Left + .width * 0.397
        Vert(8).x = .Left + .width * 0.53
        Vert(9).x = .Left + .width * 0.684
        Vert(10).x = .Left + .width * 0.673
        Vert(11).x = .Left + .width * 0.837
        Vert(12).x = .Left + .width * 0.759
        Vert(14).x = .Left + .width * 0.787
        Vert(15).x = .Left + .width * 0.846
        Vert(16).x = .Left + .width * 0.76
        Vert(17).x = .Left + .width * 0.875
        Vert(18).x = .Left + .width * 0.679
        Vert(19).x = .Left + .width * 0.692
        Vert(20).x = .Left + .width * 0.567
        Vert(22).x = .Left + .width * 0.458
        Vert(23).x = .Left + .width * 0.403
        Vert(24).x = .Left + .width * 0.35
        Vert(25).x = .Left + .width * 0.228
        Vert(26).x = .Left + .width * 0.222
        Vert(27).x = .Left + .width * 0.057
        Vert(28).x = .Left + .width * 0.154

        Vert(2).y = .Top + .height * 0.541
        Vert(3).y = .Top + .height * 0.384
        Vert(4).y = .Top + .height * 0.364
        Vert(5).y = .Top + .height * 0.17
        Vert(6).y = .Top + .height * 0.295
        Vert(8).y = .Top + .height * 0.2
        Vert(9).y = .Top
        Vert(10).y = .Top + .height * 0.266
        Vert(11).y = .Top + .height * 0.148
        Vert(12).y = .Top + .height * 0.305
        Vert(14).y = .Top + .height * 0.436
        Vert(15).y = .Top + .height * 0.523
        Vert(16).y = .Top + .height * 0.57
        Vert(17).y = .Top + .height * 0.725
        Vert(18).y = .Top + .height * 0.668
        Vert(19).y = .Top + .height * 0.807
        Vert(20).y = .Top + .height * 0.739
        Vert(22).y = .Top + .height * 0.807
        Vert(23).y = .Top + .height * 0.911
        Vert(24).y = .Top + .height * 0.839
        Vert(25).y = .Top + .height
        Vert(26).y = .Top + .height * 0.845
        Vert(27).y = .Top + .height * 0.825
        Vert(28).y = .Top + .height * 0.714

        Vert(29) = Vert(1)

    End With
End Sub
Private Sub SetVerticesExplosion1(shp As Shape)

    InitVertices 25
    With shp

        Vert(1).x = .Left
        Vert(1).y = .Top + .height * 0.397
        Vert(7).x = .Left + .width * 0.672
        Vert(7).y = .Top
        Vert(13).x = .Left + .width
        Vert(13).y = .Top + .height * 0.614
        Vert(19).x = .Left + .width * 0.394
        Vert(19).y = .Top + .height

        Vert(2).x = .Left + .width * 0.217
        Vert(3).x = .Left + .width * 0.021
        Vert(4).x = .Left + .width * 0.34
        Vert(5).x = .Left + .width * 0.389
        Vert(6).x = .Left + .width * 0.502
        Vert(8).x = .Left + .width * 0.656
        Vert(9).x = .Left + .width * 0.854
        Vert(10).x = .Left + .width * 0.781
        Vert(11).x = .Left + .width * 0.979
        Vert(12).x = .Left + .width * 0.814
        Vert(14).x = .Left + .width * 0.781
        Vert(15).x = .Left + .width * 0.84
        Vert(16).x = .Left + .width * 0.651
        Vert(17).x = .Left + .width * 0.616
        Vert(18).x = .Left + .width * 0.488
        Vert(20).x = .Left + .width * 0.358
        Vert(21).x = .Left + .width * 0.224
        Vert(22).x = .Left + .width * 0.264
        Vert(23).x = .Left + .width * 0.012
        Vert(24).x = .Left + .width * 0.172

        Vert(2).y = .Top + .height * 0.35
        Vert(3).y = .Top + .height * 0.107
        Vert(4).y = .Top + .height * 0.29
        Vert(5).y = .Top + .height * 0.105
        Vert(6).y = .Top + .height * 0.266
        Vert(8).y = .Top + .height * 0.25
        Vert(9).y = .Top + .height * 0.208
        Vert(10).y = .Top + .height * 0.339
        Vert(11).y = .Top + .height * 0.379
        Vert(12).y = .Top + .height * 0.481
        Vert(14).y = .Top + .height * 0.603
        Vert(15).y = .Top + .height * 0.836
        Vert(16).y = .Top + .height * 0.673
        Vert(17).y = .Top + .height * 0.916
        Vert(18).y = .Top + .height * 0.694
        Vert(20).y = .Top + .height * 0.727
        Vert(21).y = .Top + .height * 0.818
        Vert(22).y = .Top + .height * 0.645
        Vert(23).y = .Top + .height * 0.675
        Vert(24).y = .Top + .height * 0.547

        Vert(25) = Vert(1)

    End With
End Sub

Private Sub SetVerticesConnectorCurve(shp As Shape)
    Dim ratio1          As Single
    Dim ratio2          As Single
    Dim ratio3          As Single
    Dim ratNum          As Long

    On Error Resume Next
    ratio1 = shp.Adjustments(1)
    If Err.Number <> 0 Then     ' no adjustments
        VertNum = 6     ' two more to display the line arrow
        ' now the polylines support arrow, so the two more vertices are no more
        ' necessary, but to avoid mistakes, they are maintained.

        ratNum = 0
        Err.Clear
    Else
        ratio2 = shp.Adjustments(2)
        If Err.Number <> 0 Then
            VertNum = 9
            ratNum = 1
            Err.Clear
        Else
            ratio3 = shp.Adjustments(3)
            If Err.Number <> 0 Then
                VertNum = 12
                ratNum = 2
                Err.Clear
            Else
                VertNum = 15
                ratNum = 3
            End If
        End If
    End If

    ReDim Vert(1 To VertNum) As aofNode

    Vert(1).x = shp.Left
    Vert(1).y = shp.Top
    Vert(VertNum).x = shp.Left + shp.width
    Vert(VertNum).y = shp.Top + shp.height

    Dim arrh    As Boolean
    Dim arre    As Boolean
    Dim numOfArrow  As Long

    Dim connw    As Single
    Dim connh   As Single

    connw = Vert(VertNum).x - Vert(1).x
    connh = Vert(VertNum).y - Vert(1).y

    If connw = 0 Then
        connw = 0.1
    End If
    If connh = 0 Then
        connh = 0.1
    End If

    Select Case ratNum
        Case 0
            Vert(2).x = Vert(1).x '+ 1    ' same to v(1)
            Vert(2).y = Vert(1).y
            Vert(2).SegType = msoSegmentCurve
            Vert(5).x = Vert(VertNum).x
            Vert(5).y = Vert(VertNum).y '- 1  ' same to v(6)
            Vert(5).SegType = msoSegmentLine
            Vert(3).x = (Vert(1).x + Vert(VertNum).x) / 2
            Vert(3).y = Vert(1).y
            Vert(4).x = Vert(VertNum).x
            Vert(4).y = (Vert(1).y + Vert(VertNum).y) / 2
        Case 1
            Vert(2).x = Vert(1).x '+ 1
            Vert(2).y = Vert(1).y
            Vert(2).SegType = msoSegmentCurve
            Vert(8).x = Vert(VertNum).x
            Vert(8).y = Vert(VertNum).y '- 1
            Vert(8).SegType = msoSegmentLine
            Vert(5).x = Vert(1).x + connw * ratio1
            Vert(5).y = (Vert(1).y + Vert(VertNum).y) / 2
            Vert(5).SegType = msoSegmentCurve
            Vert(3).x = (Vert(1).x + Vert(5).x) / 2
            Vert(3).y = Vert(1).y
            Vert(4).x = Vert(5).x
            Vert(4).y = (Vert(1).y + Vert(5).y) / 2

            Vert(6).x = Vert(5).x
            Vert(6).y = (Vert(5).y + Vert(VertNum).y) / 2
            Vert(7).x = (Vert(5).x + Vert(VertNum).x) / 2
            Vert(7).y = Vert(VertNum).y
        Case 2
            Vert(2).x = Vert(1).x '+ 1
            Vert(2).y = Vert(1).y
            Vert(2).SegType = msoSegmentCurve
            Vert(11).x = Vert(VertNum).x
            Vert(11).y = Vert(VertNum).y '- 1

            Vert(5).x = Vert(1).x + connw * ratio1
            Vert(8).y = Vert(1).y + connh * ratio2
            Vert(5).y = (Vert(1).y + Vert(8).y) / 2
            Vert(8).x = (Vert(5).x + Vert(VertNum).x) / 2
            Vert(5).SegType = msoSegmentCurve
            Vert(8).SegType = msoSegmentCurve

            Vert(3).x = (Vert(1).x + Vert(5).x) / 2
            Vert(3).y = Vert(1).y
            Vert(4).x = Vert(5).x
            Vert(4).y = (Vert(1).y + Vert(5).y) / 2

            Vert(6).x = Vert(5).x
            Vert(6).y = (Vert(5).y + Vert(8).y) / 2
            Vert(7).x = (Vert(5).x + Vert(8).x) / 2
            Vert(7).y = Vert(8).y

            Vert(9).x = (Vert(8).x + Vert(VertNum).x) / 2
            Vert(9).y = Vert(8).y
            Vert(10).x = Vert(VertNum).x
            Vert(10).y = (Vert(8).y + Vert(VertNum).y) / 2
        Case 3
            Vert(2).x = Vert(1).x '+ 1
            Vert(2).y = Vert(1).y
            Vert(2).SegType = msoSegmentCurve
            Vert(14).x = Vert(VertNum).x '- 1
            Vert(14).y = Vert(VertNum).y

            Vert(5).x = Vert(1).x + connw * ratio1
            Vert(8).y = Vert(1).y + connh * ratio2
            Vert(11).x = Vert(1).x + connw * ratio3

            Vert(5).y = (Vert(1).y + Vert(8).y) / 2
            Vert(8).x = (Vert(5).x + Vert(11).x) / 2
            Vert(11).y = (Vert(8).y + Vert(VertNum).y) / 2
            Vert(5).SegType = msoSegmentCurve
            Vert(8).SegType = msoSegmentCurve
            Vert(11).SegType = msoSegmentCurve

            Vert(3).x = (Vert(1).x + Vert(5).x) / 2
            Vert(3).y = Vert(1).y
            Vert(4).x = Vert(5).x
            Vert(4).y = (Vert(1).y + Vert(5).y) / 2

            Vert(6).x = Vert(5).x
            Vert(6).y = (Vert(5).y + Vert(8).y) / 2
            Vert(7).x = (Vert(5).x + Vert(8).x) / 2
            Vert(7).y = Vert(8).y

            Vert(9).x = (Vert(8).x + Vert(11).x) / 2
            Vert(9).y = Vert(8).y
            Vert(10).x = Vert(11).x
            Vert(10).y = (Vert(8).y + Vert(11).y) / 2

            Vert(12).x = Vert(11).x
            Vert(12).y = (Vert(11).y + Vert(VertNum).y) / 2
            Vert(13).x = (Vert(11).x + Vert(VertNum).x) / 2
            Vert(13).y = Vert(VertNum).y
    End Select
End Sub

Private Sub ParseConnectorCurve(shp As Shape, Optional bRotateNodes As Boolean = True)

    m_lecShapeType = LEC_SHAPETYPE_POLYGON

    If SetGraphmode(shp) Then    ' lineart and fillart are set here
        'ErrLog LEC_ERRORTYPE_INVISIBLESHAPE, "invisible Polygon"
        Exit Sub
    End If

    'SetLineAttributes shp

    NewFlipNodes shp
    NewRotateNodes shp
    PrintPointsString
End Sub

Private Sub SetVerticesConnectorElbow(shp As Shape)
    Dim ratio1          As Single
    Dim ratio2          As Single
    Dim ratio3          As Single
    Dim ratNum          As Long

    On Error Resume Next
    ratio1 = shp.Adjustments(1)
    If Err.Number <> 0 Then     ' no adjustments
        VertNum = 3
        ratNum = 0
        Err.Clear
    Else
        ratio2 = shp.Adjustments(2)
        If Err.Number <> 0 Then
            VertNum = 4
            ratNum = 1
            Err.Clear
        Else
            ratio3 = shp.Adjustments(3)
            If Err.Number <> 0 Then
                VertNum = 5
                ratNum = 2
                Err.Clear
            Else
                VertNum = 6
                ratNum = 3
            End If
        End If
    End If

    ReDim Vert(1 To VertNum) As aofNode

    Vert(1).x = shp.Left
    Vert(1).y = shp.Top
    Vert(VertNum).x = shp.Left + shp.width
    Vert(VertNum).y = shp.Top + shp.height

    Dim arrh    As Boolean
    Dim arre    As Boolean
    Dim numOfArrow  As Long

    Dim connw    As Single
    Dim connh   As Single

    connw = Vert(VertNum).x - Vert(1).x
    connh = Vert(VertNum).y - Vert(1).y

    If connw = 0 Then
        connw = 0.1
    End If
    If connh = 0 Then
        connh = 0.1
    End If

    Select Case ratNum
        Case 0
            Vert(2).x = Vert(3).x
            Vert(2).y = Vert(1).y
        Case 1
            Vert(2).x = Vert(1).x + connw * ratio1
            Vert(2).y = Vert(1).y
            Vert(3).x = Vert(2).x
            Vert(3).y = Vert(4).y
        Case 2
            Vert(2).x = Vert(1).x + connw * ratio1
            Vert(2).y = Vert(1).y
            Vert(3).x = Vert(2).x
            Vert(3).y = Vert(1).y + connh * ratio2
            Vert(4).x = Vert(5).x
            Vert(4).y = Vert(3).y
        Case 3
            Vert(2).x = Vert(1).x + connw * ratio1
            Vert(2).y = Vert(1).y
            Vert(3).x = Vert(2).x
            Vert(3).y = Vert(1).y + connh * ratio2
            Vert(4).x = Vert(1).x + connw * ratio3
            Vert(4).y = Vert(3).y
            Vert(5).x = Vert(4).x
            Vert(5).y = Vert(6).y
    End Select

End Sub

Private Sub ParseConnectorElbow(shp As Shape, Optional bRotateNodes As Boolean = True)

    m_lecShapeType = LEC_SHAPETYPE_POLYGON

    If SetGraphmode(shp) Then    ' lineart and fillart are set here
        'ErrLog LEC_ERRORTYPE_INVISIBLESHAPE, "invisible Polygon"
        Exit Sub
    End If

'    SetLineAttributes shp

    'NewFlipNodes shp
    NewRotateNodes shp

    PrintPointsString
End Sub

Private Sub SetVerticesConnectorStraight(shp As Shape)
    Dim arrhead As Boolean
    Dim arrend   As Boolean

    InitVertices 2

    With shp
        Vert(2).x = .Left + .width
        Vert(1).x = .Left
        Vert(2).y = .Top + .height
        Vert(1).y = .Top
    End With
End Sub

Private Sub ParseConnectorStraight(shp As Shape, Optional bRotateNodes As Boolean = True)
    Dim arrhead As Boolean
    Dim arrend   As Boolean

    SetLineAttributes shp

    If shp.Line.BeginArrowheadStyle <> msoArrowheadNone Then
        arrhead = True
    End If
    If shp.Line.EndArrowheadStyle <> msoArrowheadNone Then
        arrend = True
    End If

    NewFlipNodes shp
    NewRotateNodes shp

    m_lecShapeType = LEC_SHAPETYPE_LINE
    BuildLineWithVert arrhead, arrend
End Sub

Sub FlipNodes(ByRef v() As aofNode, num As Long, shp As Shape)
    Dim midline     As Long
    Dim i           As Long

    If shp.VerticalFlip = msoTrue Then
        'midline = v(1).y + v(num).y
        midline = shp.Top * 2 + shp.height
        For i = 1 To num
            v(i).y = midline - v(i).y
        Next
    End If
    If shp.HorizontalFlip = msoTrue Then
        'midline = v(1).x + v(num).x
        midline = shp.Left * 2 + shp.width
        For i = 1 To num
            v(i).x = midline - v(i).x
        Next
    End If
End Sub


Sub SetVerts(v() As aofNode, beginNum As Long, num As Long)
    HasVertices = True
    VertNum = num
    ReDim Vert(1 To VertNum) As aofNode

    Dim i   As Long
    For i = 1 To VertNum
        Vert(i) = v(i + beginNum - 1)
    Next
End Sub

Sub BuildLineWithVert(arrhead As Boolean, arrend As Boolean)
    m_lecShapeType = LEC_SHAPETYPE_LINE
    If arrhead Then
        If arrend Then
            arrowStyle = "both"
        Else
            arrowStyle = "first"
        End If
    Else
        If arrend Then
            arrowStyle = "last"
        Else
            arrowStyle = "none"
        End If
    End If

    x = Vert(1).x
    y = Vert(1).y

    width = Vert(2).x - Vert(1).x
    height = Vert(2).y - Vert(1).y

End Sub
Private Sub SetVerticesRightBrace(shp As Shape)
    Dim shfty   As Long
    Dim shftp   As Long

    InitVertices 15
    With shp
        On Error Resume Next
        
        ' There is an error in PowerPoint 2007 VBA.
        ' The Adjustment have to be divided by 10
        'If g_lApplicationVersion = 2007 Then
            'shfty = .height * .Adjustments(1) / 10
        'End If
        
        If g_lApplicationVersion = 2007 Then
            If .width < .height Then
                shfty = .width * .Adjustments(1)
            Else
                shfty = .height * .Adjustments(1)
            End If
        Else
            shfty = .height * .Adjustments(1)
        End If
        
        If Err.Number <> 0 Then
            shfty = .height * 0.08333334
            Err.Clear
        End If
        shftp = .height * .Adjustments(2)
        If Err.Number <> 0 Then
            shftp = .height / 2
        End If

        Vert(1).x = .Left
        Vert(1).y = .Top
        Vert(1).SegType = msoSegmentCurve
        
        Vert(2).x = .Left + .width / 4
        Vert(2).y = .Top
        Vert(2).SegType = msoSegmentCurve
        
        Vert(3).x = .Left + .width / 2
        Vert(3).y = .Top + shfty / 2
        Vert(3).SegType = msoSegmentCurve
        
        Vert(4).x = .Left + .width / 2
        Vert(4).y = .Top + shfty
        
        Vert(5).x = .Left + .width / 2
        Vert(5).y = .Top + shftp - shfty
        Vert(5).SegType = msoSegmentCurve

        Vert(6).x = .Left + .width / 2
        Vert(6).y = .Top + shftp - shfty / 2
        Vert(6).SegType = msoSegmentCurve
        
        Vert(7).x = .Left + .width - .width / 4
        Vert(7).y = .Top + shftp
        Vert(7).SegType = msoSegmentCurve
        
        Vert(8).x = .Left + .width
        Vert(8).y = .Top + shftp
        'Vert(8).SegType = msoSegmentCurve

        Vert(9).x = Vert(7).x
        'Vert(9).y = .Top + .height - shftp
        Vert(9).y = .Top + shftp + shfty / 4
        Vert(9).SegType = msoSegmentCurve
        
        Vert(10).x = Vert(6).x
        Vert(10).y = .Top + shftp + shfty / 2
        'Vert(10).y = .Top + .height - shftp + shfty / 2
        Vert(10).SegType = msoSegmentCurve
        
        Vert(11).x = Vert(5).x
        Vert(11).y = .Top + shftp + shfty
        'Vert(11).y = .Top + .height - shftp + shfty
        Vert(11).SegType = msoSegmentCurve

        Vert(12).x = Vert(4).x
        Vert(12).y = .Top + .height - shfty
        Vert(12).SegType = msoSegmentCurve
        
        Vert(13).x = Vert(3).x
        Vert(13).y = .Top + .height - shfty / 2
        Vert(13).SegType = msoSegmentCurve
        
        Vert(14).x = Vert(2).x
        Vert(14).y = .Top + .height
        Vert(14).SegType = msoSegmentCurve
        
        Vert(15).x = Vert(1).x
        Vert(15).y = .Top + .height
    End With
End Sub

Private Sub SetVerticesLeftBrace(shp As Shape)
    Dim shfty   As Long
    Dim shftp   As Long

    InitVertices 15
    With shp
        On Error Resume Next
        
        If g_lApplicationVersion = 2007 Then
            If .width < .height Then
                shfty = .width * .Adjustments(1)
            Else
                shfty = .height * .Adjustments(1)
            End If
        Else
            shfty = .height * .Adjustments(1)
        End If
        
        If Err.Number <> 0 Then
            shfty = .height * 0.08333334
            Err.Clear
        End If
        shftp = .height * .Adjustments(2)
        If Err.Number <> 0 Then
            shftp = .height / 2
        End If
        
        Vert(1).x = .Left + .width
        Vert(1).y = .Top
        Vert(1).SegType = msoSegmentCurve
        Vert(2).x = .Left + .width * 3 / 4
        Vert(2).y = .Top
        Vert(2).SegType = msoSegmentCurve
        Vert(3).x = .Left + .width / 2
        Vert(3).y = .Top + shfty / 2
        Vert(3).SegType = msoSegmentCurve
        Vert(4).x = Vert(3).x
        Vert(4).y = .Top + shfty

        Vert(8).x = .Left
        Vert(8).y = .Top + shftp
        Vert(8).SegType = msoSegmentCurve

        Vert(5).x = Vert(4).x
        Vert(5).y = Vert(8).y - shfty
        Vert(5).SegType = msoSegmentCurve
        Vert(6).x = Vert(5).x
        Vert(6).y = Vert(5).y + shfty / 2
        Vert(6).SegType = msoSegmentCurve
        Vert(7).x = Vert(8).x + .width / 4
        Vert(7).y = Vert(8).y
        Vert(7).SegType = msoSegmentCurve

        Vert(9) = Vert(7)
        Vert(11).x = Vert(5).x
        Vert(11).y = Vert(8).y + shfty
        Vert(10).x = Vert(11).x
        Vert(10).y = Vert(11).y - shfty / 2
        Vert(10).SegType = msoSegmentCurve

        Vert(12).x = Vert(11).x
        Vert(12).y = .Top + .height - shfty
        Vert(12).SegType = msoSegmentCurve
        Vert(13).x = Vert(12).x
        Vert(13).y = Vert(12).y + shfty / 2
        Vert(13).SegType = msoSegmentCurve
        Vert(14).x = Vert(2).x
        Vert(14).y = .Top + .height
        Vert(14).SegType = msoSegmentCurve
        Vert(15).x = Vert(1).x
        Vert(15).y = Vert(14).y

    End With
End Sub
Private Sub SetVerticesRightBrackt(shp As Shape)
    Dim shft    As Long

    InitVertices 8
    With shp
        On Error Resume Next
        
        If g_lApplicationVersion = 2007 Then
            If (.width < .height) Then
                shft = .width * .Adjustments(1)
            Else
                shft = .height * .Adjustments(1)
            End If
        Else
            shft = .height * .Adjustments(1)
        End If
        
        If Err.Number <> 0 Then
            shft = .height * 0.08333334
        End If

        Vert(1).x = .Left
        Vert(1).y = .Top
        Vert(1).SegType = msoSegmentCurve
        Vert(2).x = .Left + .width / 2
        Vert(2).y = .Top
        Vert(2).SegType = msoSegmentCurve
        Vert(3).x = .Left + .width
        Vert(3).y = .Top + shft / 2
        Vert(3).SegType = msoSegmentCurve
        Vert(4).x = Vert(3).x
        Vert(4).y = .Top + shft

        Vert(5).x = Vert(3).x
        Vert(5).y = .Top + .height - shft
        Vert(5).SegType = msoSegmentCurve
        Vert(6).x = Vert(3).x
        Vert(6).y = .Top + .height - shft / 2
        Vert(6).SegType = msoSegmentCurve
        Vert(7).x = Vert(2).x
        Vert(7).y = .Top + .height
        Vert(7).SegType = msoSegmentCurve
        Vert(8).x = Vert(1).x
        Vert(8).y = .Top + .height

    End With
End Sub

Private Sub SetVerticesLeftBrackt(shp As Shape)
    Dim shft    As Long
    InitVertices 8
    With shp
        On Error Resume Next
        
        If g_lApplicationVersion = 2007 Then
            If (.width < .height) Then
                shft = .width * .Adjustments(1)
            Else
                shft = .height * .Adjustments(1)
            End If
        Else
            shft = .height * .Adjustments(1)
        End If
        
        If Err.Number <> 0 Then
            shft = .height * 0.08333334
        End If

        Vert(1).x = .Left + .width
        Vert(1).y = .Top
        Vert(1).SegType = msoSegmentCurve
        Vert(2).x = .Left + .width / 2
        Vert(2).y = .Top
        Vert(2).SegType = msoSegmentCurve
        Vert(3).x = .Left
        Vert(3).y = .Top + shft / 2
        Vert(3).SegType = msoSegmentCurve
        Vert(4).x = Vert(3).x
        Vert(4).y = .Top + shft

        Vert(5).x = Vert(3).x
        Vert(5).y = .Top + .height - shft
        Vert(5).SegType = msoSegmentCurve
        Vert(6).x = Vert(3).x
        Vert(6).y = .Top + .height - shft / 2
        Vert(6).SegType = msoSegmentCurve
        Vert(7).x = Vert(2).x
        Vert(7).y = .Top + .height
        Vert(7).SegType = msoSegmentCurve
        Vert(8).x = Vert(1).x
        Vert(8).y = .Top + .height
    End With
End Sub

Private Sub SetVerticesUTurnArrow(shp As Shape)
    Dim NeckW   As Long
    Dim ArrW    As Long
    Dim ArrP    As Long
    Dim NeckL   As Long
    Dim BowHfL    As Long
    Dim BowHfR      As Long
    Dim BowWdL      As Long
    Dim BowWdR      As Long

    InitVertices 20
    With shp
        NeckW = .width * 0.2834
        NeckL = .height * 0.615      '0.63
        ArrW = .width * 0.551       '0.5833
        ArrP = .height * 0.66

        Vert(1).x = .Left
        Vert(1).y = .Top + .height

        Vert(2).x = .Left
        Vert(2).y = .Top + .height - NeckL
        Vert(2).SegType = msoSegmentCurve

        Vert(9).x = .Left + .width
        Vert(9).y = Vert(2).y

        Vert(11).x = Vert(9).x - ArrW
        Vert(11).y = Vert(9).y

        Vert(10).x = (Vert(9).x + Vert(11).x) / 2
        Vert(10).y = .Top + ArrP

        Vert(8).x = Vert(9).x - (ArrW - NeckW) / 2
        Vert(8).y = Vert(9).y

        Vert(12).x = Vert(8).x - NeckW
        Vert(12).y = Vert(8).y
        Vert(12).SegType = msoSegmentCurve

        Vert(18).x = .Left + NeckW
        Vert(18).y = Vert(2).y

        BowHfL = (Vert(8).x - Vert(2).x) / 2
        BowHfR = (Vert(12).x - Vert(18).x) / 2

        Vert(5).x = Vert(2).x + BowHfL
        Vert(5).y = .Top
        Vert(5).SegType = msoSegmentCurve

        BowWdL = Vert(2).y - Vert(5).y
        BowWdR = BowWdL * BowHfR / BowHfL

        Vert(15).x = Vert(5).x
        Vert(15).y = Vert(18).y - BowWdR
        Vert(15).SegType = msoSegmentCurve

        Vert(3).x = Vert(2).x
        Vert(3).y = Vert(2).y - BowWdL / 2
        Vert(3).SegType = msoSegmentCurve

        Vert(4).x = Vert(5).x - BowHfL / 2
        Vert(4).y = Vert(5).y
        Vert(4).SegType = msoSegmentCurve
        Vert(6).x = Vert(5).x + BowHfL / 2
        Vert(6).y = Vert(5).y
        Vert(6).SegType = msoSegmentCurve

        Vert(7).x = Vert(8).x
        Vert(7).y = Vert(3).y
        Vert(7).SegType = msoSegmentCurve

        Vert(13).x = Vert(12).x
        Vert(13).y = Vert(12).y - BowWdR / 2
        Vert(13).SegType = msoSegmentCurve
        Vert(14).x = Vert(15).x + BowHfR / 2
        Vert(14).y = Vert(15).y
        Vert(14).SegType = msoSegmentCurve
        Vert(16).x = Vert(15).x - BowHfR / 2
        Vert(16).y = Vert(15).y
        Vert(16).SegType = msoSegmentCurve
        Vert(17).x = Vert(18).x
        Vert(17).y = Vert(13).y
        Vert(17).SegType = msoSegmentCurve

        Vert(19).x = Vert(18).x
        Vert(19).y = Vert(1).y
        Vert(20) = Vert(1)

    End With
End Sub

Private Sub SetVerticesBentArrow(shp As Shape)
    Dim ratiox      As Single
    Dim ratioy      As Single
    Dim bzrRatio    As Single
    Dim ArrP        As Long
    Dim NeckW       As Long
    Dim ShdL        As Long
    Dim ShdR        As Long

    InitVertices 16
    With shp
        On Error Resume Next
        ratiox = .Adjustments(1)
        If Err.Number <> 0 Then
            ratiox = 0.7002778
            Err.Clear
        End If
        ratioy = .Adjustments(2)
        If Err.Number <> 0 Then
            ratioy = 0.1348148
        End If

        ArrP = .height * 0.2814352
        ShdL = .height * ratioy
        ShdR = ArrP * 2 - ShdL
        NeckW = .width * (0.5753241 - 0.5753241 * ratioy / 0.2814352)

        bzrRatio = 0.5

        Vert(1).x = .Left
        Vert(1).y = .Top + .height

        Vert(2).x = .Left
        Vert(2).y = .Top + ArrP * 2
        Vert(2).SegType = msoSegmentCurve
        Vert(5).x = .Left + .width * 0.5753241
        Vert(5).y = .Top + ShdL
        Vert(3).x = Vert(2).x
        Vert(3).y = Vert(2).y - (Vert(2).y - Vert(5).y) * bzrRatio
        Vert(3).SegType = msoSegmentCurve
        Vert(4).x = Vert(5).x - (Vert(5).x - Vert(2).x) * bzrRatio
        Vert(4).y = Vert(5).y
        Vert(4).SegType = msoSegmentCurve

        Vert(6).x = .Left + .width * ratiox
        Vert(6).y = Vert(5).y
        Vert(7).x = Vert(6).x
        Vert(7).y = .Top
        Vert(8).x = .Left + .width
        Vert(8).y = .Top + ArrP
        Vert(9).x = Vert(7).x
        Vert(9).y = Vert(2).y
        Vert(10).x = Vert(6).x
        Vert(10).y = .Top + ShdR

        Vert(11).x = Vert(5).x
        Vert(11).y = Vert(10).y
        Vert(11).SegType = msoSegmentCurve
        Vert(14).x = .Left + NeckW
        Vert(14).y = Vert(2).y
        Vert(12).x = Vert(11).x - (Vert(11).x - Vert(14).x) * bzrRatio
        Vert(12).y = Vert(11).y
        Vert(12).SegType = msoSegmentCurve
        Vert(13).x = Vert(14).x
        Vert(13).y = Vert(14).y - (Vert(14).y - Vert(11).y) * bzrRatio
        Vert(13).SegType = msoSegmentCurve

        Vert(15).x = Vert(14).x
        Vert(15).y = .Top + .height

        Vert(16) = Vert(1)
    End With
End Sub

Private Sub SetVerticesFoldedCorner(shp As Shape)
    Dim i           As Long
    Dim ratio        As Single
    Dim curveH        As Single
    Dim shftx       As Long
    Dim shfty   As Long

    With shp
        InitVertices 10

        On Error Resume Next
        ratio = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio = 0.875
        End If
        
        
        If g_lApplicationVersion = 2007 Then
            If .width > .height Then
                shftx = .width - (.height * ratio)
                shfty = .height - (.height * ratio)
            Else
                shftx = .width - (.width * ratio)
                shfty = .height - (.width * ratio)
            End If
        Else
            shftx = .width * ratio
            shfty = .height * ratio
        End If
                
        ' the paper
        Vert(1).x = .Left + shftx
        Vert(1).y = .Top + .height
        Vert(2).x = .Left
        Vert(2).y = .Top + .height
        Vert(3).x = .Left
        Vert(3).y = .Top
        Vert(4).x = .Left + .width
        Vert(4).y = .Top
        Vert(5).x = .Left + .width
        Vert(5).y = .Top + shfty
        Vert(6) = Vert(1)

        ' the folded corner
        curveH = 0.16
        Dim rx As Single
        Dim ry As Single

        If g_lApplicationVersion = 2007 Then
            Vert(7).x = Vert(1).x + ((.width - shftx) - (0.75 * (.width - shftx)))
            Vert(7).y = Vert(5).y + ((.height - shfty) - (0.75 * (.height - shfty)))
            Vert(8) = Vert(7)
            Vert(9) = Vert(7)
        Else
            rx = 0.73 * ratio + 0.27
            ry = 0.96 * ratio + 0.04
    
            Vert(7).x = .Left + .width * rx
            Vert(7).y = .Top + .height * ry
            Vert(7).SegType = msoSegmentCurve
            Vert(8).x = .Left + .width * (0.2 + 0.8 * rx)
            Vert(8).y = .Top + .height * (ratio + curveH * (1 - ratio))
            'Vert(8).SegType = msoSegmentCurve
            Vert(9).x = .Left + .width * (0.5 + 0.5 * rx)
            Vert(9).y = Vert(8).y
            'Vert(9).SegType=msoSegmentCurve
        End If
            Vert(10) = Vert(5)
        

     End With

End Sub

Private Sub ParseFoldedCorner(shp As Shape)
    Dim i           As Long
    Dim ratio        As Single
    Dim curveH        As Single
    Dim shftx       As Long
    Dim shfty   As Long

    NewRotateNodes shp

    AddGroupItem
    With GroupItems(GroupItemNum)
        .SetShapeType (LEC_SHAPETYPE_POLYGON)
        .SetGraphstyle shp
        .InitVerts 1, 6, Vert, True
        .PrintPointsString
    End With

    Dim bSolidFilled As Boolean
    Dim colorCorner  As String
    Dim colorDumm  As String

    If shp.Fill.Visible = msoTrue Then
        bSolidFilled = True
        SetRelatedColors shp.Fill.ForeColor.RGB, colorDumm, colorDumm, colorCorner, colorDumm
    Else
        bSolidFilled = False
    End If

    AddGroupItem
    With GroupItems(GroupItemNum)
        .SetShapeType (LEC_SHAPETYPE_POLYGON)
        .SetGraphstyle shp
        .m_szFillColor = colorCorner
        .InitVerts 5, 6, Vert, True
        .PrintPointsString
    End With

    m_lecShapeType = LEC_SHAPETYPE_USERDEFINEDGROUP
End Sub

Private Sub SetVerticesPlaque(shp As Shape)
    Dim cirRatio    As Single
    Dim ratio   As Single
    Dim shftx   As Long
    Dim shfty   As Long
    Dim shft    As Long

    InitVertices 17
    With shp
        cirRatio = 0.28
        On Error Resume Next
        ratio = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio = 0.1666667
        End If

        If .width < .height Then
            shft = .width * ratio
        Else
            shft = .height * ratio
        End If
        shftx = shft * cirRatio * 2
        shfty = shftx

        Vert(1).x = .Left
        Vert(1).y = .Top + shft
        Vert(1).SegType = msoSegmentCurve
        Vert(2).x = Vert(1).x + shftx
        Vert(2).y = Vert(1).y
        Vert(2).SegType = msoSegmentCurve
        Vert(4).x = .Left + shft
        Vert(4).y = .Top
        Vert(3).x = Vert(4).x
        Vert(3).y = Vert(4).y + shfty
        Vert(3).SegType = msoSegmentCurve

        Vert(5).x = .Left + .width - shft
        Vert(5).y = .Top
        Vert(5).SegType = msoSegmentCurve
        Vert(6).x = Vert(5).x
        Vert(6).y = Vert(3).y
        Vert(6).SegType = msoSegmentCurve
        Vert(8).x = .Left + .width
        Vert(8).y = Vert(1).y
        Vert(7).x = Vert(8).x - shftx
        Vert(7).y = Vert(8).y
        Vert(7).SegType = msoSegmentCurve

        Vert(9).x = .Left + .width
        Vert(9).y = .Top + .height - shft
        Vert(9).SegType = msoSegmentCurve
        Vert(10).x = Vert(7).x
        Vert(10).y = Vert(9).y
        Vert(10).SegType = msoSegmentCurve
        Vert(12).x = Vert(5).x
        Vert(12).y = .Top + .height
        Vert(11).x = Vert(12).x
        Vert(11).y = Vert(12).y - shfty
        Vert(11).SegType = msoSegmentCurve

        Vert(13).x = Vert(4).x
        Vert(13).y = .Top + .height
        Vert(13).SegType = msoSegmentCurve
        Vert(14).x = Vert(13).x
        Vert(14).y = Vert(11).y
        Vert(14).SegType = msoSegmentCurve
        Vert(16).x = Vert(1).x
        Vert(16).y = Vert(9).y
        Vert(15).x = Vert(2).x
        Vert(15).y = Vert(10).y
        Vert(15).SegType = msoSegmentCurve

        Vert(17) = Vert(1)
    End With
End Sub

Private Sub SetVerticesDoubleBrace(shp As Shape)
    Dim i           As Long
    Dim cirRatio    As Single
    Dim ratio       As Single
    Dim shft        As Long
    Dim shftx       As Long
    Dim shfty       As Long

    With shp
        InitVertices 30

        On Error Resume Next
        cirRatio = 0.28
        ratio = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio = 0.08333334
        End If

        If .width < .height Then
            shft = .width * ratio
            shftx = shft * cirRatio * 2
        Else
            shft = .height * ratio
            shftx = shft * cirRatio * 2
        End If
        shfty = shftx

        'left brace

        Vert(1).x = .Left + shft * 2
        Vert(1).y = .Top
        Vert(1).SegType = msoSegmentCurve
        Vert(2).x = Vert(1).x - shftx
        Vert(2).y = Vert(1).y
        Vert(4).x = .Left + shft
        Vert(4).y = .Top + shft
        Vert(3).x = Vert(4).x
        Vert(3).y = Vert(4).y - shfty

        Vert(5).x = Vert(4).x
        Vert(5).y = .Top + .height / 2 - shft
        Vert(5).SegType = msoSegmentCurve
        Vert(6).x = Vert(5).x
        Vert(6).y = Vert(5).y + shfty
        Vert(8).x = .Left
        Vert(8).y = .Top + .height / 2
        Vert(8).SegType = msoSegmentCurve
        Vert(7).x = Vert(8).x + shftx
        Vert(7).y = Vert(8).y

        Vert(9).x = Vert(7).x
        Vert(9).y = Vert(7).y
        Vert(11).x = Vert(5).x
        Vert(11).y = Vert(8).y + shft
        Vert(10).x = Vert(11).x
        Vert(10).y = Vert(11).y - shfty

        Vert(12).x = Vert(11).x
        Vert(12).y = .Top + .height - shft
        Vert(12).SegType = msoSegmentCurve
        Vert(13).x = Vert(12).x
        Vert(13).y = Vert(12).y + shfty
        Vert(15).x = Vert(1).x
        Vert(15).y = .Top + .height
        Vert(14).x = Vert(2).x
        Vert(14).y = Vert(15).y

        ' right brace
        For i = 1 To 15
            Vert(31 - i).y = Vert(i).y
        Next

        Vert(16).x = .Left + .width - shft * 2
        Vert(16).SegType = msoSegmentCurve
        Vert(17).x = Vert(16).x + shftx
        Vert(19).x = .Left + .width - shft
        Vert(18).x = Vert(19).x

        Vert(20).x = Vert(19).x
        Vert(20).SegType = msoSegmentCurve
        Vert(21).x = Vert(20).x
        Vert(23).x = .Left + .width
        Vert(23).SegType = msoSegmentCurve
        Vert(22).x = Vert(23).x - shftx

        Vert(24) = Vert(22)
        Vert(26).x = Vert(20).x
        Vert(25).x = Vert(26).x

        Vert(27).x = Vert(26).x
        Vert(27).SegType = msoSegmentCurve
        Vert(28).x = Vert(27).x
        Vert(30).x = Vert(16).x
        Vert(29).x = Vert(17).x

    End With

End Sub

Private Sub ParseDoubleBrace(shp As Shape, Optional bRotateNodes As Boolean = True)
    Dim i           As Long

    SetGraphmode shp
    NewRotateNodes shp

    If m_lecDrawStyle = LEC_DRAWSTYLE_FILLED Or m_lecDrawStyle = LEC_DRAWSTYLE_FILLEDOUTLINE Then
        AddGroupItem
        With GroupItems(GroupItemNum)
            .SetShapeType (LEC_SHAPETYPE_POLYGON)
            .m_lecDrawStyle = LEC_DRAWSTYLE_FILLED
            .m_szLineColor = m_szFillColor
            .LineWidth = LineWidth
            .m_szFillColor = m_szFillColor
            .InitVerts 1, VertNum, Vert, True
            .PrintPointsString
        End With
    End If

    AddGroupItem        ' left bracket
    With GroupItems(GroupItemNum)
        .SetShapeType (LEC_SHAPETYPE_POLYGON)
        .m_lecDrawStyle = LEC_DRAWSTYLE_OUTLINE
        .m_szLineColor = m_szLineColor
        .LineStyle = LineStyle
        .LineWidth = LineWidth
        .InitVerts 1, 15, Vert
        .PrintPointsString
    End With

    AddGroupItem        ' right bracket
    With GroupItems(GroupItemNum)
        .SetShapeType (LEC_SHAPETYPE_POLYGON)
        .m_lecDrawStyle = LEC_DRAWSTYLE_OUTLINE
        .m_szLineColor = m_szLineColor
        .LineStyle = LineStyle
        .LineWidth = LineWidth
        .InitVerts 16, 15, Vert
        .PrintPointsString
    End With

    m_lecShapeType = LEC_SHAPETYPE_USERDEFINEDGROUP

End Sub

Private Sub SetVerticesDoubleBracket(shp As Shape, Optional bRotateNodes As Boolean = True)
    Dim i           As Long
    Dim cirRatio    As Single
    Dim ratio        As Single
    Dim shft        As Long
    Dim shftx       As Long
    Dim shfty   As Long

    With shp
        InitVertices 16

        On Error Resume Next
        cirRatio = 0.28
        ratio = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio = 0.1666667
        End If

        If .width < .height Then
            shft = .width * ratio
        Else
            shft = .height * ratio
        End If
        shftx = shft * cirRatio * 2
        shfty = shftx

        'left bracket
        Vert(1).x = .Left + shft
        Vert(1).y = .Top
        Vert(1).SegType = msoSegmentCurve
        Vert(2).x = Vert(1).x - shftx
        Vert(2).y = Vert(1).y
        Vert(4).x = .Left
        Vert(4).y = .Top + shft
        Vert(3).x = Vert(4).x
        Vert(3).y = Vert(4).y - shfty

        Vert(5).x = .Left
        Vert(5).y = .Top + .height - shft
        Vert(5).SegType = msoSegmentCurve
        Vert(6).x = Vert(5).x
        Vert(6).y = Vert(5).y + shfty
        Vert(8).x = Vert(1).x
        Vert(8).y = .Top + .height
        Vert(7).x = Vert(2).x
        Vert(7).y = Vert(8).y

        ' right bracket
        For i = 1 To 8
            Vert(17 - i).y = Vert(i).y
        Next

        Vert(9).x = .Left + .width - shft
        Vert(9).SegType = msoSegmentCurve
        Vert(10).x = Vert(9).x + shftx
        Vert(12).x = .Left + .width
        Vert(11).x = Vert(12).x

        Vert(13).x = .Left + .width
        Vert(13).SegType = msoSegmentCurve
        Vert(14).x = Vert(13).x
        Vert(16).x = Vert(9).x
        Vert(15).x = Vert(10).x

    End With

End Sub

Private Sub ParseDoubleBracket(shp As Shape, Optional bRotateNodes As Boolean = True)
    Dim i           As Long

    SetGraphmode shp
    NewRotateNodes shp

    If m_lecDrawStyle = LEC_DRAWSTYLE_FILLED Or m_lecDrawStyle = LEC_DRAWSTYLE_FILLEDOUTLINE Then
        AddGroupItem
        With GroupItems(GroupItemNum)
            .SetShapeType (LEC_SHAPETYPE_POLYGON)
            .m_lecDrawStyle = LEC_DRAWSTYLE_FILLED
            .m_szLineColor = m_szFillColor
            .LineWidth = LineWidth
            .m_szFillColor = m_szFillColor
            .InitVerts 1, VertNum, Vert, True
            .PrintPointsString
        End With
    End If

    AddGroupItem        ' left bracket
    With GroupItems(GroupItemNum)
        .SetShapeType (LEC_SHAPETYPE_POLYGON)
        .m_lecDrawStyle = LEC_DRAWSTYLE_OUTLINE
        .m_szLineColor = m_szLineColor
        .LineStyle = LineStyle
        .LineWidth = LineWidth
        .InitVerts 1, 8, Vert
        .PrintPointsString
    End With

    AddGroupItem        ' right bracket
    With GroupItems(GroupItemNum)
        .SetShapeType (LEC_SHAPETYPE_POLYGON)
        .m_lecDrawStyle = LEC_DRAWSTYLE_OUTLINE
        .m_szLineColor = m_szLineColor
        .LineStyle = LineStyle
        .LineWidth = LineWidth
        .InitVerts 9, 8, Vert
        .PrintPointsString
    End With

    m_lecShapeType = LEC_SHAPETYPE_USERDEFINEDGROUP

End Sub

Private Sub SetVerticesCross(shp As Shape)
    Dim ratio As Single
    Dim shftx As Long
    Dim shfty As Long

    InitVertices 13
    With shp
        On Error Resume Next
        ratio = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio = 0.25
        End If

        shftx = .width * ratio
        shfty = .height * ratio

        Vert(1).x = .Left
        Vert(1).y = .Top + shfty
        Vert(2).x = .Left + shftx
        Vert(2).y = Vert(1).y
        Vert(3).x = Vert(2).x
        Vert(3).y = .Top
        Vert(4).x = .Left + .width - shftx
        Vert(4).y = .Top
        Vert(5).x = Vert(4).x
        Vert(5).y = Vert(2).y

        Vert(6).x = .Left + .width
        Vert(6).y = Vert(5).y
        Vert(7).x = Vert(6).x
        Vert(7).y = .Top + .height - shfty
        Vert(8).x = Vert(5).x
        Vert(8).y = Vert(7).y
        Vert(9).x = Vert(8).x
        Vert(9).y = .Top + .height
        Vert(10).x = Vert(3).x
        Vert(10).y = Vert(9).y
        Vert(11).x = Vert(10).x
        Vert(11).y = Vert(8).y
        Vert(12).x = Vert(1).x
        Vert(12).y = Vert(11).y

        Vert(13) = Vert(1)
    End With
End Sub

Private Sub SetVerticesBevel(shp As Shape)
    Dim i           As Long
    Dim ratio       As Single
    Dim shft        As Long

    With shp
        InitVertices 8

        On Error Resume Next
        ratio = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio = 0.125
        End If
        
        If g_lApplicationVersion = 2007 Then
            ratio = 0
        End If

        If .width < .height Then
            shft = .width * ratio
        Else
            shft = .height * ratio
        End If

        Vert(1).x = .Left
        Vert(1).y = .Top
        Vert(2).x = .Left + .width
        Vert(2).y = .Top
        Vert(3).x = .Left + shft
        Vert(3).y = .Top + shft
        Vert(4).x = .Left + .width - shft
        Vert(4).y = .Top + shft

        Vert(5).x = Vert(3).x
        Vert(5).y = .Top + .height - shft
        Vert(6).x = Vert(4).x
        Vert(6).y = Vert(5).y
        Vert(7).x = .Left
        Vert(7).y = .Top + .height
        Vert(8).x = .Left + .width
        Vert(8).y = .Top + .height
    End With
End Sub

Private Sub ParseBevel(shp As Shape)
    Dim i           As Long
    Dim ratio       As Single
    Dim shft        As Long

    NewRotateNodes shp

    HasGroupItem = True
    GroupItemNum = 5
    ReDim GroupItems(1 To GroupItemNum) As aofShape

    With shp
        If .Fill.Visible = msoTrue Then
            m_lecDrawStyle = LEC_DRAWSTYLE_FILLED
            SetFillAttributes shp
        End If
        If .Line.Visible = msoTrue Then
            m_lecDrawStyle = m_lecDrawStyle + LEC_DRAWSTYLE_OUTLINE
            SetLineAttributes shp
        End If
    End With

    For i = 1 To GroupItemNum
        Set GroupItems(i) = New aofShape
        AddHyperlink GroupItems(i)
        
        With GroupItems(i)
            .SetShapeType (LEC_SHAPETYPE_POLYGON)
            .ReDimVert 5
            .m_lecDrawStyle = m_lecDrawStyle
            .m_szLineColor = m_szLineColor
            .LineStyle = LineStyle
            .LineWidth = LineWidth
            .m_szFillColor = m_szFillColor
        End With
    Next

    With shp
        'NodesRotate .Rotation

        Dim bSolidFilled As Boolean
        Dim colorLeft As String
        Dim colorUpper As String
        Dim colorBottom  As String
        Dim colorRight  As String

        If .Fill.Visible = msoTrue Then
            bSolidFilled = True
            SetRelatedColors .Fill.ForeColor.RGB, colorLeft, colorUpper, colorBottom, colorRight
        Else
            bSolidFilled = False
        End If

        With GroupItems(1)      ' north
            .Set5Vert Vert, 1, 2, 4, 3
            .PrintPointsString
            .m_szFillColor = colorUpper
        End With

        With GroupItems(2)      ' east
            .Set5Vert Vert, 1, 3, 5, 7
            .PrintPointsString
            .m_szFillColor = colorLeft
        End With

        With GroupItems(3)      ' south
            .Set5Vert Vert, 5, 6, 8, 7
            .PrintPointsString
            .m_szFillColor = colorBottom
        End With

        With GroupItems(4)      ' west
            .Set5Vert Vert, 2, 4, 6, 8
            .PrintPointsString
            .m_szFillColor = colorRight
        End With

        With GroupItems(5)      ' middle
            .Set5Vert Vert, 3, 4, 6, 5
            .PrintPointsString
        End With
    End With

    m_lecShapeType = LEC_SHAPETYPE_USERDEFINEDGROUP
End Sub

Sub Set5Vert(v() As aofNode, n1 As Long, n2 As Long, n3 As Long, n4 As Long)
    ReDimVert 5
    Vert(1) = v(n1)
    Vert(2) = v(n2)
    Vert(3) = v(n3)
    Vert(4) = v(n4)
    Vert(5) = v(n1)
End Sub

Sub ReDimVert(vn As Long)
    If vn < 1 Then
        Exit Sub
    End If
    HasVertices = True
    VertNum = vn
    ReDim Vert(1 To VertNum) As aofNode
End Sub

Private Sub SetVerticesFlowchartDisplay(shp As Shape)
    Dim cirRatio    As Single
    Dim ratio   As Single
    Dim shftx   As Long
    Dim shfty   As Long

    InitVertices 11
    With shp
        cirRatio = 0.28
        ratio = 0.1684
        shftx = .width * ratio * cirRatio * 2
        shfty = .height * cirRatio

        Vert(1).x = .Left + .width * (1 - ratio)
        Vert(1).y = .Top
        Vert(1).SegType = msoSegmentCurve
        Vert(2).x = Vert(1).x + shftx
        Vert(2).y = Vert(1).y
        Vert(2).SegType = msoSegmentCurve
        Vert(4).x = .Left + .width
        Vert(4).y = .Top + .height / 2
        Vert(4).SegType = msoSegmentCurve
        Vert(3).x = Vert(4).x
        Vert(3).y = Vert(4).y - shfty
        Vert(3).SegType = msoSegmentCurve
        Vert(5).x = Vert(4).x
        Vert(5).y = Vert(4).y + shfty
        Vert(5).SegType = msoSegmentCurve
        Vert(7).x = Vert(1).x
        Vert(7).y = .Top + .height
        Vert(6).x = Vert(2).x
        Vert(6).y = Vert(7).y
        Vert(6).SegType = msoSegmentCurve

        Vert(8).x = .Left + .width * ratio
        Vert(8).y = Vert(7).y
        Vert(9).x = .Left
        Vert(9).y = .Top + .height / 2
        Vert(10).x = Vert(8).x
        Vert(10).y = .Top

        Vert(11) = Vert(1)

    End With
End Sub

Private Sub SetVerticesFlowchartDirectAccessStorage(shp As Shape)
    Dim cirRatio    As Single
    Dim ratio   As Single
    Dim shftx   As Long
    Dim shfty   As Long

    InitVertices 27
    With shp
        cirRatio = 0.28
        ratio = 0.333
        shftx = .width * ratio * cirRatio
        shfty = .height * cirRatio

        Vert(1).x = .Left + .width * (1 - ratio / 2)
        Vert(1).y = .Top
        Vert(1).SegType = msoSegmentCurve
        Vert(2).x = Vert(1).x + shftx
        Vert(2).y = Vert(1).y
        Vert(2).SegType = msoSegmentCurve
        Vert(4).x = .Left + .width
        Vert(4).y = .Top + .height / 2
        Vert(4).SegType = msoSegmentCurve
        Vert(3).x = Vert(4).x
        Vert(3).y = Vert(4).y - shfty
        Vert(3).SegType = msoSegmentCurve
        Vert(5).x = Vert(4).x
        Vert(5).y = Vert(4).y + shfty
        Vert(5).SegType = msoSegmentCurve
        Vert(7).x = Vert(1).x
        Vert(7).y = .Top + .height
        Vert(7).SegType = msoSegmentCurve
        Vert(6).x = Vert(2).x
        Vert(6).y = Vert(7).y
        Vert(6).SegType = msoSegmentCurve

        Vert(8).x = Vert(7).x - shftx
        Vert(8).y = Vert(7).y
        Vert(8).SegType = msoSegmentCurve
        Vert(10).x = .Left + .width * (1 - ratio)
        Vert(10).y = Vert(4).y
        Vert(10).SegType = msoSegmentCurve
        Vert(9).x = Vert(10).x
        Vert(9).y = Vert(5).y
        Vert(9).SegType = msoSegmentCurve
        Vert(11).x = Vert(10).x
        Vert(11).y = Vert(3).y
        Vert(11).SegType = msoSegmentCurve
        Vert(12).x = Vert(1).x - shftx
        Vert(12).y = Vert(1).y
        Vert(12).SegType = msoSegmentCurve
        Vert(13).x = Vert(1).x
        Vert(13).y = Vert(1).y

        Vert(14).x = .Left + .width * ratio / 2
        Vert(14).y = .Top
        Vert(14).SegType = msoSegmentCurve
        Vert(15).x = Vert(14).x - shftx
        Vert(15).y = Vert(14).y
        Vert(15).SegType = msoSegmentCurve
        Vert(17).x = .Left
        Vert(17).y = Vert(10).y
        Vert(17).SegType = msoSegmentCurve
        Vert(16).x = Vert(17).x
        Vert(16).y = Vert(11).y
        Vert(16).SegType = msoSegmentCurve
        Vert(18).x = Vert(17).x
        Vert(18).y = Vert(9).y
        Vert(18).SegType = msoSegmentCurve
        Vert(20).x = Vert(14).x
        Vert(20).y = Vert(7).y
        Vert(19).x = Vert(15).x
        Vert(19).y = Vert(20).y
        Vert(19).SegType = msoSegmentCurve

        Vert(21) = Vert(7)
        Vert(22) = Vert(8)
        Vert(23) = Vert(9)
        Vert(24) = Vert(10)
        Vert(25) = Vert(11)
        Vert(26) = Vert(12)
        Vert(27) = Vert(13)
    End With
End Sub

Private Sub SetVerticesFlowchartSequentialAccessStorage(shp As Shape)
    Dim shftx   As Long
    Dim shfty   As Long
    Dim cirRatio    As Single
    Dim ratio   As Single
    Dim Tailw   As Single
    Dim tailL   As Single

    InitVertices 16
    With shp
        cirRatio = 0.28
        shftx = .width * cirRatio
        shfty = .height * cirRatio
        Tailw = 0.16
        tailL = 0.5 - Sqr(0.25 - 0.34 * 0.34)

        Vert(1).x = .Left
        Vert(1).y = .Top + .height / 2
        Vert(1).SegType = msoSegmentCurve
        Vert(2).x = Vert(1).x
        Vert(2).y = Vert(1).y - shfty
        Vert(2).SegType = msoSegmentCurve
        Vert(4).x = .Left + .width / 2
        Vert(4).y = .Top
        Vert(4).SegType = msoSegmentCurve
        Vert(3).x = Vert(4).x - shftx
        Vert(3).y = Vert(4).y
        Vert(3).SegType = msoSegmentCurve
        Vert(5).x = Vert(4).x + shftx
        Vert(5).y = Vert(4).y
        Vert(5).SegType = msoSegmentCurve
        Vert(7).x = .Left + .width
        Vert(7).y = Vert(1).y
        Vert(7).SegType = msoSegmentCurve
        Vert(6).x = Vert(7).x
        Vert(6).y = Vert(2).y
        Vert(6).SegType = msoSegmentCurve

        Vert(8).x = Vert(7).x
        Vert(8).y = Vert(7).y + shfty * 0.8
        Vert(8).SegType = msoSegmentCurve
        Vert(11).x = .Left + .width
        Vert(11).y = .Top + .height * (1 - Tailw)
        Vert(10).x = .Left + .width * (1 - tailL)
        Vert(10).y = Vert(11).y
        '!!!
        ratio = 0.35
        Vert(9).x = Vert(10).x + .width * tailL * ratio
        Vert(9).y = Vert(10).y - .height * Tailw * ratio
        Vert(9).SegType = msoSegmentCurve

        Vert(12).x = Vert(11).x
        Vert(12).y = .Top + .height

        Vert(13).x = Vert(4).x
        Vert(13).y = .Top + .height
        Vert(13).SegType = msoSegmentCurve
        Vert(14).x = Vert(3).x
        Vert(14).y = Vert(13).y
        Vert(14).SegType = msoSegmentCurve

        Vert(16) = Vert(1)

        Vert(15).x = Vert(16).x
        Vert(15).y = Vert(16).y + shfty
        Vert(15).SegType = msoSegmentCurve
    End With
End Sub

Private Sub SetVerticesFlowchartDelay(shp As Shape)
    Dim shftx   As Long
    Dim shfty   As Long

    InitVertices 10
    With shp
        shftx = .width / 4
        shfty = .height / 4

        Vert(1).x = .Left
        Vert(1).y = .Top

        Vert(2).x = .Left + .width / 2
        Vert(2).y = Vert(1).y
        Vert(2).SegType = msoSegmentCurve
        Vert(3).x = Vert(2).x + shftx
        Vert(3).y = .Top
        Vert(3).SegType = msoSegmentCurve
        Vert(5).x = .Left + .width
        Vert(5).y = .Top + .height / 2
        Vert(5).SegType = msoSegmentCurve
        Vert(4).x = Vert(5).x
        Vert(4).y = Vert(5).y - shfty
        Vert(4).SegType = msoSegmentCurve
        Vert(6).x = Vert(5).x
        Vert(6).y = Vert(5).y + shfty
        Vert(6).SegType = msoSegmentCurve
        Vert(8).x = Vert(2).x
        Vert(8).y = .Top + .height
        Vert(7).x = Vert(3).x
        Vert(7).y = Vert(8).y
        Vert(7).SegType = msoSegmentCurve

        Vert(9).x = Vert(1).x
        Vert(9).y = .Top + .height

        Vert(10) = Vert(1)
    End With
End Sub

Private Sub SetVerticesCan(shp As Shape)
    Dim ratio   As Single
    Dim shftx   As Long
    Dim shfty   As Long
    Dim i       As Long

    InitVertices 27
    With shp
        On Error Resume Next
        ratio = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio = 0.25
        End If

        shftx = .width / 4
        shfty = .height * ratio / 4

        Vert(1).x = .Left
        Vert(1).y = .Top + .height * ratio / 2
        Vert(1).SegType = msoSegmentCurve
        Vert(2).x = .Left
        Vert(2).y = Vert(1).y - shfty
        Vert(2).SegType = msoSegmentCurve
        Vert(4).x = .Left + .width / 2
        Vert(4).y = .Top
        Vert(4).SegType = msoSegmentCurve
        Vert(3).x = Vert(4).x - shftx
        Vert(3).y = Vert(4).y
        Vert(3).SegType = msoSegmentCurve
        Vert(5).x = Vert(4).x + shftx
        Vert(5).y = Vert(4).y
        Vert(5).SegType = msoSegmentCurve
        Vert(7).x = .Left + .width
        Vert(7).y = Vert(1).y
        Vert(7).SegType = msoSegmentCurve
        Vert(6).x = Vert(7).x
        Vert(6).y = Vert(7).y - shfty
        Vert(6).SegType = msoSegmentCurve

        Vert(8).x = Vert(7).x
        Vert(8).y = Vert(7).y + shfty
        Vert(8).SegType = msoSegmentCurve
        Vert(10).x = Vert(4).x
        Vert(10).y = .Top + .height * ratio
        Vert(10).SegType = msoSegmentCurve
        Vert(9).x = Vert(5).x
        Vert(9).y = Vert(10).y
        Vert(9).SegType = msoSegmentCurve
        Vert(11).x = Vert(3).x
        Vert(11).y = Vert(10).y
        Vert(11).SegType = msoSegmentCurve
        Vert(12).x = Vert(1).x
        Vert(12).y = Vert(8).y
        Vert(12).SegType = msoSegmentCurve
        Vert(13).x = Vert(1).x
        Vert(13).y = Vert(1).y

        Vert(14).x = Vert(1).x
        Vert(14).y = .Top + .height * (1 - ratio / 2)
        Vert(14).SegType = msoSegmentCurve
        Vert(15).x = Vert(14).x
        Vert(15).y = Vert(14).y + shfty
        Vert(15).SegType = msoSegmentCurve
        Vert(17).x = Vert(10).x
        Vert(17).y = .Top + .height
        Vert(17).SegType = msoSegmentCurve
        Vert(16).x = Vert(11).x
        Vert(16).y = Vert(17).y
        Vert(16).SegType = msoSegmentCurve
        Vert(18).x = Vert(9).x
        Vert(18).y = Vert(17).y
        Vert(18).SegType = msoSegmentCurve
        Vert(20).x = Vert(7).x
        Vert(20).y = Vert(14).y
        Vert(19).x = Vert(20).x
        Vert(19).y = Vert(15).y
        Vert(19).SegType = msoSegmentCurve

        Vert(21) = Vert(7)
        Vert(22) = Vert(8)
        Vert(23) = Vert(9)
        Vert(24) = Vert(10)
        Vert(25) = Vert(11)
        Vert(26) = Vert(12)
        Vert(27) = Vert(13)

    End With
End Sub

Private Sub ParseCan(shp As Shape)
    Dim i       As Long

    NewRotateNodes shp

    HasGroupItem = True
    GroupItemNum = 2
    ReDim GroupItems(1 To GroupItemNum) As aofShape

    If shp.Fill.Visible = msoTrue Then
        m_lecDrawStyle = LEC_DRAWSTYLE_FILLED
        SetFillAttributes shp
    End If
    If shp.Line.Visible = msoTrue Then
        m_lecDrawStyle = m_lecDrawStyle + LEC_DRAWSTYLE_OUTLINE
        SetLineAttributes shp
    End If

    For i = 1 To GroupItemNum
        Set GroupItems(i) = New aofShape
        AddHyperlink GroupItems(i)
        With GroupItems(i)
            .SetShapeType (LEC_SHAPETYPE_POLYGON)
            .ReDimVert 5
            .m_lecDrawStyle = m_lecDrawStyle
            .m_szLineColor = m_szLineColor
            .LineStyle = LineStyle
            .LineWidth = LineWidth
            .m_szFillColor = m_szFillColor
        End With
    Next

    Dim bSolidFilled As Boolean
    Dim colorUpper As String
    Dim colorDumm  As String

    If shp.Fill.Visible = msoTrue Then
        bSolidFilled = True
        SetRelatedColors shp.Fill.ForeColor.RGB, colorDumm, colorUpper, colorDumm, colorDumm
    Else
        bSolidFilled = False
    End If

    With GroupItems(1)      ' upper
        .SetVerts Vert, 1, 13
        .PrintPointsString
        If bSolidFilled And shp.AutoShapeType <> msoShapeFlowchartMagneticDisk Then
            .m_szFillColor = colorUpper
        End If
    End With

    With GroupItems(2)      ' front
        .SetVerts Vert, 13, 15
        .PrintPointsString
    End With

    'ImportShapeAsPolygon shp, True
    m_lecShapeType = LEC_SHAPETYPE_USERDEFINEDGROUP
End Sub

Private Sub SetVerticesFlowchartOr(shp As Shape)
    SetVerticesOval shp
End Sub


Private Sub ParseFlowchartOr(shp As Shape)
    Dim i           As Long
    Dim ratio       As Single

    SetGraphstyle shp

    ' circle
    If shp.Rotation = 0 Then
        AddGroupItem
        '' ?????
        GroupItems(GroupItemNum).ImportShapeAsOval shp
    Else
        NewRotateNodes shp
        AddGroupItem
        With GroupItems(GroupItemNum)
            .SetShapeType (LEC_SHAPETYPE_POLYGON)
            .m_lecDrawStyle = m_lecDrawStyle
            .m_szFillColor = m_szFillColor
            .m_szLineColor = m_szLineColor
            .InitVerts 1, VertNum, Vert, True
            .PrintPointsString
        End With
    End If

    If m_lecDrawStyle = LEC_DRAWSTYLE_OUTLINE Or m_lecDrawStyle = LEC_DRAWSTYLE_FILLEDOUTLINE Then
        Dim vtmp(1 To 4) As aofNode
        vtmp(1).x = shp.Left
        vtmp(1).y = shp.Top + shp.height / 2
        vtmp(2).x = shp.Left + shp.width
        vtmp(2).y = vtmp(1).y
        vtmp(3).x = shp.Left + shp.width / 2
        vtmp(3).y = shp.Top
        vtmp(4).x = vtmp(3).x
        vtmp(4).y = shp.Top + shp.height
        AddGroupItem
        With GroupItems(GroupItemNum)
            .SetVerts vtmp, 1, 2
            .NewRotateNodes shp
            .BuildLineWithVert False, False     ' without arrow
'            .m_lecShapeType = LEC_SHAPETYPE_LINE
'            .x = shp.Left + shp.Width * ratio
'            .y = shp.Top + shp.Height * ratio
'            .Width = shp.Width * (1 - ratio * 2)
'            .Height = shp.Height * (1 - ratio * 2)
            .SetLineAttributes shp, True
        End With

        AddGroupItem
        With GroupItems(GroupItemNum)
            .SetVerts vtmp, 3, 2
            .NewRotateNodes shp
            .BuildLineWithVert False, False     ' without arrow
'            .m_lecShapeType = LEC_SHAPETYPE_LINE
'            .x = shp.Left + shp.Width * (1 - ratio)
'            .y = shp.Top + shp.Height * ratio
'            .Width = -shp.Width * (1 - ratio * 2)
'            .Height = shp.Height * (1 - ratio * 2)
            .SetLineAttributes shp, True
        End With
        Erase vtmp
    End If

    m_lecShapeType = LEC_SHAPETYPE_USERDEFINEDGROUP
End Sub

Private Sub SetVerticesFlowchartSummingJunction(shp As Shape)
    SetVerticesOval shp
End Sub

Private Sub ParseFlowchartSummingJunction(shp As Shape)

    NewRotateNodes shp
    SetGraphstyle shp

    AddGroupItem
    With GroupItems(GroupItemNum)   ' circle
        .SetShapeType (LEC_SHAPETYPE_POLYGON)
        .SetGraphstyle shp
        .InitVerts 1, VertNum, Vert, True
        .PrintPointsString
    End With

    ' CANNOT use Line object. otherwise the shadow may be incorrect!!!
    If m_lecDrawStyle <> LEC_DRAWSTYLE_NONE Or m_lecDrawStyle <> LEC_DRAWSTYLE_FILLED Then
        Dim i           As Long
        Dim ratio       As Single
        Dim vtmp(1 To 4) As aofNode

        ratio = 0.5 - Sqr(2) / 4
        vtmp(1).x = shp.Left + shp.width * ratio
        vtmp(1).y = shp.Top + shp.height * ratio
        vtmp(2).x = vtmp(1).x + shp.width * (1 - ratio * 2)
        vtmp(2).y = vtmp(1).y + shp.height * (1 - ratio * 2)
        vtmp(3).x = vtmp(1).x
        vtmp(3).y = vtmp(2).y
        vtmp(4).x = vtmp(2).x
        vtmp(4).y = vtmp(1).y
        AddGroupItem
        With GroupItems(GroupItemNum)
            .SetVerts vtmp, 1, 2
            .NewRotateNodes shp
            .m_lecDrawStyle = m_lecDrawStyle
            .SetLineAttributes shp, True
            .PrintPointsString
            .SetShapeType (LEC_SHAPETYPE_POLYGON)
        End With
        AddGroupItem
        With GroupItems(GroupItemNum)
            .SetVerts vtmp, 3, 2
            .NewRotateNodes shp
            .m_lecDrawStyle = m_lecDrawStyle
            .SetLineAttributes shp, True
            .PrintPointsString
            .SetShapeType (LEC_SHAPETYPE_POLYGON)
        End With
        Erase vtmp
    End If

    m_lecShapeType = LEC_SHAPETYPE_USERDEFINEDGROUP
End Sub

Private Sub SetVerticesFlowchartTerminator(shp As Shape)
    Dim shftx   As Long
    Dim shfty   As Long

    InitVertices 15
    With shp
        shftx = .width * 0.08
        shfty = .height * 0.25

        Vert(1).x = .Left + .width * 0.15
        Vert(1).y = .Top

        Vert(2).x = .Left + .width * 0.85
        Vert(2).y = .Top
        Vert(2).SegType = msoSegmentCurve
        Vert(3).x = .Left + .width - shftx
        Vert(3).y = .Top
        Vert(3).SegType = msoSegmentCurve
        Vert(4).x = .Left + .width
        Vert(4).y = .Top + shfty
        Vert(4).SegType = msoSegmentCurve
        Vert(5).x = .Left + .width
        Vert(5).y = .Top + .height / 2
        Vert(5).SegType = msoSegmentCurve
        Vert(6).x = Vert(4).x
        Vert(6).y = .Top + .height - shfty
        Vert(6).SegType = msoSegmentCurve
        Vert(7).x = Vert(3).x
        Vert(7).y = .Top + .height
        Vert(7).SegType = msoSegmentCurve
        Vert(8).x = Vert(2).x
        Vert(8).y = .Top + .height


        Vert(9).x = Vert(1).x
        Vert(9).y = Vert(8).y
        Vert(9).SegType = msoSegmentCurve
        Vert(10).x = .Left + shftx
        Vert(10).y = Vert(7).y
        Vert(10).SegType = msoSegmentCurve
        Vert(11).x = .Left
        Vert(11).y = Vert(6).y
        Vert(11).SegType = msoSegmentCurve
        Vert(12).x = .Left
        Vert(12).y = Vert(5).y
        Vert(12).SegType = msoSegmentCurve
        Vert(13).x = Vert(11).x
        Vert(13).y = Vert(4).y
        Vert(13).SegType = msoSegmentCurve
        Vert(14).x = Vert(10).x
        Vert(14).y = Vert(3).y
        Vert(14).SegType = msoSegmentCurve

        Vert(15) = Vert(1)

    End With
End Sub

Private Sub SetVerticesFlowchartAlternateProcess(shp As Shape)
    Dim ratio   As Single
    Dim cirRatio    As Single
    Dim shftx   As Long
    Dim shfty   As Long

    InitVertices 17
    With shp
        cirRatio = 0.28
        On Error Resume Next
        ratio = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio = 0.12
        End If
        If .width > .height Then
            shftx = .height * ratio * (1 - cirRatio * 2)
        Else
            shftx = .width * ratio * (1 - cirRatio * 2)
        End If
        shfty = shftx

        Vert(1).x = .Left
        Vert(1).y = .Top + shfty + shfty
        Vert(1).SegType = msoSegmentCurve
        Vert(2).x = .Left
        Vert(2).y = .Top + shfty
        Vert(2).SegType = msoSegmentCurve
        Vert(3).x = .Left + shftx
        Vert(3).y = .Top
        Vert(3).SegType = msoSegmentCurve
        Vert(4).x = .Left + shftx + shftx
        Vert(4).y = .Top

        Vert(5).x = .Left + .width - shftx - shftx
        Vert(5).y = .Top
        Vert(5).SegType = msoSegmentCurve
        Vert(6).x = .Left + .width - shftx
        Vert(6).y = .Top
        Vert(6).SegType = msoSegmentCurve
        Vert(7).x = .Left + .width
        Vert(7).y = .Top + shfty
        Vert(7).SegType = msoSegmentCurve
        Vert(8).x = .Left + .width
        Vert(8).y = .Top + shfty + shfty

        Vert(9).x = Vert(8).x
        Vert(9).y = .Top + .height - shfty - shfty
        Vert(9).SegType = msoSegmentCurve
        Vert(10).x = Vert(9).x
        Vert(10).y = .Top + .height - shfty
        Vert(10).SegType = msoSegmentCurve
        Vert(11).x = Vert(6).x
        Vert(11).y = .Top + .height
        Vert(11).SegType = msoSegmentCurve
        Vert(12).x = Vert(5).x
        Vert(12).y = .Top + .height

        Vert(13).x = Vert(4).x
        Vert(13).y = Vert(12).y
        Vert(13).SegType = msoSegmentCurve
        Vert(14).x = Vert(3).x
        Vert(14).y = Vert(13).y
        Vert(14).SegType = msoSegmentCurve
        Vert(15).x = .Left
        Vert(15).y = .Top + .height - shfty
        Vert(15).SegType = msoSegmentCurve
        Vert(16).x = .Left
        Vert(16).y = Vert(9).y

        Vert(17).x = Vert(1).x
        Vert(17).y = Vert(1).y
    End With
End Sub
Private Sub SetVerticesFlowchartMultidocument(shp As Shape)
    InitVertices 22
    With shp

        Vert(1).x = .Left
        Vert(1).y = .Top + .height * 0.18
        Vert(2).x = .Left + .width * 0.86
        Vert(2).y = Vert(1).y
        Vert(3).x = .Left + .width * 0.07
        Vert(3).y = Vert(1).y
        Vert(4).x = Vert(3).x
        Vert(4).y = .Top + .height * 0.09
        Vert(5).x = .Left + .width * 0.93
        Vert(5).y = Vert(4).y
        Vert(6).x = .Left + .width * 0.14
        Vert(6).y = Vert(5).y
        Vert(7).x = Vert(6).x
        Vert(7).y = .Top

        Vert(8).x = .Left + .width
        Vert(8).y = .Top
        Vert(9).x = Vert(8).x
        Vert(9).y = .Top + .height * 0.67
        Vert(10).x = Vert(5).x
        Vert(10).y = Vert(9).y
        Vert(11) = Vert(5)
        Vert(12).x = Vert(10).x
        Vert(12).y = .Top + .height * 0.75
        Vert(13).x = Vert(2).x
        Vert(13).y = Vert(12).y
        Vert(14) = Vert(2)

        Vert(15).x = Vert(13).x
        Vert(15).y = .Top + .height * 0.83
        Vert(15).SegType = msoSegmentCurve
        Vert(16).x = .Left + .width * 0.55
        Vert(16).y = Vert(15).y
        Vert(16).SegType = msoSegmentCurve
        Vert(17).x = .Left + .width * 0.45
        Vert(17).y = .Top + .height
        Vert(17).SegType = msoSegmentCurve
        Vert(18).x = .Left + .width * 0.3
        Vert(18).y = .Top + .height
        Vert(18).SegType = msoSegmentCurve
        Vert(19).x = .Left + .width * 0.15
        Vert(19).y = .Top + .height
        Vert(19).SegType = msoSegmentCurve
        Vert(20).x = .Left
        Vert(20).y = .Top + .height * 0.95
        Vert(21) = Vert(20)
        Vert(20).SegType = msoSegmentCurve

        Vert(22) = Vert(1)
    End With
End Sub

Private Sub ParseFlowchartMultidocument(shp As Shape, Optional bRotateNodes As Boolean = True)

    VertNum = 22

    ReDim Vert(1 To VertNum) As aofNode

    With shp

        Vert(1).x = .Left
        Vert(1).y = .Top + .height * 0.18
        Vert(2).x = .Left + .width * 0.86
        Vert(2).y = Vert(1).y
        Vert(3).x = .Left + .width * 0.07
        Vert(3).y = Vert(1).y
        Vert(4).x = Vert(3).x
        Vert(4).y = .Top + .height * 0.09
        Vert(5).x = .Left + .width * 0.93
        Vert(5).y = Vert(4).y
        Vert(6).x = .Left + .width * 0.14
        Vert(6).y = Vert(5).y
        Vert(7).x = Vert(6).x
        Vert(7).y = .Top

        Vert(8).x = .Left + .width
        Vert(8).y = .Top
        Vert(9).x = Vert(8).x
        Vert(9).y = .Top + .height * 0.67
        Vert(10).x = Vert(5).x
        Vert(10).y = Vert(9).y
        Vert(11) = Vert(5)
        Vert(12).x = Vert(10).x
        Vert(12).y = .Top + .height * 0.75
        Vert(13).x = Vert(2).x
        Vert(13).y = Vert(12).y
        Vert(14) = Vert(2)

        Vert(15).x = Vert(13).x
        Vert(15).y = .Top + .height * 0.83
        Vert(15).SegType = msoSegmentCurve
        Vert(16).x = .Left + .width * 0.55
        Vert(16).y = Vert(15).y
        Vert(16).SegType = msoSegmentCurve
        Vert(17).x = .Left + .width * 0.45
        Vert(17).y = .Top + .height
        Vert(17).SegType = msoSegmentCurve
        Vert(18).x = .Left + .width * 0.3
        Vert(18).y = .Top + .height
        Vert(18).SegType = msoSegmentCurve
        Vert(19).x = .Left + .width * 0.15
        Vert(19).y = .Top + .height
        Vert(19).SegType = msoSegmentCurve
        Vert(20).x = .Left
        Vert(20).y = .Top + .height * 0.95
        Vert(21) = Vert(20)
        Vert(20).SegType = msoSegmentCurve

        Vert(22) = Vert(1)

        FlipNodes Vert, VertNum, shp
        If bRotateNodes Then
            NodesRotate .Rotation
        End If
    End With
    ImportShapeAsPolygon shp, True

End Sub

Private Sub SetVerticesFlowchartDocument(shp As Shape)

    InitVertices 10
    With shp
        Vert(1).x = .Left
        Vert(1).y = .Top
        Vert(2).x = .Left + .width
        Vert(2).y = .Top
        Vert(3).x = Vert(2).x
        Vert(3).y = .Top + .height * 0.8
        Vert(3).SegType = msoSegmentCurve
        Vert(4).x = Vert(3).x - .width / 4
        Vert(4).y = Vert(3).y
        Vert(4).SegType = msoSegmentCurve
        Vert(5).x = .Left + .width * 0.375
        Vert(5).y = .Top + .height
        Vert(5).SegType = msoSegmentCurve
        Vert(6).x = .Left + .width / 4
        Vert(6).y = Vert(5).y
        Vert(6).SegType = msoSegmentCurve
        Vert(7).x = .Left + .width / 8
        Vert(7).y = Vert(6).y
        Vert(7).SegType = msoSegmentCurve

        Vert(8).x = .Left
        Vert(8).y = .Top + .height * 0.93
        Vert(9) = Vert(8)
        Vert(8).SegType = msoSegmentCurve
        Vert(10) = Vert(1)
    End With
End Sub

Private Sub SetVerticesFlowchartInternalStorage(shp As Shape)

    InitVertices 11
    With shp
        Vert(1).x = .Left
        Vert(1).y = .Top
        Vert(2).x = .Left + .width
        Vert(2).y = .Top
        Vert(3).x = Vert(2).x
        Vert(3).y = .Top + .height
        Vert(4).x = .Left + .width * 0.2
        Vert(4).y = Vert(3).y
        Vert(5).x = Vert(4).x
        Vert(5).y = .Top
        Vert(6) = Vert(4)
        Vert(7).x = .Left
        Vert(7).y = Vert(4).y

        Vert(8).x = .Left
        Vert(8).y = .Top + .height * 0.2
        Vert(9).x = Vert(2).x
        Vert(9).y = Vert(8).y
        Vert(10) = Vert(8)
        Vert(11) = Vert(1)
    End With
End Sub

Private Sub SetVerticesFlowchartPredefinedProcess(shp As Shape)

    Dim shftx As Single

    InitVertices 11
    With shp
        shftx = .width * 0.12

        Vert(1).x = .Left
        Vert(1).y = .Top
        Vert(2).x = .Left + .width
        Vert(2).y = .Top
        Vert(3).x = Vert(2).x
        Vert(3).y = .Top + .height
        Vert(4).x = Vert(3).x - shftx
        Vert(4).y = Vert(3).y
        Vert(5).x = Vert(4).x
        Vert(5).y = .Top
        Vert(6) = Vert(4)
        Vert(7).x = .Left + shftx
        Vert(7).y = Vert(4).y

        Vert(8).x = Vert(7).x
        Vert(8).y = .Top
        Vert(9) = Vert(7)
        Vert(10).x = .Left
        Vert(10).y = Vert(9).y
        Vert(11) = Vert(1)
    End With
End Sub

Private Sub SetVerticesFlowchartPunchedTape(shp As Shape)

    Dim shftx As Long
    Dim shfty   As Long
    Dim ctrlshft As Long

    InitVertices 15
    With shp
        shftx = .width * 0.1
        shfty = .height * 0.1
        ctrlshft = .width * 0.06

        Vert(1).x = .Left
        Vert(1).y = .Top + shfty
        Vert(1).SegType = msoSegmentCurve
        Vert(2).x = .Left + ctrlshft
        Vert(2).y = .Top + shfty + shfty
        Vert(2).SegType = msoSegmentCurve
        Vert(3).x = .Left + .width / 2 - ctrlshft
        Vert(3).y = Vert(2).y
        Vert(3).SegType = msoSegmentCurve
        Vert(4).x = .Left + .width / 2
        Vert(4).y = Vert(1).y
        Vert(4).SegType = msoSegmentCurve

        Vert(5).x = Vert(4).x + ctrlshft
        Vert(5).y = .Top
        Vert(5).SegType = msoSegmentCurve
        Vert(6).x = .Left + .width - ctrlshft
        Vert(6).y = .Top
        Vert(6).SegType = msoSegmentCurve
        Vert(7).x = .Left + .width
        Vert(7).y = Vert(4).y

        Vert(8).x = Vert(7).x
        Vert(8).y = .Top + .height - shfty
        Vert(8).SegType = msoSegmentCurve
        Vert(9).x = Vert(6).x
        Vert(9).y = Vert(8).y - shfty
        Vert(9).SegType = msoSegmentCurve
        Vert(10).x = Vert(5).x
        Vert(10).y = Vert(9).y
        Vert(10).SegType = msoSegmentCurve
        Vert(11).x = Vert(4).x
        Vert(11).y = Vert(8).y
        Vert(11).SegType = msoSegmentCurve

        Vert(12).x = Vert(3).x
        Vert(12).y = .Top + .height
        Vert(12).SegType = msoSegmentCurve
        Vert(13).x = Vert(2).x
        Vert(13).y = Vert(12).y
        Vert(13).SegType = msoSegmentCurve
        Vert(14).x = .Left
        Vert(14).y = Vert(11).y

        Vert(15) = Vert(1)
    End With
End Sub

Private Sub SetVerticesFlowchartStoredData(shp As Shape)

    Dim shftx As Long
    Dim shfty   As Long

    InitVertices 15
    With shp
        shftx = .width * 0.1
        shfty = .height * 0.1

        Vert(1).x = .Left + shftx * 2
        Vert(1).y = .Top
        Vert(2).x = .Left + .width
        Vert(2).y = .Top
        Vert(2).SegType = msoSegmentCurve
        Vert(3).x = .Left + .width - shftx
        Vert(3).y = .Top + shfty / 2    '.Top + shfty
        Vert(3).SegType = msoSegmentCurve
        Vert(4).x = .Left + .width - shftx * 2
        Vert(4).y = .Top + .height / 2 - shfty * 3 '2
        Vert(4).SegType = msoSegmentCurve
        Vert(5).x = Vert(4).x
        Vert(5).y = .Top + .height / 2
        Vert(5).SegType = msoSegmentCurve
        Vert(6).x = Vert(5).x
        Vert(6).y = Vert(5).y * 2 - Vert(4).y
        Vert(6).SegType = msoSegmentCurve
        Vert(7).x = Vert(3).x
        Vert(7).y = Vert(5).y * 2 - Vert(3).y
        Vert(7).SegType = msoSegmentCurve
        Vert(8).x = Vert(2).x
        Vert(8).y = .Top + .height

        Vert(9).x = Vert(1).x
        Vert(9).y = Vert(8).y
        Vert(9).SegType = msoSegmentCurve
        Vert(10).x = Vert(7).x + shftx * 2 - .width
        Vert(10).y = Vert(7).y
        Vert(10).SegType = msoSegmentCurve
        Vert(11).x = .Left
        Vert(11).y = Vert(6).y
        Vert(11).SegType = msoSegmentCurve
        Vert(12).x = Vert(11).x
        Vert(12).y = Vert(5).y
        Vert(12).SegType = msoSegmentCurve
        Vert(13).x = Vert(12).x
        Vert(13).y = Vert(4).y
        Vert(13).SegType = msoSegmentCurve
        Vert(14).x = Vert(10).x
        Vert(14).y = Vert(3).y
        Vert(14).SegType = msoSegmentCurve
        Vert(15) = Vert(1)
    End With
End Sub

Private Sub SetVerticesFlowchartMerge(shp As Shape)

    InitVertices 4
    With shp
        Vert(1).x = .Left
        Vert(1).y = .Top
        Vert(2).x = .Left + .width / 2
        Vert(2).y = .Top + .height
        Vert(3).x = .Left + .width
        Vert(3).y = Vert(1).y
        Vert(4) = Vert(1)
    End With
End Sub

Private Sub SetVerticesFlowchartExtract(shp As Shape)

    InitVertices 4
    With shp
        Vert(1).x = .Left
        Vert(1).y = .Top + .height
        Vert(2).x = .Left + .width / 2
        Vert(2).y = .Top
        Vert(3).x = .Left + .width
        Vert(3).y = Vert(1).y
        Vert(4) = Vert(1)
    End With
End Sub

Private Sub SetVerticesFlowchartSort(shp As Shape)

    InitVertices 6
    With shp
        Vert(1).x = .Left
        Vert(1).y = .Top + .height / 2
        Vert(2).x = .Left + .width / 2
        Vert(2).y = .Top
        Vert(3).x = .Left + .width
        Vert(3).y = Vert(1).y
        Vert(4).x = Vert(2).x
        Vert(4).y = .Top + .height

        Vert(5) = Vert(1)
        Vert(6) = Vert(3)
    End With
End Sub

Private Sub SetVerticesFlowchartCollate(shp As Shape)
    InitVertices 5
    With shp
        Vert(1).x = .Left
        Vert(1).y = .Top
        Vert(2).x = .Left + .width
        Vert(2).y = .Top
        Vert(3).x = .Left
        Vert(3).y = .Top + .height
        Vert(4).x = .Left + .width
        Vert(4).y = .Top + .height

        Vert(5) = Vert(1)
    End With
End Sub

Private Sub SetVerticesFlowchartCard(shp As Shape)

    InitVertices 6
    With shp

        Vert(1).x = .Left
        Vert(1).y = .Top + .height * 0.2
        Vert(2).x = .Left + .width * 0.2
        Vert(2).y = .Top
        Vert(3).x = .Left + .width
        Vert(3).y = .Top
        Vert(4).x = .Left + .width
        Vert(4).y = .Top + .height
        Vert(5).x = .Left
        Vert(5).y = .Top + .height

        Vert(6) = Vert(1)
    End With
End Sub

Private Sub SetVerticesFlowchartManualInput(shp As Shape)

    InitVertices 5
    With shp
        Vert(1).x = .Left
        Vert(1).y = .Top + .height * 0.2
        Vert(2).x = .Left + .width
        Vert(2).y = .Top
        Vert(3).x = Vert(2).x
        Vert(3).y = .Top + .height
        Vert(4).x = .Left
        Vert(4).y = .Top + .height

        Vert(5) = Vert(1)
    End With
End Sub

Private Sub SetVerticesFlowchartOffpageConnector(shp As Shape)

    InitVertices 6
    With shp
        Vert(1).x = .Left
        Vert(1).y = .Top
        Vert(2).x = .Left + .width
        Vert(2).y = .Top
        Vert(3).x = Vert(2).x
        Vert(3).y = .Top + .height * 0.8
        Vert(4).x = .Left + .width / 2
        Vert(4).y = .Top + .height
        Vert(5).x = .Left
        Vert(5).y = Vert(3).y

        Vert(6) = Vert(1)
    End With
End Sub

Private Sub SetVerticesQuadArrow(shp As Shape)
    Dim shft3 As Single
    Dim shft1 As Single
    Dim shft2 As Single

    InitVertices 25

    With shp
        On Error Resume Next
        shft1 = 0.3
        shft2 = 0.4
        shft3 = 0.2

        shft1 = .Adjustments(1)
        shft2 = .Adjustments(2)
        shft3 = .Adjustments(3)

        If g_lApplicationVersion = 2007 Then
            If shft2 + shft3 > 0.5 Then
                shft3 = 0.5 - shft2
            End If
            If shft1 > 2 * shft2 Then
                shft1 = 2 * shft2
            End If
            
            Dim sz As Single
            sz = IIf(.width > .height, .height, .width)
            
            Vert(1).x = .Left + .width / 2
            Vert(1).y = .Top
            Vert(2).x = Vert(1).x + shft2 * sz
            Vert(2).y = Vert(1).y + shft3 * sz
            Vert(3).x = Vert(1).x + shft1 * sz / 2
            Vert(3).y = Vert(2).y
            Vert(4).x = Vert(3).x
            Vert(4).y = .Top + .height / 2 - shft1 * sz / 2
            Vert(5).x = .Left + .width - shft3 * sz
            Vert(5).y = Vert(4).y
            Vert(6).x = Vert(5).x
            Vert(6).y = .Top + .height / 2 - shft2 * sz
            Vert(7).x = .Left + .width
            Vert(7).y = .Top + .height / 2
            Vert(8).x = Vert(6).x
            Vert(8).y = Vert(7).y + shft2 * sz
            Vert(9).x = Vert(8).x
            Vert(9).y = Vert(7).y + shft1 * sz / 2
            Vert(10).x = Vert(4).x
            Vert(10).y = Vert(9).y
            Vert(11).x = Vert(10).x
            Vert(11).y = .Top + .height - shft3 * sz
            Vert(12).x = Vert(2).x
            Vert(12).y = Vert(11).y
            Vert(13).x = .Left + .width / 2
            Vert(13).y = .Top + .height
            Vert(14).x = Vert(13).x - shft2 * sz
            Vert(14).y = Vert(12).y
            Vert(15).x = Vert(13).x - shft1 * sz / 2
            Vert(15).y = Vert(11).y
            Vert(16).x = Vert(15).x
            Vert(16).y = Vert(10).y
            Vert(17).x = .Left + shft3 * sz
            Vert(17).y = Vert(16).y
            Vert(18).x = Vert(17).x
            Vert(18).y = Vert(8).y
            Vert(19).x = .Left
            Vert(19).y = Vert(7).y
            Vert(20).x = Vert(18).x
            Vert(20).y = Vert(6).y
            Vert(21).x = Vert(17).x
            Vert(21).y = Vert(4).y
            Vert(22).x = Vert(16).x
            Vert(22).y = Vert(4).y
            Vert(23).x = Vert(22).x
            Vert(23).y = Vert(3).y
            Vert(24).x = Vert(14).x
            Vert(24).y = Vert(3).y
            Vert(25) = Vert(1)
        Else
        Vert(1).x = .Left
        Vert(1).y = .Top + .height / 2
        Vert(2).x = .Left + .width * shft3
        Vert(2).y = .Top + .height * shft1
        Vert(3).x = Vert(2).x
        Vert(3).y = .Top + .height * shft2
        Vert(4).x = .Left + .width * shft2
        Vert(4).y = Vert(3).y
        Vert(5).x = Vert(4).x
        Vert(5).y = .Top + .height * shft3
        Vert(6).x = .Left + .width * shft1
        Vert(6).y = Vert(5).y

        Vert(7).x = .Left + .width / 2
        Vert(7).y = .Top
        Vert(8).x = .Left + .width * (1 - shft1)
        Vert(8).y = Vert(6).y
        Vert(9).x = .Left + .width * (1 - shft2)
        Vert(9).y = Vert(5).y
        Vert(10).x = Vert(9).x
        Vert(10).y = Vert(4).y
        Vert(11).x = .Left + .width * (1 - shft3)
        Vert(11).y = Vert(4).y
        Vert(12).x = Vert(11).x
        Vert(12).y = Vert(2).y

        Vert(13).x = .Left + .width
        Vert(13).y = Vert(1).y
        Vert(14).x = Vert(11).x
        Vert(14).y = .Top + .height * (1 - shft1)
        Vert(15).x = Vert(14).x
        Vert(15).y = .Top + .height * (1 - shft2)
        Vert(16).x = Vert(10).x
        Vert(16).y = Vert(15).y
        Vert(17).x = Vert(16).x
        Vert(17).y = .Top + .height * (1 - shft3)
        Vert(18).x = Vert(8).x
        Vert(18).y = Vert(17).y

        Vert(19).x = Vert(7).x
        Vert(19).y = .Top + .height
        Vert(20).x = Vert(6).x
        Vert(20).y = Vert(17).y
        Vert(21).x = Vert(4).x
        Vert(21).y = Vert(17).y
        Vert(22).x = Vert(4).x
        Vert(22).y = Vert(16).y
        Vert(23).x = Vert(3).x
        Vert(23).y = Vert(22).y
        Vert(24).x = Vert(3).x
        Vert(24).y = Vert(14).y

        Vert(25) = Vert(1)
        End If
    End With
End Sub

Private Sub SetVerticesQuadArrowCallout(shp As Shape)
    Dim shftx1 As Single
    Dim shftx2 As Single
    Dim shfty1 As Single
    Dim shfty2 As Single
    Dim shftx3 As Single
    Dim shfty3 As Single
    Dim shftx4 As Single
    Dim shfty4 As Single

    Dim arrh    As Single
    Dim lArrB   As Single
    Dim lNeck   As Single
    Dim sqAng   As Single

    InitVertices 33
    With shp
        On Error Resume Next
        lArrB = 0.375
        lArrB = .Adjustments(2) '
        lNeck = 0.4375
        lNeck = .Adjustments(4) '
        arrh = 0.125
        arrh = .Adjustments(3)  '
        sqAng = 0.25
        sqAng = .Adjustments(1)

        shftx1 = .width * arrh
        shfty1 = .height * arrh
        shftx2 = .width * sqAng
        shfty2 = .height * sqAng
        shftx3 = .width * lArrB
        shfty3 = .height * lArrB
        shftx4 = .width * lNeck
        shfty4 = .height * lNeck

        Vert(1).x = .Left
        Vert(1).y = .Top + .height / 2
        Vert(2).x = .Left + shftx1
        Vert(2).y = .Top + shfty3
        Vert(3).x = Vert(2).x
        Vert(3).y = .Top + shfty4
        Vert(4).x = .Left + shftx2
        Vert(4).y = Vert(3).y
        Vert(5).x = Vert(4).x
        Vert(5).y = .Top + shfty2
        Vert(6).x = .Left + shftx4
        Vert(6).y = Vert(5).y
        Vert(7).x = Vert(6).x
        Vert(7).y = .Top + shfty1
        Vert(8).x = .Left + shftx3
        Vert(8).y = Vert(7).y

        Vert(9).x = .Left + .width / 2
        Vert(9).y = .Top
        Vert(10).x = .Left + .width - shftx3
        Vert(10).y = Vert(8).y
        Vert(11).x = .Left + .width - shftx4
        Vert(11).y = Vert(10).y
        Vert(12).x = Vert(11).x
        Vert(12).y = Vert(6).y
        Vert(13).x = .Left + .width - shftx2
        Vert(13).y = Vert(12).y
        Vert(14).x = Vert(13).x
        Vert(14).y = Vert(4).y
        Vert(15).x = .Left + .width - shftx1
        Vert(15).y = Vert(14).y
        Vert(16).x = Vert(15).x
        Vert(16).y = Vert(2).y

        Vert(17).x = .Left + .width
        Vert(17).y = Vert(1).y
        Vert(18).x = Vert(16).x
        Vert(18).y = .Top + .height - shfty3
        Vert(19).x = Vert(18).x
        Vert(19).y = .Top + .height - shfty4
        Vert(20).x = Vert(14).x
        Vert(20).y = Vert(19).y
        Vert(21).x = Vert(20).x
        Vert(21).y = .Top + .height - shfty2
        Vert(22).x = Vert(12).x
        Vert(22).y = Vert(21).y
        Vert(23).x = Vert(22).x
        Vert(23).y = .Top + .height - shfty1
        Vert(24).x = Vert(10).x
        Vert(24).y = Vert(23).y

        Vert(25).x = Vert(9).x
        Vert(25).y = .Top + .height
        Vert(26).x = Vert(8).x
        Vert(26).y = Vert(24).y
        Vert(27).x = Vert(7).x
        Vert(27).y = Vert(26).y
        Vert(28).x = Vert(27).x
        Vert(28).y = Vert(22).y
        Vert(29).x = Vert(5).x
        Vert(29).y = Vert(28).y
        Vert(30).x = Vert(29).x
        Vert(30).y = Vert(20).y
        Vert(31).x = Vert(3).x
        Vert(31).y = Vert(30).y
        Vert(32).x = Vert(31).x
        Vert(32).y = Vert(18).y

        Vert(33) = Vert(1)
    End With
End Sub


Private Sub SetVerticesLeftRightArrowCallout(shp As Shape)
    Dim shftx1 As Single
    Dim shftx2 As Single
    Dim shfty1 As Single
    Dim shfty2 As Single

    InitVertices 19
    With shp
        On Error Resume Next
        shftx1 = .width * 0.125
        shftx2 = .width * 0.25
        shfty1 = .height * 0.25
        shfty2 = .height * 0.375

        shftx1 = .width * .Adjustments(3)
        shftx2 = .width * .Adjustments(1)
        shfty1 = .height * .Adjustments(2)
        shfty2 = .height * .Adjustments(4)
        
        If g_lApplicationVersion = 2007 Then
            Dim whRatio As Double: whRatio = 1
        
            If .height < .width Then
                whRatio = .width / 2 / .height
            End If
            
            Dim a1 As Double: a1 = .Adjustments(1)
            Dim a2 As Double: a2 = .Adjustments(2)
            Dim a3 As Double: a3 = .Adjustments(3) / whRatio
            Dim a4 As Double: a4 = .Adjustments(4)
            
            If a1 > a2 * 2 Then
                a1 = a2 * 2
            End If
            
            If a4 + a3 + 0.00001 > 1 Then
                a4 = 1 - a3
            End If
            shftx1 = .width * a3 / 2 'a4 ' .Adjustments(1)
            shftx2 = .width * (1 - a4) / 2 '(1 - a3) '.Adjustments(3)
            shfty1 = .height * (0.5 - a2) '.Adjustments(2)
            shfty2 = .height * (1 - a1) / 2 '.Adjustments(4)
            
        End If

        Vert(1).x = .Left
        Vert(1).y = .Top + .height / 2
        Vert(2).x = .Left + shftx1
        Vert(2).y = .Top + shfty1
        Vert(3).x = Vert(2).x
        Vert(3).y = .Top + shfty2
        Vert(4).x = .Left + shftx2
        Vert(4).y = Vert(3).y
        Vert(5).x = Vert(4).x
        Vert(5).y = .Top
        Vert(6).x = .Left + .width - shftx2
        Vert(6).y = Vert(5).y
        Vert(7).x = Vert(6).x
        Vert(7).y = Vert(4).y
        Vert(8).x = .Left + .width - shftx1
        Vert(8).y = Vert(7).y
        Vert(9).x = Vert(8).x
        Vert(9).y = Vert(2).y
        Vert(10).x = .Left + .width
        Vert(10).y = Vert(1).y
        Vert(11).x = Vert(8).x
        Vert(11).y = .Top + .height - shfty1
        Vert(12).x = Vert(8).x
        Vert(12).y = .Top + .height - shfty2
        Vert(13).x = Vert(7).x
        Vert(13).y = Vert(12).y
        Vert(14).x = Vert(6).x
        Vert(14).y = .Top + .height
        Vert(15).x = Vert(5).x
        Vert(15).y = Vert(14).y
        Vert(16).x = Vert(4).x
        Vert(16).y = Vert(13).y
        Vert(17).x = Vert(3).x
        Vert(17).y = Vert(16).y
        Vert(18).x = Vert(17).x
        Vert(18).y = Vert(11).y

        Vert(19) = Vert(1)
    End With
End Sub

Private Sub SetVerticesDownArrowCallout(shp As Shape)
    Dim shftx1 As Single
    Dim shftx2 As Single
    Dim shfty1 As Single
    Dim shfty2 As Single

    InitVertices 12
    With shp
        On Error Resume Next
        shftx1 = .width * 0.25
        shftx2 = .width * 0.375
        shfty1 = .height * 0.6666667
        shfty2 = .height * 0.8333333

        shftx1 = .width * .Adjustments(2)
        shftx2 = .width * .Adjustments(4)
        shfty1 = .height * .Adjustments(1)
        shfty2 = .height * .Adjustments(3)
        
        If g_lApplicationVersion = 2007 Then
            Dim hwRatio As Double: hwRatio = 1
        
            If .height > .width Then
                hwRatio = .height / .width
            End If
            
            Dim a1 As Double: a1 = .Adjustments(1)
            Dim a2 As Double: a2 = .Adjustments(2)
            Dim a3 As Double: a3 = .Adjustments(3) / hwRatio
            Dim a4 As Double: a4 = .Adjustments(4)
            
            If a1 > a2 * 2 Then
                a1 = a2 * 2
            End If
            
            If a4 + a3 + 0.00001 > 1 Then
                a4 = 1 - a3
            End If
            shftx1 = .width * (0.5 - a2) 'a4 ' .Adjustments(1)
            shftx2 = .width * (1 - a1) / 2 '(1 - a4) '(1 - a3) '.Adjustments(3)
            shfty1 = .height * a4 'a3 '.Adjustments(2)
            shfty2 = .height * (1 - a3) '(1 - a1) / 2 '.Adjustments(4)
        End If

        Vert(1).x = .Left
        Vert(1).y = .Top
        Vert(2).x = .Left + .width
        Vert(2).y = .Top
        Vert(3).x = Vert(2).x
        Vert(3).y = .Top + shfty1
        Vert(4).x = .Left + .width - shftx2
        Vert(4).y = Vert(3).y
        Vert(5).x = Vert(4).x
        Vert(5).y = .Top + shfty2
        Vert(6).x = .Left + .width - shftx1
        Vert(6).y = Vert(5).y
        Vert(7).x = .Left + .width / 2
        Vert(7).y = .Top + .height
        Vert(8).x = .Left + shftx1
        Vert(8).y = Vert(5).y
        Vert(9).x = .Left + shftx2
        Vert(9).y = Vert(8).y
        Vert(10).x = Vert(9).x
        Vert(10).y = Vert(4).y
        Vert(11).x = .Left
        Vert(11).y = Vert(10).y

        Vert(12) = Vert(1)
    End With
End Sub

Private Sub SetVerticesUpArrowCallout(shp As Shape)
    Dim shftx1 As Single
    Dim shftx2 As Single
    Dim shfty1 As Single
    Dim shfty2 As Single

    InitVertices 12
    With shp
        On Error Resume Next
        shftx1 = .width * 0.25
        shftx2 = .width * 0.375
        shfty1 = .height * 0.166667
        shfty2 = .height * 0.333333

        shftx1 = .width * .Adjustments(2)
        shftx2 = .width * .Adjustments(4)
        shfty1 = .height * .Adjustments(3)
        shfty2 = .height * .Adjustments(1)
        
        If g_lApplicationVersion = 2007 Then
            Dim hwRatio As Double: hwRatio = 1
        
            If .height > .width Then
                hwRatio = .height / .width
            End If
            
            Dim a1 As Double: a1 = .Adjustments(1)
            Dim a2 As Double: a2 = .Adjustments(2)
            Dim a3 As Double: a3 = .Adjustments(3) / hwRatio
            Dim a4 As Double: a4 = .Adjustments(4)
            
            If a1 > a2 * 2 Then
                a1 = a2 * 2
            End If
            
            If a4 + a3 + 0.00001 > 1 Then
                a4 = 1 - a3
            End If
            shftx1 = .width * (0.5 - a2) 'a4 ' .Adjustments(1)
            shftx2 = .width * (1 - a1) / 2 '(1 - a4) '(1 - a3) '.Adjustments(3)
            shfty1 = .height * a3 '.Adjustments(2)
            shfty2 = .height * (1 - a4) '(1 - a1) / 2 '.Adjustments(4)
        End If

        Vert(1).x = .Left
        Vert(1).y = .Top + shfty2
        Vert(2).x = .Left + shftx2
        Vert(2).y = .Top + shfty2
        Vert(3).x = Vert(2).x
        Vert(3).y = .Top + shfty1
        Vert(4).x = .Left + shftx1
        Vert(4).y = Vert(3).y
        Vert(5).x = .Left + .width / 2
        Vert(5).y = .Top
        Vert(6).x = .Left + .width - shftx1
        Vert(6).y = Vert(3).y
        Vert(7).x = .Left + .width - shftx2
        Vert(7).y = Vert(3).y
        Vert(8).x = Vert(7).x
        Vert(8).y = .Top + shfty2
        Vert(9).x = .Left + .width
        Vert(9).y = Vert(8).y
        Vert(10).x = Vert(9).x
        Vert(10).y = .Top + .height
        Vert(11).x = .Left
        Vert(11).y = .Top + .height
        Vert(12) = Vert(1)
    End With
End Sub

Private Sub SetVerticesLeftArrowCallout(shp As Shape)
    Dim shftx1 As Single
    Dim shftx2 As Single
    Dim shfty1 As Single
    Dim shfty2 As Single

    InitVertices 12
    With shp
        On Error Resume Next
        shftx1 = .width * 0.1666667
        shftx2 = .width * 0.3333333
        shfty1 = .height * 0.25
        shfty2 = .height * 0.375

        shftx1 = .width * .Adjustments(3)
        shftx2 = .width * .Adjustments(1)
        shfty1 = .height * .Adjustments(2)
        shfty2 = .height * .Adjustments(4)
        
        If g_lApplicationVersion = 2007 Then
            Dim whRatio As Double: whRatio = 1
        
            If .height < .width Then
                whRatio = .width / .height
            End If
            
            Dim a1 As Double: a1 = .Adjustments(1)
            Dim a2 As Double: a2 = .Adjustments(2)
            Dim a3 As Double: a3 = .Adjustments(3) / whRatio
            Dim a4 As Double: a4 = .Adjustments(4)
            
            If a1 > a2 * 2 Then
                a1 = a2 * 2
            End If
            
            If a4 + a3 + 0.00001 > 1 Then
                a4 = 1 - a3
            End If
            shftx1 = .width * a3 'a4 ' .Adjustments(1)
            shftx2 = .width * (1 - a4) '(1 - a3) '.Adjustments(3)
            shfty1 = .height * (0.5 - a2) '.Adjustments(2)
            shfty2 = .height * (1 - a1) / 2 '.Adjustments(4)
        End If

        Vert(1).x = .Left
        Vert(1).y = .Top + .height / 2
        Vert(2).x = .Left + shftx1
        Vert(2).y = .Top + shfty1
        Vert(3).x = Vert(2).x
        Vert(3).y = .Top + shfty2
        Vert(4).x = .Left + shftx2
        Vert(4).y = .Top + shfty2
        Vert(5).x = .Left + shftx2
        Vert(5).y = .Top
        Vert(6).x = .Left + .width
        Vert(6).y = .Top
        Vert(7).x = .Left + .width
        Vert(7).y = .Top + .height
        Vert(8).x = Vert(5).x
        Vert(8).y = .Top + .height
        Vert(9).x = Vert(8).x
        Vert(9).y = .Top + .height - shfty2
        Vert(10).x = Vert(3).x
        Vert(10).y = Vert(9).y
        Vert(11).x = Vert(10).x
        Vert(11).y = .Top + .height - shfty1
        Vert(12) = Vert(1)
    End With
End Sub

Private Sub SetVerticesRightArrowCallout(shp As Shape)
    Dim shftx1 As Single
    Dim shftx2 As Single
    Dim shfty1 As Single
    Dim shfty2 As Single

    InitVertices 12
    With shp
        On Error Resume Next
        shftx1 = .width * 0.666667
        shftx2 = .width * 0.833333
        shfty1 = .height * 0.25
        shfty2 = .height * 0.375

        shftx1 = .width * .Adjustments(1)
        shftx2 = .width * .Adjustments(3)
        shfty1 = .height * .Adjustments(2)
        shfty2 = .height * .Adjustments(4)
        
        If g_lApplicationVersion = 2007 Then
            Dim whRatio As Double: whRatio = 1
        
            If .height < .width Then
                whRatio = .width / .height
            End If
            
            Dim a1 As Double: a1 = .Adjustments(1)
            Dim a2 As Double: a2 = .Adjustments(2)
            Dim a3 As Double: a3 = .Adjustments(3) / whRatio
            Dim a4 As Double: a4 = .Adjustments(4)
            
            If a1 > a2 * 2 Then
                a1 = a2 * 2
            End If
            
            If a4 + a3 + 0.00001 > 1 Then
                a4 = 1 - a3
            End If
            shftx1 = .width * a4 ' .Adjustments(1)
            shftx2 = .width * (1 - a3) '.Adjustments(3)
            shfty1 = .height * (0.5 - a2) '.Adjustments(2)
            shfty2 = .height * (1 - a1) / 2 '.Adjustments(4)
        End If
        

        Vert(1).x = .Left
        Vert(1).y = .Top
        Vert(2).x = .Left + shftx1
        Vert(2).y = .Top
        Vert(3).x = .Left + shftx1
        Vert(3).y = .Top + shfty2
        Vert(4).x = .Left + shftx2
        Vert(4).y = .Top + shfty2
        Vert(5).x = .Left + shftx2
        Vert(5).y = .Top + shfty1
        Vert(6).x = .Left + .width
        Vert(6).y = .Top + .height / 2
        Vert(7).x = .Left + shftx2
        Vert(7).y = .Top + .height - shfty1
        Vert(8).x = .Left + shftx2
        Vert(8).y = .Top + .height - shfty2
        Vert(9).x = .Left + shftx1
        Vert(9).y = Vert(8).y
        Vert(10).x = Vert(9).x
        Vert(10).y = .Top + .height
        Vert(11).x = .Left
        Vert(11).y = .Top + .height
        Vert(12) = Vert(1)
    End With
End Sub

Private Sub SetVerticesChevron(shp As Shape)
    Dim shftx As Single
    InitVertices 7
    With shp
        On Error Resume Next
        shftx = .width * 0.75
        shftx = .width * .Adjustments(1)
        If g_lApplicationVersion = 2007 Then
            Dim whRatio As Double: whRatio = 1
            If .width > .height Then
                whRatio = .width / .height
            End If
            shftx = .width * (1 - .Adjustments(1) / whRatio)
        End If

        Vert(1).x = .Left
        Vert(1).y = .Top
        Vert(2).x = .Left + shftx
        Vert(2).y = .Top
        Vert(3).x = .Left + .width
        Vert(3).y = .Top + .height / 2
        Vert(4).x = Vert(2).x
        Vert(4).y = .Top + .height
        Vert(5).x = .Left
        Vert(5).y = .Top + .height
        Vert(6).x = .Left + .width - shftx
        Vert(6).y = Vert(3).y
        Vert(7) = Vert(1)
    End With
End Sub

Private Sub SetVerticesPentagon(shp As Shape)
    InitVertices 6
    With shp
        On Error Resume Next
        Dim whRatio As Double: whRatio = 1
        If g_lApplicationVersion = 2007 And .width > .height Then
            whRatio = .width / .height
        End If
        Vert(1).x = .Left
        Vert(1).y = .Top
        
        If g_lApplicationVersion = 2007 Then
            Vert(2).x = .Left + .width * (1 - .Adjustments(1) / whRatio)
        Else
        Vert(2).x = .Left + .width * .Adjustments(1)
        If Err.Number <> 0 Then
            Vert(2).x = .Left + .width * 0.75   ' use default value
            Err.Clear
        End If
        End If
        Vert(2).y = .Top
        Vert(3).x = .Left + .width
        Vert(3).y = .Top + .height / 2
        Vert(4).x = Vert(2).x
        Vert(4).y = .Top + .height
        Vert(5).x = .Left
        Vert(5).y = .Top + .height
        Vert(6) = Vert(1)
    End With
End Sub

Private Sub SetVerticesNotchedRightArrow(shp As Shape)
    Dim ratio1 As Single
    Dim ratio2 As Single
    Dim shfty As Single
    Dim shftx As Single

    InitVertices 9
    With shp
        On Error Resume Next
        ratio1 = 0.75
        ratio2 = 0.25

        ratio1 = .Adjustments(1)
        ratio2 = .Adjustments(2)
        shftx = .width * ratio1     '.Adjustments(1)
        shfty = .height * ratio2    '.Adjustments(2)
        Dim whRatio As Double: whRatio = 1
        If g_lApplicationVersion = 2007 Then
            
            If .width > .height Then
                whRatio = .width / .height
            End If
            shftx = .width * (1 - ratio2 / whRatio)
            shfty = .height / 2 * (1 - ratio1)
        End If

        Vert(1).x = .Left
        Vert(1).y = .Top + shfty
        Vert(2).x = .Left + shftx
        Vert(2).y = .Top + shfty
        Vert(3).x = Vert(2).x
        Vert(3).y = .Top
        Vert(4).x = .Left + .width
        Vert(4).y = .Top + .height / 2
        Vert(5).x = Vert(2).x
        Vert(5).y = .Top + .height
        Vert(6).x = Vert(2).x
        Vert(6).y = .Top + .height - shfty
        Vert(7).x = .Left
        Vert(7).y = Vert(6).y

'        Vert(8).x = .Left + .Width * (1 - .Adjustments(1)) * (1 - 2 * .Adjustments(2))
        If g_lApplicationVersion = 2007 Then
            Vert(8).x = .Left + ratio2 * .width * ratio1 / whRatio
        Else
        Vert(8).x = .Left + .width * (1 - ratio1) * (1 - 2 * ratio2)
        End If
        Vert(8).y = .Top + .height / 2
        Vert(9) = Vert(1)
    End With
End Sub

Private Sub SetVerticesStripeRightArrow(shp As Shape, Optional bRotateNodes As Boolean = True)
    Dim bFilled     As Boolean
    Dim bOutline    As Boolean
    Dim i           As Long
    Dim shftx        As Single
    Dim shfty           As Single

    With shp
        On Error Resume Next
        shftx = .width * .Adjustments(1)
        If Err.Number <> 0 Then
            shftx = .width * 0.75
            Err.Clear
        End If
        shfty = .height * .Adjustments(2)
        If Err.Number <> 0 Then
            shfty = .height * 0.25
            Err.Clear
        End If

        InitVertices 15
        Dim wh As Double: wh = .width
        If g_lApplicationVersion = 2007 Then
            Dim whRatio As Double: whRatio = 1
        
            If .height < .width Then
                whRatio = .width / .height
            End If
            Dim a1 As Double: a1 = 1 - .Adjustments(1)
            Dim a2 As Double: a2 = .Adjustments(2) / whRatio / 0.84375
            shfty = .height / 2 * a1 '.Adjustments(1)
            shftx = .width * (1 - 0.84375 * a2) ' .Adjustments(2)
            wh = IIf(.width > .height, .height, .width)
        End If

        'rectangle 1
        Vert(1).x = .Left
        Vert(1).y = .Top + shfty
        Vert(2).x = .Left + wh * 0.03125 '0.033
        Vert(2).y = .Top + shfty
        Vert(3).x = Vert(2).x
        Vert(3).y = .Top + .height - shfty
        Vert(4).x = .Left
        Vert(4).y = Vert(3).y

        ' rectangle 2
        Vert(5).x = .Left + wh * 0.0625
        Vert(5).y = Vert(1).y
        Vert(6).x = .Left + wh * 0.125
        Vert(6).y = Vert(2).y
        Vert(7).x = Vert(6).x
        Vert(7).y = Vert(3).y
        Vert(8).x = Vert(5).x
        Vert(8).y = Vert(4).y

        ' arrow
        Vert(9).x = .Left + wh * 0.15625
        Vert(9).y = Vert(1).y
        Vert(10).x = .Left + shftx
        Vert(10).y = Vert(9).y
        Vert(11).x = Vert(10).x
        Vert(11).y = .Top
        Vert(12).x = .Left + .width
        Vert(12).y = .Top + .height / 2
        Vert(13).x = Vert(11).x
        Vert(13).y = .Top + .height
        Vert(14).x = Vert(13).x
        Vert(14).y = .Top + .height - shfty
        Vert(15).x = Vert(9).x
        Vert(15).y = Vert(14).y

    End With
End Sub

Private Sub ParseStripeRightArrow(shp As Shape, Optional bRotateNodes As Boolean = True)
    m_lecShapeType = LEC_SHAPETYPE_USERDEFINEDGROUP

    ' This shape should be converted to 3 objects (Polygons)
    HasGroupItem = True

    ' flip and rotate the vertices.
    NewFlipNodes shp
    NewRotateNodes shp

    ' the left most rect
    AddGroupItem
    With GroupItems(GroupItemNum)
        .SetShapeType (LEC_SHAPETYPE_POLYGON)
        .SetGraphmode shp
        .InitVerts 1, 4, Vert, True
        .PrintPointsString
    End With

    ' the second rect
    AddGroupItem
    With GroupItems(GroupItemNum)
        .SetShapeType (LEC_SHAPETYPE_POLYGON)
        .SetGraphmode shp
        .InitVerts 5, 4, Vert, True
        .PrintPointsString
    End With

    ' the arrow
    AddGroupItem
    With GroupItems(GroupItemNum)
        .SetShapeType (LEC_SHAPETYPE_POLYGON)
        .SetGraphmode shp
        .InitVerts 9, 7, Vert, True
        .PrintPointsString
    End With
End Sub

Private Sub SetVerticesBentUpArrow(shp As Shape)
    Dim shft3 As Single
    Dim shft1 As Single
    Dim shft2 As Single
    Dim Tailw   As Single

    InitVertices 10

    With shp
        On Error Resume Next
        shft1 = 0.4285648
        shft2 = 0.8571296
        shft3 = 0.3333333

        shft1 = .Adjustments(1)
        shft2 = .Adjustments(2)
        shft3 = .Adjustments(3)

        Tailw = 2 * shft2 - shft1 - 1
        Dim A As Single
        Dim b As Single
        Dim d As Single

        d = (1 + shft1) / 2

        d = d * 8.9 / 10

        A = (1 - shft1) / (Sqr(1 - d) - Sqr((1 + shft1) / 2 - d))
        b = -A * Sqr((1 + shft1) / 2 - d)

        Tailw = A * Sqr(shft2 - d) + b

        Vert(1).x = .Left + .width * shft2
        Vert(1).y = .Top + .height
        Vert(2).x = .Left
        Vert(2).y = .Top + .height
        Vert(3).x = .Left
        Vert(3).y = .Top + .height * (1 - Tailw)
        Vert(4).x = .Left + .width * (1 + shft1 - shft2)
        Vert(4).y = Vert(3).y
        Vert(5).x = Vert(4).x
        Vert(5).y = .Top + .height * shft3
        Vert(6).x = .Left + .width * shft1
        Vert(6).y = Vert(5).y

        Vert(7).x = .Left + .width * (1 + shft1) / 2
        Vert(7).y = .Top
        Vert(8).x = .Left + .width
        Vert(8).y = Vert(6).y
        Vert(9).x = Vert(1).x
        Vert(9).y = Vert(5).y
        Vert(10) = Vert(1)
    End With
End Sub

Private Sub SetVerticesLeftUpArrow(shp As Shape)
    Dim shft3 As Single
    Dim shft1 As Single
    Dim shft2 As Single

    InitVertices 13
    With shp
        On Error Resume Next
        shft1 = 0.4285648
        shft2 = 0.8571296
        shft3 = 0.2856945

        shft1 = .Adjustments(1)
        shft2 = .Adjustments(2)
        shft3 = .Adjustments(3)

        Vert(1).x = .Left
        Vert(1).y = .Top + .height * (1 + shft1) / 2
        Vert(2).x = .Left + .width * shft3
        Vert(2).y = .Top + .height * shft1
        Vert(3).x = Vert(2).x
        Vert(3).y = .Top + .height * (1 + shft1 - shft2)
        Vert(4).x = .Left + .width * (1 + shft1 - shft2)
        Vert(4).y = Vert(3).y
        Vert(5).x = Vert(4).x
        Vert(5).y = .Top + .height * shft3
        Vert(6).x = .Left + .width * shft1
        Vert(6).y = Vert(5).y

        Vert(7).x = .Left + .width * (1 + shft1) / 2
        Vert(7).y = .Top
        Vert(8).x = .Left + .width
        Vert(8).y = Vert(6).y
        Vert(9).x = .Left + .width * shft2
        Vert(9).y = Vert(5).y
        Vert(10).x = Vert(9).x
        Vert(10).y = .Top + .height * shft2
        Vert(11).x = Vert(3).x
        Vert(11).y = Vert(10).y
        Vert(12).x = Vert(11).x
        Vert(12).y = .Top + .height
        Vert(13) = Vert(1)
    End With
End Sub

' the powerpoint has a bug in this shape, sometime it gives
' wrong adjustments.
Private Sub SetVerticesLeftRightUpArrow(shp As Shape)
    Dim shftx1 As Single
    Dim shftx2 As Single
    Dim shfty As Single
    Dim lArrW As Single
    Dim lNeckW As Single
    Dim lArrH   As Single

    InitVertices 18
    With shp
        On Error Resume Next
        If g_lApplicationVersion = 2007 Then
            Dim shft1 As Single
            Dim shft2 As Single
            Dim shft3 As Single
            shft1 = 0.3
            shft2 = 0.4
            shft3 = 0.2856945
            shft1 = .Adjustments(1)
            shft2 = .Adjustments(2)
            shft3 = .Adjustments(3)
            
            If shft2 + shft3 > 0.5 Then
                shft3 = 0.5 - shft2
            End If
            If shft1 > 2 * shft2 Then
                shft1 = 2 * shft2
            End If
            
            Dim sz As Single
            sz = IIf(.width > .height, .height, .width)
            
            Vert(1).x = .Left + .width / 2
            Vert(1).y = .Top
            Vert(2).x = Vert(1).x + shft2 * sz
            Vert(2).y = Vert(1).y + shft3 * sz
            Vert(3).x = Vert(1).x + shft1 * sz / 2
            Vert(3).y = Vert(2).y
            Vert(4).x = Vert(3).x
            Vert(4).y = .Top + .height - shft2 * sz - shft1 * sz / 2
            Vert(5).x = .Left + .width - shft3 * sz
            Vert(5).y = Vert(4).y
            Vert(6).x = Vert(5).x
            Vert(6).y = .Top + .height - 2 * shft2 * sz
            Vert(7).x = .Left + .width
            Vert(7).y = .Top + .height - shft2 * sz
            Vert(8).x = Vert(6).x
            Vert(8).y = .Top + .height
            Vert(9).x = Vert(8).x
            Vert(9).y = Vert(8).y - shft2 * sz + shft1 * sz / 2
            Vert(10).x = .Left + shft3 * sz
            Vert(10).y = Vert(9).y
            Vert(11).x = Vert(10).x
            Vert(11).y = .Top + .height
            Vert(12).x = .Left
            Vert(12).y = Vert(7).y
            Vert(13).x = Vert(11).x
            Vert(13).y = Vert(6).y
            Vert(14).x = Vert(13).x
            Vert(14).y = Vert(4).y
            Vert(15).x = Vert(1).x - shft1 * sz / 2
            Vert(15).y = Vert(14).y
            Vert(16).x = Vert(15).x
            Vert(16).y = Vert(3).y
            Vert(17).x = Vert(1).x - shft2 * sz
            Vert(17).y = Vert(2).y
            Vert(18) = Vert(1)
        Else
        shftx1 = 0.3
        shftx2 = 0.4
        shfty = 0.2856945

        shftx1 = .Adjustments(1)
        shftx2 = .Adjustments(2)
        shfty = .Adjustments(3)

        lArrW = .height * (1 - shftx1 - shftx1) / (2 - shftx1 - shftx1)
        lNeckW = .height * (shftx2 - shftx1) / (1 - shftx1)
        lArrH = .width * shfty * (1 - shftx1) * 2 / (3 - 4 * shftx1)

        Vert(1).x = .Left
        Vert(1).y = .Top + .height - lArrW
        Vert(2).x = .Left + lArrH
        Vert(2).y = Vert(1).y - lArrW
        Vert(3).x = Vert(2).x
        Vert(3).y = Vert(2).y + lNeckW
        Vert(4).x = .Left + .width * shftx2
        Vert(4).y = Vert(3).y
        Vert(5).x = Vert(4).x
        Vert(5).y = .Top + .height * shfty
        Vert(6).x = .Left + .width * shftx1
        Vert(6).y = Vert(5).y

        Vert(7).x = .Left + .width / 2
        Vert(7).y = .Top
        Vert(8).x = .Left + .width * (1 - shftx1)
        Vert(8).y = Vert(6).y
        Vert(9).x = .Left + .width * (1 - shftx2)
        Vert(9).y = Vert(5).y
        Vert(10).x = Vert(9).x
        Vert(10).y = Vert(4).y
        Vert(11).x = .Left + .width - lArrH
        Vert(11).y = Vert(4).y
        Vert(12).x = Vert(11).x
        Vert(12).y = Vert(2).y

        Vert(13).x = .Left + .width
        Vert(13).y = Vert(1).y
        Vert(14).x = Vert(11).x
        Vert(14).y = .Top + .height
        Vert(15).x = Vert(14).x
        Vert(15).y = .Top + .height - lNeckW
        Vert(16).x = Vert(3).x
        Vert(16).y = Vert(15).y
        Vert(17).x = Vert(16).x
        Vert(17).y = Vert(14).y
        Vert(18) = Vert(1)
        End If
    End With
End Sub


Private Sub SetVerticesUpDownArrow(shp As Shape)
    Dim shfty As Single
    Dim shftx As Single

    InitVertices 11
    With shp
        On Error Resume Next
        shftx = .width * 0.25
        shfty = .height * 0.2

        shftx = .width * .Adjustments(1)
        shfty = .height * .Adjustments(2)
        
        If g_lApplicationVersion = 2007 Then
            Dim hwRatio As Double: hwRatio = .height / 2 / .width
            
            Dim a1 As Double: a1 = 1 - .Adjustments(1)
            Dim a2 As Double: a2 = .Adjustments(2) / hwRatio
    
    
            shftx = .width / 2 * a1
            shfty = .height / 2 * a2 '(1 - .Adjustments(1))
        End If

        Vert(1).x = .Left
        Vert(1).y = .Top + shfty
        Vert(2).x = .Left + .width / 2
        Vert(2).y = .Top
        Vert(3).x = .Left + .width
        Vert(3).y = Vert(1).y
        Vert(4).x = .Left + .width - shftx
        Vert(4).y = Vert(3).y
        Vert(5).x = Vert(4).x
        Vert(5).y = .Top + .height - shfty
        Vert(6).x = .Left + .width
        Vert(6).y = Vert(5).y
        Vert(7).x = Vert(2).x
        Vert(7).y = .Top + .height
        Vert(8).x = .Left
        Vert(8).y = Vert(5).y
        Vert(9).x = .Left + shftx
        Vert(9).y = Vert(5).y
        Vert(10).x = Vert(9).x
        Vert(10).y = Vert(1).y

        Vert(11) = Vert(1)
    End With
End Sub

Private Sub SetVerticesCube(shp As Shape)
    Dim bFilled     As Boolean
    Dim bOutline    As Boolean
    Dim i           As Long
    Dim shft        As Single

    With shp
        On Error Resume Next
        If .height > .width Then
            shft = .width * 0.25
            shft = .width * .Adjustments(1)
        Else
            shft = .height * 0.25
            shft = .height * .Adjustments(1)
        End If

        InitVertices 7
        ' the upper side
        Vert(1).x = .Left + shft
        Vert(1).y = .Top
        Vert(2).x = .Left + .width
        Vert(2).y = .Top
        Vert(3).x = .Left
        Vert(3).y = .Top + shft
        Vert(4).x = .Left + .width - shft
        Vert(4).y = .Top + shft

        ' the bottom
        Vert(5).x = .Left + .width
        Vert(5).y = .Top + .height - shft
        Vert(6).x = .Left
        Vert(6).y = .Top + .height
        Vert(7).x = .Left + .width - shft
        Vert(7).y = .Top + .height
    End With
End Sub

Private Sub ParseCube(shp As Shape)

    SetGraphstyle shp
    'NewFlipNodes shp
    NewRotateNodes shp

    With shp

        Dim bSolidFilled As Boolean
        Dim colorUpper As String
        Dim colorSide  As String
        Dim colorDumm  As String

        If .Fill.Visible = msoTrue Then
            bSolidFilled = True
            SetRelatedColors .Fill.ForeColor.RGB, colorDumm, colorUpper, colorSide, colorDumm
        Else
            bSolidFilled = False
        End If

        AddGroupItem
        With GroupItems(GroupItemNum)      ' upper
            .SetShapeType (LEC_SHAPETYPE_POLYGON)
            .SetGraphmode shp
            .Set5Vert Vert, 1, 2, 4, 3
            .PrintPointsString
            .m_szFillColor = colorUpper
        End With

        AddGroupItem
        With GroupItems(GroupItemNum)      ' front
            .SetShapeType (LEC_SHAPETYPE_POLYGON)
            .SetGraphmode shp
            .Set5Vert Vert, 3, 4, 7, 6
            .PrintPointsString
            .m_szFillColor = m_szFillColor
        End With

        AddGroupItem
        With GroupItems(GroupItemNum)      ' side
            .SetShapeType (LEC_SHAPETYPE_POLYGON)
            .SetGraphmode shp
            .Set5Vert Vert, 2, 4, 7, 5
            .PrintPointsString
            .m_szFillColor = colorSide
       End With

    End With

    m_lecShapeType = LEC_SHAPETYPE_USERDEFINEDGROUP
End Sub

Private Sub SetRelatedColors(fc As Long, ByRef c1 As String, ByRef c2 As String, ByRef c3 As String, ByRef c4 As String)
    Dim r As Long, g As Long, b As Long
    Dim rt As Long, gt As Long, bt As Long
    Dim a2 As Double, a1 As Double

    a1 = 153# / 255#
    a2 = 205# / 255#

    r = fc Mod 256
    g = CLng(fc / 256 - 0.5) Mod 256
    b = CLng(fc / 65536 - 0.5)

    ' right side color of bevel                             ' c4 = a1 * c
    rt = a1 * r
    gt = a1 * g
    bt = a1 * b
    c4 = GetHexColor(rt, gt, bt)

    ' left side color of bevel                              , c1 = a1 * c + 102
    c1 = GetHexColor(rt + 102, gt + 102, bt + 102)

    ' right side color of cube, bottom side color of bevel  , c3 = a2 * c
    rt = a2 * r
    gt = a2 * g
    bt = a2 * b
    c3 = GetHexColor(rt, gt, bt)

    ' upper color of cube, cylinder and bevel               , c2 = a2 * c + 50
    c2 = GetHexColor(rt + 50, gt + 50, bt + 50)

End Sub

Private Function GetHexColor(r As Long, g As Long, b As Long) As String
    Dim rs As String, gs As String, bS As String
    rs = Hex$(r)
    gs = Hex$(g)
    bS = Hex$(b)

    If Len(rs) < 2 Then
        rs = "0" & rs
    End If
    If Len(gs) < 2 Then
        gs = "0" & gs
    End If
    If Len(bS) < 2 Then
        bS = "0" & bS
    End If

    GetHexColor = "#" & rs & gs & bS
End Function

Sub InitVerts(begin As Long, num As Long, v() As aofNode, Optional bClosed As Boolean = False)
    If bClosed Then
        VertNum = num + 1
    Else
        VertNum = num
    End If
    ReDim Vert(1 To VertNum) As aofNode

    Dim i       As Long

    For i = 1 To num
        Vert(i) = v(begin + i - 1)
    Next

    If bClosed Then
        Vert(VertNum) = v(begin)
    End If

    'PrintPointsString
End Sub

Private Function Has3DEffect(shp As Shape) As Boolean
    Dim d As Single
    On Error Resume Next
    If shp.ThreeD.Visible = msoFalse Then
        Has3DEffect = False
        Exit Function
    End If
    d = shp.ThreeD.Depth       ' determine 3D effect
    If Err.Number <> 0 Then
        'MsgBox "This shape has no 3D effect."
        Err.Clear
        Has3DEffect = False
        Exit Function
    Else
        Has3DEffect = True
        Exit Function
    End If
End Function
Private Sub Set3DRectBondaryPoints(shp As Shape, vnum As Long)
    With shp
        vnum = 8 ' callout line points and vertices.

        ReDim v(1 To vnum, 1 To 3) As Double    ' coordinates before transform

        v(1, 1) = .Left
        v(1, 2) = .Top
        v(2, 1) = .Left + .width
        v(2, 2) = .Top
        v(3, 1) = .Left
        v(3, 2) = .Top + .height
        v(4, 1) = .Left + .width
        v(4, 2) = .Top + .height
    End With
End Sub

Private Sub FlipV(shp As Shape, vnum)
    Dim i As Long

    With shp
        If .HorizontalFlip = msoTrue Then
            For i = 1 To vnum / 2
                v(i, 1) = .Left * 2 + .width - v(i, 1)
            Next
         End If
        If .VerticalFlip = msoTrue Then
            For i = 1 To vnum / 2
                v(i, 2) = .Top * 2 + .height - v(i, 2)
            Next
        End If
    End With
End Sub

' Initialize the Vert() array, if ReDim failed, returns -1, otherwise returns VertNum.
Private Function InitVertices(vnum As Long) As Long
    On Error Resume Next
    ' clear the old Vert()
    If HasVertices And VertNum > 0 Then
        Erase Vert
        HasVertices = False
        VertNum = 0
    End If
    ' Init
    Err.Clear
    If vnum > 0 Then
        ReDim Vert(1 To vnum) As aofNode
        If Err.Number <> 0 Then     ' ReDim failed.
            InitVertices = -1
            Err.Clear
            Exit Function
        End If
        VertNum = vnum
        HasVertices = True
    End If

    InitVertices = VertNum
End Function

Public Sub SetVerticesRect(shp As Shape)
    If InitVertices(5) < 1 Then     ' init Vert() failed
        Exit Sub
    End If
    
    On Error GoTo SetSizeError

    With shp
        Vert(1).x = .Left
        Vert(1).y = .Top
        Vert(2).x = .Left + .width
        Vert(2).y = .Top
        Vert(3).x = .Left + .width
        Vert(3).y = .Top + .height
        Vert(4).x = .Left
        Vert(4).y = .Top + .height
        Vert(5) = Vert(1)
    End With
    
    Exit Sub
    
SetSizeError:
    
    Vert(1).x = 0
    Vert(1).y = 0
    Vert(2).x = 0
    Vert(2).y = 0
    Vert(3).x = 0
    Vert(3).y = 0
    Vert(4).x = 0
    Vert(4).y = g_currentPresentation.SlideMaster.height
    Vert(5) = Vert(1)
    
End Sub

Private Sub SetVerticesRightTriangle(shp As Shape)
    InitVertices 4

    With shp
        Vert(1).x = .Left
        Vert(1).y = .Top
        Vert(3).x = .Left
        Vert(3).y = .Top + .height
        Vert(2).x = .Left + .width
        Vert(2).y = .Top + .height

        Vert(4) = Vert(1)
    End With
End Sub

Private Sub SetVerticesIsoscelesTriangle(shp As Shape)
    Dim shft    As Single

    On Error Resume Next

    InitVertices 4

    With shp
        shft = .Adjustments(1)
        If Err.Number <> 0 Then
            shft = 0.5
        End If
        Vert(1).x = .Left + .width * shft
        Vert(2).x = .Left + .width
        Vert(3).x = .Left
        Vert(1).y = .Top
        Vert(2).y = .Top + .height
        Vert(3).y = .Top + .height
        Vert(4) = Vert(1)
    End With
End Sub

Private Sub SetVerticesParallelogram(shp As Shape)
    Dim shft    As Single

    InitVertices 5
    With shp
        On Error Resume Next
        shft = .width * .Adjustments(1)
        If Err.Number <> 0 Then
            shft = .width * 0.25
        End If

        Vert(1).x = .Left + shft
        Vert(2).x = .Left + .width
        Vert(3).x = Vert(2).x - shft
        Vert(4).x = .Left
        Vert(1).y = .Top
        Vert(2).y = .Top
        Vert(3).y = .Top + .height
        Vert(4).y = Vert(3).y

        Vert(5) = Vert(1)
    End With
End Sub

Private Sub SetVerticesTrapezoid(shp As Shape)
    Dim shft        As Single

    InitVertices 5
    With shp
        On Error Resume Next
        shft = CLng(.width * .Adjustments(1))

        If (Err.Number <> 0) Then       '"Der Index in der angegebenen Sammlung ist auerhalb des zulssigen Bereichs."
            shft = CLng(.width * 0.2)
            Err.Clear
        End If
            
        If g_lApplicationVersion = 2007 Then
            
            shft = .height * .Adjustments(1)
            
            Vert(1).x = .Left + shft
            Vert(2).x = .Left + .width - shft
            Vert(3).x = .Left + .width
            Vert(4).x = .Left
            
            Vert(1).y = .Top
            Vert(2).y = .Top
            Vert(3).y = .Top + .height
            Vert(4).y = Vert(3).y
        Else
            Vert(1).x = .Left
            Vert(2).x = .Left + .width
            Vert(3).x = Vert(2).x - shft
            Vert(4).x = .Left + shft
            
            Vert(1).y = .Top
            Vert(2).y = .Top
            Vert(3).y = .Top + .height
            Vert(4).y = Vert(3).y
        End If

        Vert(5) = Vert(1)
    End With

End Sub

Private Sub SetVerticesDiamond(shp As Shape)
    InitVertices 5

    With shp
        Vert(1).x = .Left + (.width / 2)
        Vert(1).y = .Top
        Vert(2).x = .Left + .width
        Vert(2).y = .Top + (.height / 2)
        Vert(3).x = Vert(1).x
        Vert(3).y = .Top + .height
        Vert(4).x = .Left
        Vert(4).y = Vert(2).y

        Vert(5) = Vert(1)
    End With
End Sub

Private Sub SetVerticesOctagon(shp As Shape)
    Dim shft    As Single

    InitVertices 9
    With shp
        On Error Resume Next
        If .width < .height Then
            shft = (.width * 0.293)
            shft = (.width * .Adjustments(1))
        Else
            shft = (.height * 0.293)
            shft = (.height * .Adjustments(1))
        End If
        Vert(1).x = .Left + shft
        Vert(1).y = .Top
        Vert(2).x = .Left + .width - shft
        Vert(2).y = .Top
        Vert(3).x = .Left + .width
        Vert(3).y = .Top + shft
        Vert(4).x = Vert(3).x
        Vert(4).y = .Top + .height - shft
        Vert(5).x = Vert(2).x
        Vert(5).y = .Top + .height
        Vert(6).x = Vert(1).x
        Vert(6).y = Vert(5).y
        Vert(7).x = .Left
        Vert(7).y = Vert(4).y
        Vert(8).x = .Left
        Vert(8).y = Vert(3).y

        Vert(9) = Vert(1)
    End With
End Sub

Private Sub SetVerticesHexagon(shp As Shape)
    Dim shft    As Single

    InitVertices 7
    With shp
        On Error Resume Next
        shft = .Adjustments(1)
        If Err.Number <> 0 Then
            shft = 0.2
        End If

        shft = (.width * shft)
        Vert(1).x = .Left + shft
        Vert(1).y = .Top
        Vert(2).x = .Left + .width - shft
        Vert(2).y = .Top
        Vert(3).x = .Left + .width
        Vert(3).y = .Top + (.height / 2)
        Vert(4).x = Vert(2).x
        Vert(4).y = .Top + .height
        Vert(5).x = Vert(1).x
        Vert(5).y = Vert(4).y
        Vert(6).x = .Left
        Vert(6).y = Vert(3).y

        Vert(7) = Vert(1)
End With
End Sub

Private Sub SetVerticesRegularPentagon(shp As Shape)
    Dim shft    As Single
    Dim ratio       As Single

    InitVertices 6
    With shp
        ratio = 0.363271     ' tan(PI/5) / 2
        Vert(1).x = .Left + (.width / 2)
        Vert(1).y = .Top
        Vert(2).x = .Left + .width
        Vert(2).y = .Top + (.height * ratio)
        ratio = 0.2068857       ' ( 1 - tan(PI/5)/2 ) * tan(PI/10)
        shft = (.width * ratio)
        Vert(3).x = .Left + .width - shft
        Vert(3).y = .Top + .height
        Vert(4).x = .Left + shft
        Vert(4).y = Vert(3).y
        Vert(5).x = .Left
        Vert(5).y = Vert(2).y
        Vert(6) = Vert(1)
    End With
End Sub

Private Sub SetVerticesRightArrow(shp As Shape)
    Dim shfty As Single
    Dim shftx As Single
    
    InitVertices 8

    With shp
        On Error Resume Next
        
        shftx = .width * 0.75
        shftx = .width * .Adjustments(1)

        shfty = .height * 0.25
        shfty = .height * .Adjustments(2)
        
        If g_lApplicationVersion = 2007 Then
            Dim whRatio As Double: whRatio = 1
        
            If .height < .width Then
                whRatio = .width / .height
            End If
            Dim a1 As Double: a1 = 1 - .Adjustments(1) / whRatio
            Dim a2 As Double: a2 = 1 - .Adjustments(2)
            shfty = .height / 2 * a2 '.Adjustments(1)
            shftx = .width * a1 ' .Adjustments(2)
        End If

        Vert(1).x = .Left
        Vert(1).y = .Top + shfty
        Vert(2).x = .Left + shftx
        Vert(2).y = .Top + shfty
        Vert(3).x = Vert(2).x
        Vert(3).y = .Top
        Vert(4).x = .Left + .width
        Vert(4).y = .Top + .height / 2
        Vert(5).x = Vert(2).x
        Vert(5).y = .Top + .height
        Vert(6).x = Vert(2).x
        Vert(6).y = .Top + .height - shfty
        Vert(7).x = .Left
        Vert(7).y = Vert(6).y

        Vert(8) = Vert(1)
    End With
End Sub

Private Sub SetVerticesLeftArrow(shp As Shape)
    Dim shfty As Single
    Dim shftx As Single

    InitVertices 8
    With shp
        On Error Resume Next
        shfty = .height * 0.25
        shftx = .width * 0.25

        shfty = .height * .Adjustments(1)
        shftx = .width * .Adjustments(2)
        
        If g_lApplicationVersion = 2007 Then
            Dim whRatio As Double: whRatio = 1
        
            If .height < .width Then
                whRatio = .width / .height
            End If
            Dim a1 As Double: a1 = .Adjustments(1) / whRatio
            Dim a2 As Double: a2 = 1 - .Adjustments(2)
    
            shfty = .height / 2 * a2 '.Adjustments(1)
            shftx = .width * a1 ' .Adjustments(2)
        End If

        Vert(1).x = .Left
        Vert(1).y = .Top + .height / 2
        Vert(2).x = .Left + shftx
        Vert(2).y = .Top
        Vert(3).x = Vert(2).x
        Vert(3).y = .Top + shfty
        Vert(4).x = .Left + .width
        Vert(4).y = Vert(3).y
        Vert(5).x = .Left + .width
        Vert(5).y = .Top + .height - shfty
        Vert(6).x = Vert(2).x
        Vert(6).y = Vert(5).y
        Vert(7).x = Vert(2).x
        Vert(7).y = .Top + .height
        Vert(8) = Vert(1)
    End With
End Sub

Private Sub SetVerticesUpArrow(shp As Shape)
    Dim shfty As Single
    Dim shftx As Single

    InitVertices 8
    With shp
        On Error Resume Next
        shfty = .height * 0.25
        shftx = .width * 0.25

        shfty = .height * .Adjustments(1)
        shftx = .width * .Adjustments(2)

        If g_lApplicationVersion = 2007 Then
            Dim hwRatio As Double: hwRatio = 1
        
            If .height > .width Then
                hwRatio = .height / .width
            End If
            Dim a1 As Double: a1 = 1 - .Adjustments(1)
            Dim a2 As Double: a2 = .Adjustments(2) / hwRatio
    
            shfty = .height * a2 '.Adjustments(1)
            shftx = .width / 2 * a1 '.Adjustments(2)
        End If
        
        Vert(1).x = .Left
        Vert(1).y = .Top + shfty
        Vert(2).x = .Left + .width / 2
        Vert(2).y = .Top
        Vert(3).x = .Left + .width
        Vert(3).y = Vert(1).y
        Vert(4).x = .Left + .width - shftx
        Vert(4).y = Vert(1).y
        Vert(5).x = Vert(4).x
        Vert(5).y = .Top + .height
        Vert(6).x = .Left + shftx
        Vert(6).y = Vert(5).y
        Vert(7).x = Vert(6).x
        Vert(7).y = Vert(1).y
        Vert(8) = Vert(1)
    End With
End Sub

Private Sub SetVerticesDownArrow(shp As Shape)
    Dim shfty As Single
    Dim shftx As Single

    InitVertices 8
    With shp
        On Error Resume Next
        shfty = .height * 0.75
        shftx = .width * 0.25

        shfty = .height * .Adjustments(1)
        shftx = .width * .Adjustments(2)
        
        If g_lApplicationVersion = 2007 Then
            Dim hwRatio As Double: hwRatio = 1
        
            If .height > .width Then
                hwRatio = .height / .width
            End If
            Dim a1 As Double: a1 = 1 - .Adjustments(1)
            Dim a2 As Double: a2 = 1 - .Adjustments(2) / hwRatio
            
            shfty = .height * a2 ' .Adjustments(1)
            shftx = .width / 2 * a1 '.Adjustments(2)
        End If

        Vert(1).x = .Left
        Vert(1).y = .Top + shfty
        Vert(2).x = .Left + .width / 2
        Vert(2).y = .Top + .height
        Vert(3).x = .Left + .width
        Vert(3).y = Vert(1).y
        Vert(4).x = .Left + .width - shftx
        Vert(4).y = Vert(1).y
        Vert(5).x = Vert(4).x
        Vert(5).y = .Top
        Vert(6).x = .Left + shftx
        Vert(6).y = Vert(5).y
        Vert(7).x = Vert(6).x
        Vert(7).y = Vert(1).y
        Vert(8) = Vert(1)
    End With
End Sub

Private Sub SetVerticesDonut(shp As Shape)
    Dim cirRatio As Single
    Dim shft        As Single
    Dim l           As Single       ' left, top, width and height of the inner circle
    Dim t           As Single
    Dim w           As Single
    Dim h           As Single

    InitVertices 26

    On Error Resume Next
    With shp
        cirRatio = 0.28

        shft = .Adjustments(1)
        If Err.Number <> 0 Then
            shft = 0.25
            Err.Clear
        End If

        Vert(1).x = .Left
        Vert(1).y = .Top + .height / 2
        Vert(1).SegType = msoSegmentCurve
        Vert(2).x = .Left
        Vert(2).y = Vert(1).y - .height * cirRatio
        Vert(2).SegType = msoSegmentCurve
        Vert(3).x = .Left + .width * (0.5 - cirRatio)
        Vert(3).y = .Top
        Vert(3).SegType = msoSegmentCurve
        Vert(4).x = .Left + .width / 2
        Vert(4).y = .Top
        Vert(4).SegType = msoSegmentCurve
        Vert(5).x = Vert(4).x + .width * cirRatio
        Vert(5).y = .Top
        Vert(5).SegType = msoSegmentCurve
        Vert(6).x = .Left + .width
        Vert(6).y = Vert(2).y
        Vert(6).SegType = msoSegmentCurve
        Vert(7).x = Vert(6).x
        Vert(7).y = Vert(1).y
        Vert(7).SegType = msoSegmentCurve
        Vert(8).x = Vert(7).x
        Vert(8).y = Vert(7).y + .height * cirRatio
        Vert(8).SegType = msoSegmentCurve
        Vert(9).x = Vert(5).x
        Vert(9).y = .Top + .height
        Vert(9).SegType = msoSegmentCurve
        Vert(10).x = Vert(4).x
        Vert(10).y = Vert(9).y
        Vert(10).SegType = msoSegmentCurve
        Vert(11).x = Vert(3).x
        Vert(11).y = Vert(10).y
        Vert(11).SegType = msoSegmentCurve
        Vert(12).x = Vert(1).x
        Vert(12).y = Vert(8).y
        Vert(12).SegType = msoSegmentCurve
        Vert(13) = Vert(1)
        Vert(13).SegType = msoSegmentLine

        ' inner circle
        l = .Left + .width * shft
        t = .Top + .height * shft
        w = .width * (1 - shft * 2)
        h = .height * (1 - shft * 2)

        Vert(14).x = l
        Vert(14).y = t + h / 2
        Vert(14).SegType = msoSegmentCurve
        Vert(15).x = l
        Vert(15).y = t + h * (0.5 + cirRatio)
        Vert(15).SegType = msoSegmentCurve
        Vert(16).x = l + w * (0.5 - cirRatio)
        Vert(16).y = t + h
        Vert(16).SegType = msoSegmentCurve
        Vert(17).x = l + w / 2
        Vert(17).y = t + h
        Vert(17).SegType = msoSegmentCurve
        Vert(18).x = Vert(17).x + w * cirRatio
        Vert(18).y = t + h
        Vert(18).SegType = msoSegmentCurve
        Vert(19).x = l + w
        Vert(19).y = Vert(15).y
        Vert(19).SegType = msoSegmentCurve
        Vert(20).x = Vert(19).x
        Vert(20).y = Vert(14).y
        Vert(20).SegType = msoSegmentCurve
        Vert(21).x = Vert(20).x
        Vert(21).y = Vert(20).y - h * cirRatio
        Vert(21).SegType = msoSegmentCurve
        Vert(22).x = Vert(18).x
        Vert(22).y = t
        Vert(22).SegType = msoSegmentCurve
        Vert(23).x = Vert(17).x
        Vert(23).y = t
        Vert(23).SegType = msoSegmentCurve
        Vert(24).x = Vert(16).x
        Vert(24).y = t
        Vert(24).SegType = msoSegmentCurve
        Vert(25).x = l
        Vert(25).y = Vert(21).y
        Vert(25).SegType = msoSegmentCurve
        Vert(26) = Vert(14)

    End With
End Sub

Public Sub SetShapeAsPolygon(gs As Long, pntStr As String, col As String, fcol As String)
    m_lecShapeType = LEC_SHAPETYPE_POLYGON
    m_lecDrawStyle = gs
    PointsString = pntStr
    m_szLineColor = col
    m_szFillColor = fcol
    m_bVisible = True
End Sub

Public Sub SetVerticesOval(shp As Shape, _
                            Optional bUserDefined As Boolean = False, _
                            Optional sl As Single, Optional st As Single, _
                            Optional sw As Single, Optional sh As Single)
    Dim cirRatio As Single
    'Dim l As Single, t As Single, w As Single, h As Single

    If Not bUserDefined Then
        sl = shp.Left
        st = shp.Top
        sw = shp.width
        sh = shp.height
    End If

    InitVertices 13

    With shp
        cirRatio = 0.28
        Vert(1).x = sl
        Vert(1).y = st + sh / 2
        Vert(1).SegType = msoSegmentCurve
        Vert(2).x = sl
        Vert(2).y = Vert(1).y - sh * cirRatio
        Vert(2).SegType = msoSegmentCurve
        Vert(3).x = sl + sw * (0.5 - cirRatio)
        Vert(3).y = st
        Vert(3).SegType = msoSegmentCurve
        Vert(4).x = sl + sw / 2
        Vert(4).y = st
        Vert(4).SegType = msoSegmentCurve
        Vert(5).x = Vert(4).x + sw * cirRatio
        Vert(5).y = st
        Vert(5).SegType = msoSegmentCurve
        Vert(6).x = sl + sw
        Vert(6).y = Vert(2).y
        Vert(6).SegType = msoSegmentCurve
        Vert(7).x = Vert(6).x
        Vert(7).y = Vert(1).y
        Vert(7).SegType = msoSegmentCurve
        Vert(8).x = Vert(7).x
        Vert(8).y = Vert(7).y + sh * cirRatio
        Vert(8).SegType = msoSegmentCurve
        Vert(9).x = Vert(5).x
        Vert(9).y = st + sh
        Vert(9).SegType = msoSegmentCurve
        Vert(10).x = Vert(4).x
        Vert(10).y = Vert(9).y
        Vert(10).SegType = msoSegmentCurve
        Vert(11).x = Vert(3).x
        Vert(11).y = Vert(10).y
        Vert(11).SegType = msoSegmentCurve
        Vert(12).x = Vert(1).x
        Vert(12).y = Vert(8).y
        Vert(12).SegType = msoSegmentCurve
        Vert(13) = Vert(1)
    End With
End Sub

Private Sub SetVerticesLeftRightArrow(shp As Shape)
    Dim shfty As Single
    Dim shftx As Single

    InitVertices 11
    With shp
        On Error Resume Next
        shftx = .width * 0.2
        shfty = .height * 0.25

        shftx = .width * .Adjustments(1)
        shfty = .height * .Adjustments(2)
        
        If g_lApplicationVersion = 2007 Then
            Dim whRatio As Double: whRatio = .width / 2 / .height
        
            Dim a1 As Double: a1 = .Adjustments(2) / whRatio
            Dim a2 As Double: a2 = 1 - .Adjustments(1)
    
    
            shftx = .width / 2 * a1
            shfty = .height / 2 * a2 '(1 - .Adjustments(1))
        End If

        Vert(1).x = .Left
        Vert(1).y = .Top + .height / 2
        Vert(2).x = .Left + shftx
        Vert(2).y = .Top
        Vert(3).x = Vert(2).x
        Vert(3).y = .Top + shfty
        Vert(4).x = .Left + .width - shftx
        Vert(4).y = Vert(3).y
        Vert(5).x = Vert(4).x
        Vert(5).y = .Top
        Vert(6).x = .Left + .width
        Vert(6).y = Vert(1).y
        Vert(7).x = Vert(4).x
        Vert(7).y = .Top + .height
        Vert(8).x = Vert(4).x
        Vert(8).y = .Top + .height - shfty
        Vert(9).x = Vert(2).x
        Vert(9).y = Vert(8).y
        Vert(10).x = Vert(2).x
        Vert(10).y = .Top + .height
        Vert(11) = Vert(1)
    End With
End Sub

Private Sub SetVerticesUpDownArrowCallout(shp As Shape)
    Dim shftx1 As Single
    Dim shftx2 As Single
    Dim shfty1 As Single
    Dim shfty2 As Single

    InitVertices 19
    With shp
        On Error Resume Next
        shftx1 = .width * 0.25
        shftx1 = .width * .Adjustments(2)
        shftx2 = .width * 0.375
        shftx2 = .width * .Adjustments(4)
        shfty1 = .height * 0.125
        shfty1 = .height * .Adjustments(3)
        shfty2 = .height * 0.25
        shfty2 = .height * .Adjustments(1)

        Vert(1).x = .Left
        Vert(1).y = .Top + shfty2
        Vert(2).x = .Left + shftx2
        Vert(2).y = Vert(1).y
        Vert(3).x = Vert(2).x
        Vert(3).y = .Top + shfty1
        Vert(4).x = .Left + shftx1
        Vert(4).y = Vert(3).y
        Vert(5).x = .Left + .width / 2
        Vert(5).y = .Top
        Vert(6).x = .Left + .width - shftx1
        Vert(6).y = Vert(4).y
        Vert(7).x = .Left + .width - shftx2
        Vert(7).y = Vert(6).y
        Vert(8).x = Vert(7).x
        Vert(8).y = Vert(2).y
        Vert(9).x = .Left + .width
        Vert(9).y = Vert(2).y
        Vert(10).x = .Left + .width
        Vert(10).y = .Top + .height - shfty2
        Vert(11).x = Vert(8).x
        Vert(11).y = Vert(10).y
        Vert(12).x = Vert(11).x
        Vert(12).y = .Top + .height - shfty1
        Vert(13).x = Vert(6).x
        Vert(13).y = Vert(12).y
        Vert(14).x = Vert(5).x
        Vert(14).y = .Top + .height
        Vert(15).x = Vert(4).x
        Vert(15).y = Vert(12).y
        Vert(16).x = Vert(2).x
        Vert(16).y = Vert(12).y
        Vert(17).x = Vert(2).x
        Vert(17).y = Vert(11).y
        Vert(18).x = Vert(1).x
        Vert(18).y = Vert(17).y
        Vert(19) = Vert(1)
    End With

End Sub

Private Sub SetShapeVertices(shp As Shape)

    If shp.Type = msoFreeform Then
        ImportShapeAsPolygon shp, False, False
        'NewFlipNodes shp   ' do not flip nodes. The nodes are flipped in ReadNodes()
        Exit Sub
    End If

    Select Case shp.AutoShapeType
        Case msoShapeMixed  ' shape maybe msoLine or msoTextBox
            Select Case shp.Type
                Case MsoShapeType.msoLine
                    If InitVertices(2) < 1 Then     ' init Vert() failed
                        Exit Sub
                    End If

                    With shp
                        Vert(1).x = .Left
                        Vert(1).y = .Top
                        Vert(2).x = .Left + .width
                        Vert(2).y = .Top + .height
                    End With
                'Case MsoShapeType.msoTextBox
                Case Else   ' msoTable have no shadow
                     If shp.Connector = msoTrue Then
                          Select Case shp.ConnectorFormat.Type
                              Case msoConnectorStraight
                                  SetVerticesConnectorStraight shp
                              Case msoConnectorElbow
                                  SetVerticesConnectorElbow shp
                              Case msoConnectorCurve
                                  SetVerticesConnectorCurve shp
                              Case Else
                                  SetVerticesConnectorElbow shp
                          End Select
                      Else
                          m_bShpIsUnsupported = True
                          SetVerticesRect shp         ' set bounding box as a rectangle
                    End If
            End Select
        Case MsoAutoShapeType.msoShapeRectangle, MsoAutoShapeType.msoShapeFlowchartProcess
            SetVerticesRect shp
        Case MsoAutoShapeType.msoShapeRightTriangle
            SetVerticesRightTriangle shp
        Case MsoAutoShapeType.msoShapeIsoscelesTriangle
            SetVerticesIsoscelesTriangle shp
        Case MsoAutoShapeType.msoShapeParallelogram, MsoAutoShapeType.msoShapeFlowchartData
            SetVerticesParallelogram shp
        Case MsoAutoShapeType.msoShapeTrapezoid, msoShapeFlowchartManualOperation
            SetVerticesTrapezoid shp
        Case MsoAutoShapeType.msoShapeDiamond, MsoAutoShapeType.msoShapeFlowchartDecision
            SetVerticesDiamond shp
        Case MsoAutoShapeType.msoShapeOctagon
            SetVerticesOctagon shp
        Case MsoAutoShapeType.msoShapeHexagon, msoShapeFlowchartPreparation
            SetVerticesHexagon shp
        Case MsoAutoShapeType.msoShapeRegularPentagon
            SetVerticesRegularPentagon shp
        Case MsoAutoShapeType.msoShapeRightArrow
            SetVerticesRightArrow shp
        Case MsoAutoShapeType.msoShapeLeftArrow
            SetVerticesLeftArrow shp
        Case MsoAutoShapeType.msoShapeUpArrow
            SetVerticesUpArrow shp
        Case MsoAutoShapeType.msoShapeDownArrow
            SetVerticesDownArrow shp
        Case MsoAutoShapeType.msoShapeLeftRightArrow
            SetVerticesLeftRightArrow shp
        Case MsoAutoShapeType.msoShapeUpDownArrow
            SetVerticesUpDownArrow shp
        Case MsoAutoShapeType.msoShapeQuadArrow
            SetVerticesQuadArrow shp
        Case MsoAutoShapeType.msoShapeLeftRightUpArrow
            SetVerticesLeftRightUpArrow shp
        Case MsoAutoShapeType.msoShapeLeftUpArrow
            SetVerticesLeftUpArrow shp
        Case MsoAutoShapeType.msoShapeBentUpArrow
            SetVerticesBentUpArrow shp
        Case MsoAutoShapeType.msoShapeStripedRightArrow
            SetVerticesStripeRightArrow shp
        Case MsoAutoShapeType.msoShapeNotchedRightArrow
            SetVerticesNotchedRightArrow shp
        Case MsoAutoShapeType.msoShapePentagon
            SetVerticesPentagon shp
        Case MsoAutoShapeType.msoShapeChevron
            SetVerticesChevron shp
        Case MsoAutoShapeType.msoShapeRightArrowCallout
            SetVerticesRightArrowCallout shp
        Case MsoAutoShapeType.msoShapeLeftArrowCallout
            SetVerticesLeftArrowCallout shp
        Case MsoAutoShapeType.msoShapeUpArrowCallout
            SetVerticesUpArrowCallout shp
        Case MsoAutoShapeType.msoShapeDownArrowCallout
            SetVerticesDownArrowCallout shp
        Case MsoAutoShapeType.msoShapeLeftRightArrowCallout
            SetVerticesLeftRightArrowCallout shp
        Case MsoAutoShapeType.msoShapeUpDownArrowCallout
            SetVerticesUpDownArrowCallout shp
        Case MsoAutoShapeType.msoShapeQuadArrowCallout
            SetVerticesQuadArrowCallout shp
        Case MsoAutoShapeType.msoShapeFlowchartConnector, MsoAutoShapeType.msoShapeOval
            SetVerticesOval shp
        Case msoShapeDonut
            SetVerticesDonut shp
        Case MsoAutoShapeType.msoShapeFlowchartOffpageConnector
            SetVerticesFlowchartOffpageConnector shp
        Case MsoAutoShapeType.msoShapeFlowchartManualInput
            SetVerticesFlowchartManualInput shp
        Case msoShapeFlowchartCard
            SetVerticesFlowchartCard shp
        Case msoShapeFlowchartOr        ' no 3D effect.
            SetVerticesFlowchartOr shp
        Case msoShapeFlowchartCollate
            SetVerticesFlowchartCollate shp
        Case msoShapeFlowchartExtract
            SetVerticesFlowchartExtract shp
        Case msoShapeFlowchartMerge
            SetVerticesFlowchartMerge shp
        Case msoShapeFlowchartStoredData
            SetVerticesFlowchartStoredData shp
        Case msoShapeFlowchartPunchedTape
            SetVerticesFlowchartPunchedTape shp
        Case msoShapeFlowchartPredefinedProcess     ' no 3D effect
            SetVerticesFlowchartPredefinedProcess shp
        Case msoShapeFlowchartInternalStorage
            SetVerticesFlowchartInternalStorage shp
        Case msoShapeFlowchartDocument
            SetVerticesFlowchartDocument shp
        Case msoShapeFlowchartAlternateProcess, msoShapeRoundedRectangle
            SetVerticesFlowchartAlternateProcess shp
        Case msoShapeFlowchartTerminator
            SetVerticesFlowchartTerminator shp
        Case msoShapeFlowchartDelay
            SetVerticesFlowchartDelay shp
        Case msoShapeFlowchartSequentialAccessStorage
            SetVerticesFlowchartSequentialAccessStorage shp
        Case msoShapeFlowchartDisplay
            SetVerticesFlowchartDisplay shp
        Case msoShapeCross
            SetVerticesCross shp
        Case msoShapeBentArrow
            SetVerticesBentArrow shp
        Case msoShapeUTurnArrow
            SetVerticesUTurnArrow shp
        Case msoShapeLeftBracket
            SetVerticesLeftBrackt shp
        Case msoShapeRightBracket
            SetVerticesRightBrackt shp
        Case msoShapeLeftBrace
            SetVerticesLeftBrace shp
        Case msoShapeRightBrace
            SetVerticesRightBrace shp
        Case msoShapeExplosion1
            SetVerticesExplosion1 shp
        Case msoShapeExplosion2
            SetVerticesExplosion2 shp
        Case msoShape4pointStar
            SetVertices4pointStar shp
        Case msoShape5pointStar
            SetVertices5pointStar shp
        Case msoShape8pointStar
            SetVertices8pointStar shp
        Case msoShapeLightningBolt
            SetVerticesLightningBolt shp
        Case msoShapeMoon
            SetVerticesMoon shp
        Case MsoAutoShapeType.msoShapeCube
            SetVerticesCube shp
        Case msoShapeFlowchartSort
            SetVerticesFlowchartSort shp
        Case msoShapeFlowchartMultidocument
            SetVerticesFlowchartMultidocument shp
        Case msoShapeFlowchartSummingJunction
            SetVerticesFlowchartSummingJunction shp
        Case msoShapeCan, msoShapeFlowchartMagneticDisk
            SetVerticesCan shp
        Case msoShapeFlowchartDirectAccessStorage
            SetVerticesFlowchartDirectAccessStorage shp
        Case msoShapeBevel, msoShapeActionButtonCustom
            SetVerticesBevel shp
        Case msoShapeDoubleBracket
            SetVerticesDoubleBracket shp
        Case msoShapeDoubleBrace
            SetVerticesDoubleBrace shp
        Case msoShapePlaque
            SetVerticesPlaque shp
        Case msoShapeFoldedCorner
            SetVerticesFoldedCorner shp
        Case msoShapeSmileyFace
            SetVerticesSmileyFace shp
        Case msoShapeCurvedRightArrow
            SetVerticesCurvedRightArrow shp
        Case msoShapeCurvedLeftArrow
            SetVerticesCurvedLeftArrow shp
        Case msoShapeCurvedUpArrow
            SetVerticesCurvedUpArrow shp
        Case msoShapeCurvedDownArrow
            SetVerticesCurvedDownArrow shp
        Case msoShapeRectangularCallout     ' 3D effect still incorrect
            SetVerticesRectangularCallout shp
        Case msoShapeRoundedRectangularCallout ' 3D effect still incorrect
            SetVerticesRoundedRectangularCallout shp
        Case msoShapeOvalCallout
            SetVerticesOvalCallout shp
        Case msoShapeCloudCallout
            SetVerticesCloudCallout shp
        Case Else
            m_bShpIsUnsupported = True
            SetVerticesRect shp
    End Select

    NewFlipNodes shp

End Sub

Private Sub SetNewCalloutAnchor(shp As Shape)
    Dim l As Single, t As Single, r As Single, b As Single
    Dim i As Long

    NewFlipNodes shp
    NewRotateNodes shp
    ' get the dimension
    l = x
    r = x
    t = y
    b = y
    For i = 1 To VertNum
        If Vert(i).x < l Then
            l = Vert(i).x
        ElseIf Vert(i).x > r Then
            r = Vert(i).x
        End If
        If Vert(i).y < t Then
            t = Vert(i).y
        ElseIf Vert(i).y > b Then
            b = Vert(i).y
        End If
    Next

    x = l
    y = t
    width = r - l
    height = b - t

End Sub

' the vertices can only be used to find out the dimension,
' they're not the actual bounding points.
Private Sub SetVerticesOvalCallout(shp As Shape)
    Dim ratio1 As Single, ratio2 As Single, shftx3 As Single, shfty3 As Single

    SetVerticesOval shp
    VertNum = VertNum + 1
    ReDim Preserve Vert(1 To VertNum) As aofNode

    With shp
        On Error Resume Next
        ratio1 = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio1 = 0.0625
            Err.Clear
        End If
        ratio2 = .Adjustments(2)
        If Err.Number <> 0 Then
            ratio2 = 1.2
        End If
        On Error GoTo 0

        If shp.VerticalFlip = msoTrue Then
            ratio1 = 1 - ratio1
            ratio2 = 1 - ratio2
        End If
        ' the callout point
        shftx3 = .width * ratio1
        shfty3 = .height * ratio2

        Vert(VertNum).x = .Left + shftx3
        Vert(VertNum).y = .Top + shfty3
    End With
End Sub

Private Sub SetVerticesCloudCallout(shp As Shape)
    Dim ratio1 As Single, ratio2 As Single

    Dim zLeft As Single: zLeft = shp.Left
    Dim zTop As Single: zTop = shp.Top
    Dim zRight As Single: zRight = shp.Left + shp.width
    Dim zBottom As Single: zBottom = shp.Top + shp.height
    
    With shp
        Dim pointX, pointY As Single
        On Error Resume Next

        ratio1 = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio1 = 0.0625
            Err.Clear
        End If
        ratio2 = .Adjustments(2)
        If Err.Number <> 0 Then
            ratio2 = 1.2
        End If
        On Error GoTo 0

        If shp.VerticalFlip = msoTrue And shp.HorizontalFlip = False Then
            ratio1 = 1 - ratio1
            ratio2 = 1 - ratio2
        End If
        
        pointX = .Left + .width * ratio1
        pointY = .Top + .height * ratio2
        
        If pointX < zLeft Then
            zLeft = pointX
        ElseIf pointX > zRight Then
            zRight = pointX
        End If
        
        If pointY < zTop Then
            zTop = pointY
        ElseIf pointY > zBottom Then
            zBottom = pointY
        End If
    End With
    
    InitVertices 5
    With shp
        Vert(1).x = zLeft
        Vert(1).y = zTop
        Vert(2).x = zRight
        Vert(2).y = zTop
        Vert(3).x = zRight
        Vert(3).y = zBottom
        Vert(4).x = zLeft
        Vert(4).y = zBottom
        Vert(5) = Vert(1)
    End With
    
    If shp.HorizontalFlip = True Then
        NewFlipNodes shp
    End If
End Sub

'
' rotations and Flipping
'

Private Sub NewFlipNodes(shp As Shape)
    Dim midline     As Long
    Dim i           As Long

    With shp
        If .VerticalFlip = msoTrue Then
            midline = .Top * 2 + .height
            For i = 1 To VertNum
                Vert(i).y = midline - Vert(i).y
            Next
        End If
        If .HorizontalFlip = msoTrue Then
            midline = .Left * 2 + .width
            For i = 1 To VertNum
                Vert(i).x = midline - Vert(i).x
            Next
        End If
    End With
End Sub

Public Sub NewRotateNodes(shp As Shape) '(rotAng As Long)
    Dim c11     As Double
    Dim c12     As Double
    Dim c21     As Double
    Dim c22     As Double
    Dim d1      As Double
    Dim d2      As Double
    Dim ang     As Double

    Dim nx      As Double
'    Dim ny      As Double

    If shp.Rotation = 0 Then
        Exit Sub
    End If

    ang = -shp.Rotation * PI / 180
    c11 = Cos(ang)
    c12 = Sin(ang)
    c21 = -c12
    c22 = c11

    Dim x0      As Double
    Dim y0      As Double

    x0 = shp.Left + shp.width / 2
    y0 = shp.Top + shp.height / 2

    d1 = x0 - x0 * c11 - y0 * c12
    d2 = y0 - x0 * c21 - y0 * c22

    Dim i        As Long

    For i = 1 To VertNum
        With Vert(i)
            nx = .x
            .x = c11 * .x + c12 * .y + d1
            .y = c21 * nx + c22 * .y + d2
        End With
    Next
End Sub

'
' Vertices
'

Private Sub SetBoundingPoints()
    Dim i                   As Long
    Dim j                   As Long
    Dim strTemp             As String
    Dim InsertedPoints      As Long
    Dim sgPoints(0 To 3)    As WBPoint

    Set BPoints = New aofPoints

    i = 1
    Do While i <= VertNum
        With Vert(i)
            If .SegType = MsoSegmentType.msoSegmentLine Then        ' line segment
                strTemp = strTemp & "{" & CLng(.x) & " " & CLng(.y) & "} "
                i = i + 1
                PointNum = PointNum + 1

                BPoints.Add CLng(.x), CLng(.y)

            Else        'nSegType = MsoSegmentType.msoSegmentCurve   bezier curve segment
                If i < VertNum Then        ' else reached the end of Vertices.
                    For j = 1 To 4
                        If i - 1 + j <= VertNum Then
                            sgPoints(j - 1).x = Vert(i - 1 + j).x
                            sgPoints(j - 1).y = Vert(i - 1 + j).y
                        Else
                            sgPoints(j - 1).x = Vert(1).x
                            sgPoints(j - 1).y = Vert(1).y
                        End If
                    Next
                    strTemp = strTemp & InsertBezierPoints(sgPoints, InsertedPoints)
                    i = i + 3
                    PointNum = PointNum + InsertedPoints
                Else
                    strTemp = strTemp & "{" & CLng(.x) & " " & CLng(.y) & "} "
                    i = i + 1
                    PointNum = PointNum + 1

                    BPoints.Add CLng(.x), CLng(.y)

                End If
            End If
        End With
    Loop

    If BPoints.Count < 1 Then
        m_bVisible = False
    End If
'    PointsString = BPoints.PrintString()
End Sub

Private Sub NewSetBoundingPoints(Optional nBegin As Long = -1, Optional nEnd As Long = -1)
    Dim i                   As Long
    Dim j                   As Long
    Dim strTemp             As String
    Dim InsertedPoints      As Long
    Dim sgPoints(0 To 3)    As WBPoint
    Dim nb                  As Long
    Dim ne                  As Long

    BPoints.Clear

    If nBegin < 0 Or nEnd < 0 Then
        nb = 1
        ne = VertNum
    Else
        nb = nBegin
        ne = nEnd
    End If

    On Error Resume Next        ' user-defined nBegin and nEnd may cuase the index overflow of Vert()
    i = nb '1
    Do While i <= ne 'VertNum
        With Vert(i)
            If .SegType = MsoSegmentType.msoSegmentLine Then        ' line segment
                strTemp = strTemp & "{" & CLng(.x) & " " & CLng(.y) & "} "
                i = i + 1
                PointNum = PointNum + 1

                BPoints.Add CLng(.x), CLng(.y)

            Else        'nSegType = MsoSegmentType.msoSegmentCurve   bezier curve segment
                If i < VertNum Then        ' else reached the end of Vertices.
                    For j = 1 To 4
                        If i - 1 + j <= VertNum Then
                            sgPoints(j - 1).x = Vert(i - 1 + j).x
                            sgPoints(j - 1).y = Vert(i - 1 + j).y
                        Else
                            sgPoints(j - 1).x = Vert(1).x
                            sgPoints(j - 1).y = Vert(1).y
                        End If
                    Next
                    strTemp = strTemp & InsertBezierPoints(sgPoints, InsertedPoints)
                    i = i + 3
                    PointNum = PointNum + InsertedPoints
                Else
                    strTemp = strTemp & "{" & CLng(.x) & " " & CLng(.y) & "} "
                    i = i + 1
                    PointNum = PointNum + 1

                    BPoints.Add CLng(.x), CLng(.y)

                End If
            End If
        End With
    Loop

    If BPoints.Count < 1 Then
        m_bVisible = False
    End If
'    PointsString = BPoints.PrintString()
End Sub

'
'   Parse Shapes
'

Public Sub ParseSimpleShape(shp As Shape)
 
    If shp.Type = msoAutoShape And shp.AutoShapeType = msoShapeRectangle And _
       (shp.width = 0 Or shp.height = 0) Then
       Exit Sub
    End If
    
    SetGraphmode shp
    NewRotateNodes shp
    NewSetBoundingPoints
    IsClosedPolyline = BPoints.IsClosed()
    PointsString = BPoints.PrintString()
    m_lecShapeType = LEC_SHAPETYPE_POLYGON
End Sub

Private Sub ParseComplexShapes(shp As Shape)

    Dim bSizecalculated As Boolean
            
    Select Case shp.AutoShapeType
        Case MsoAutoShapeType.msoShapeStripedRightArrow
            ParseStripeRightArrow shp
        Case MsoAutoShapeType.msoShapeFlowchartConnector
            ImportShapeAsOval shp
        Case msoShapeDonut
            ParseDonut shp
        Case msoShapeFlowchartOr        ' no 3D effect.
            ParseFlowchartOr shp
        Case MsoAutoShapeType.msoShapeCube
            ParseCube shp
        Case msoShapeFlowchartSummingJunction
            ParseFlowchartSummingJunction shp
        Case msoShapeCan, msoShapeFlowchartMagneticDisk
            ParseCan shp
        Case msoShapeBevel, msoShapeActionButtonCustom
            ParseBevel shp
        Case msoShapeDoubleBracket
            ParseDoubleBracket shp
        Case msoShapeDoubleBrace
            ParseDoubleBrace shp
        Case msoShapeFoldedCorner
            ParseFoldedCorner shp
        Case msoShapeSmileyFace
            ParseSmileyFace shp
        Case msoShapeCurvedRightArrow
            ParseCurvedRightArrow shp
        Case msoShapeCurvedLeftArrow
            ParseCurvedLeftArrow shp
        Case msoShapeCurvedUpArrow
            ParseCurvedUpArrow shp
        Case msoShapeCurvedDownArrow
            ParseCurvedDownArrow shp
        Case msoShapeOvalCallout, msoShapeCloudCallout
            ImportShapeBackgroundAsImage shp, bSizecalculated
            If Not bSizecalculated Then
                SetNewCalloutAnchor shp
                m_iCutTransOff = 0
            End If
        Case Else
            ImportShapeBackgroundAsImage shp, bSizecalculated
            If Not bSizecalculated Then
                SetNewAnchor shp
                m_iCutTransOff = 0
            End If
        End Select
End Sub

Private Sub ParseDonut(shp As Shape)

    NewRotateNodes shp     ' rotate vertices
    SetGraphstyle shp

    If m_lecDrawStyle = LEC_DRAWSTYLE_FILLED Or m_lecDrawStyle = LEC_DRAWSTYLE_FILLEDOUTLINE Then
        ' add the filled polygon
        AddGroupItem
        With GroupItems(GroupItemNum)
            .SetShapeType (LEC_SHAPETYPE_POLYGON)
            .m_lecDrawStyle = LEC_DRAWSTYLE_FILLED       ' no outlines
            .InitVerts 1, VertNum, Vert, True
            .m_szFillColor = m_szFillColor
            .PrintPointsString
        End With
    End If

    If m_lecDrawStyle = LEC_DRAWSTYLE_OUTLINE Or m_lecDrawStyle = LEC_DRAWSTYLE_FILLEDOUTLINE Then
        ' add the outlines
        AddGroupItem
        With GroupItems(GroupItemNum)
'            If shp.Rotation = 0 Then
'                .PerformOval shp
'                .m_lecDrawStyle = LEC_DRAWSTYLE_OUTLINE
'            Else
                .SetShapeType (LEC_SHAPETYPE_POLYGON)
                .m_lecDrawStyle = LEC_DRAWSTYLE_OUTLINE
                .InitVerts 1, 13, Vert, True
                .m_szLineColor = m_szLineColor
                .PrintPointsString
'            End If
        End With

        AddGroupItem
        BPoints.Clear
        NewSetBoundingPoints 14, 26      ' inner circle
        BPoints.PrintString
        With GroupItems(GroupItemNum)
            .SetShapeType (LEC_SHAPETYPE_POLYGON)
            .m_lecDrawStyle = LEC_DRAWSTYLE_OUTLINE
            .InitVerts 14, 13, Vert, True
            .m_szLineColor = m_szLineColor
            .PrintPointsString
        End With
    End If

    m_lecShapeType = LEC_SHAPETYPE_USERDEFINEDGROUP

End Sub

'
' 3D
'

Private Sub Set3DObjectOffset(shp As Shape)
    NewSet3DBoundaryPoints shp
End Sub

Private Sub NewSet3DBoundaryPoints(shp As Shape)
    SetShapeVertices shp
    ' do not rotate the shape, the shape should be rotated in ThreeDTransform()
    NewSetBoundingPoints
    ' ThreedTransform here

    Dim vnum        As Long         ' the number of boundary points
    Dim i           As Long
    Dim ExtrusionDir As Long
    Dim offsetWidth  As Single
    Dim offsetHeight As Single

    offsetWidth = 0
    offsetHeight = 0

    vnum = BPoints.Count * 2
    ReDim v(1 To vnum, 1 To 3)
    BPoints.SetV v

    On Error Resume Next
    With shp
        ExtrusionDir = .ThreeD.PresetExtrusionDirection
        If Err.Number <> 0 Then
            ExtrusionDir = -1
        End If

        ThreeDTransform vnum, .ThreeD.RotationX, .ThreeD.RotationY, .Rotation, _
                    .Left, .Top, .width + offsetWidth, .height + offsetHeight, _
                    .ThreeD.Depth, .ThreeD.Perspective, ExtrusionDir
    End With
End Sub

Private Function ThreeDTransform(vnum As Long, rx As Single, ry As Single, rz As Single, _
                        l As Single, t As Single, w As Single, h As Single, d As Single, _
                        bPerspective As Boolean, ExtrusionDir As Long)
    Dim T11 As Double
    Dim T12 As Double
    Dim T13 As Double
    Dim T21 As Double
    Dim T22 As Double
    Dim T23 As Double
    Dim T31 As Double
    Dim T32 As Double
    Dim T33 As Double

    Dim sa As Double
    Dim ca As Double
    Dim sb As Double
    Dim cb As Double
    Dim sc As Double
    Dim cc As Double

    Dim x0 As Double
    Dim y0 As Double

    Dim hw As Double
    Dim hh As Double

    Dim r As Double

    Dim i As Long, j As Long

'    Dim v(1 To 8, 1 To 3) As Double     ' coordinates before transform
'    Dim p(1 To 8, 1 To 3) As Double     ' coordiantes after transform
'    Dim f(1 To 8, 1 To 2) As Double     ' coordinates after 2D affine transform
    ReDim p(1 To vnum, 1 To 3) As Double    ' coordiantes after transform
    ReDim f(1 To vnum, 1 To 2) As Double    ' coordinates after 2D affine transform


    sa = Sin(rx * PI / 180)
    ca = Cos(rx * PI / 180)
    sb = Sin(ry * PI / 180)
    cb = Cos(ry * PI / 180)
    sc = Sin(-rz * PI / 180)
    cc = Cos(-rz * PI / 180)

    T11 = cb * cc
    T21 = -sa * sb * cc - ca * sc
    T31 = -ca * sb * cc + sa * sc
    T12 = cb * sc
    T22 = -sa * sb * sc + ca * cc
    T32 = -ca * sb * sc - sa * cc
    T13 = sb
    T23 = sa * cb
    T33 = ca * cb

    hw = w / 2
    hh = h / 2

    ' prepare the array:
    ' move the coordinate origin to the center of the boundary, and
    ' set the boundary points in far half part.
    For i = 1 To vnum / 2
        v(i, 1) = v(i, 1) - l - hw
        v(i, 2) = v(i, 2) - t - hh
        v(i, 3) = 0
        v(i + vnum / 2, 1) = v(i, 1)
        v(i + vnum / 2, 2) = v(i, 2)
        v(i + vnum / 2, 3) = d
    Next
    ' rotate
    For i = 1 To vnum   '8
        p(i, 1) = T11 * v(i, 1) + T12 * v(i, 2) + T13 * v(i, 3)
        p(i, 2) = T21 * v(i, 1) + T22 * v(i, 2) + T23 * v(i, 3)
        p(i, 3) = T31 * v(i, 1) + T32 * v(i, 2) + T33 * v(i, 3)
    Next

    ' 2D affine transform
    If bPerspective Then

        Dim viewpx As Double    'view point
        Dim viewpy As Double
        Dim vo As Double

        Dim minx As Double, miny As Double, maxx As Double, maxy As Double
        minx = p(1, 1)
        maxx = minx
        miny = p(1, 2)
        maxy = miny

        ' find the boundry of rotated shape
        For i = 2 To (vnum / 2) '4
            If p(i, 1) < minx Then
                minx = p(i, 1)
            ElseIf p(i, 1) > maxx Then
                maxx = p(i, 1)
            End If
            If p(i, 2) < miny Then
                miny = p(i, 2)
            ElseIf p(i, 2) > maxy Then
                maxy = p(i, 2)
            End If
        Next

        viewpx = (maxx - minx) / 2
        viewpy = (maxy - miny) / 2

        vo = 100    ' offset from the shape corner to the viewpoint, a constant in PowerPoint

        Select Case ExtrusionDir
            Case MsoPresetExtrusionDirection.msoExtrusionBottomRight
                viewpx = -viewpx - vo
                viewpy = -viewpy - vo
            Case MsoPresetExtrusionDirection.msoExtrusionBottom
                viewpx = 0
                viewpy = -viewpy - vo
            Case MsoPresetExtrusionDirection.msoExtrusionBottomLeft
                viewpx = viewpx + vo
                viewpy = -viewpy - vo
            Case MsoPresetExtrusionDirection.msoExtrusionRight
                viewpx = -viewpx - vo
                viewpy = 0
            Case MsoPresetExtrusionDirection.msoExtrusionNone
                viewpx = 0
                viewpy = 0
            Case MsoPresetExtrusionDirection.msoExtrusionLeft
                viewpx = viewpx + vo
                viewpy = 0
            Case MsoPresetExtrusionDirection.msoExtrusionTopRight
                viewpx = -viewpx - vo
                viewpy = viewpy + vo
            Case MsoPresetExtrusionDirection.msoExtrusionTop
                viewpx = 0
                viewpy = viewpy + vo
            Case MsoPresetExtrusionDirection.msoExtrusionTopLeft
                viewpx = viewpx + vo
                viewpy = viewpy + vo
            Case Else
        End Select

        '   2D affine of 3D perspective transform
        '       / 1 0 0 0 \
        '       | 0 1 0 0 |
        '   T = | 0 0 0 r |
        '       \ 0 0 0 1 /
        '   e.g. ExtrusionDirectoryTopRight
        '       viewpoint is in positive z axis.
        '   top right corner of the shape A (Xa, Ya, Za, 1)  Xa=100, Ya=100, Za = 0
        '   remote top right corner A' (Xa', Ya', Za', 1)    Xa'=Xa, Ya'=Ya, Za'=d (depth)
        '   after the transform:  A -> B (Xb, Yb, Zb, 1)  Xb=Xa, Yb=Ya, Zb=Za=0
        '                         A'-> B'(Xb',Yb',Zb',1)  Xb'=Xb/(1+rd), Yb'=Yb/(1+rd), Zb'=0
        '               offsetX = Xb' - Xb = rd/(1+rd) * Xb
        '   as the real value (A'):1 (100, 100, 36, 1) -> (94, 94, 0, 1)
        '                     (A'):2 (100, 100, 9600, 1)->(7, 7, 0, 1)
        '                     ...
        '                   => r ~ 0.0014
        '                   => the vanishing point ~ (0, 0, -714)
        r = 0.0014

        For i = 1 To vnum '8
            f(i, 1) = (p(i, 1) + viewpx) / (1 + r * p(i, 3)) + l + hw - viewpx
            f(i, 2) = (p(i, 2) + viewpy) / (1 + r * p(i, 3)) + t + hh - viewpy
        Next
    Else
        'No perspective
        '       / 1  0  (0.5 * cos(a)) 0 \
        '       | 0  1 -(0.5 * sin(a)) 0 |
        '   T = | 0  0               0 0 |
        '       \ 0  0               0 1 /
        ' a = pi/4 or a = pi/2
        ' vp = 0.5 * sin(pi/4)
        ' vq = 0.5 * sin(pi/2)
        Dim vp As Double, vq As Double

        vp = 0.3535         ' 0.5 * sin PI/4
        vq = 0.5            ' 0.5 * sin PI/2

        Dim a1 As Double, a2 As Double

        Select Case ExtrusionDir
            Case MsoPresetExtrusionDirection.msoExtrusionBottomRight
                a1 = vp
                a2 = vp
            Case MsoPresetExtrusionDirection.msoExtrusionBottom
                a1 = 0
                a2 = vq
            Case MsoPresetExtrusionDirection.msoExtrusionBottomLeft
                a1 = -vp
                a2 = vp
            Case MsoPresetExtrusionDirection.msoExtrusionRight
                a1 = vq
                a2 = 0
            Case MsoPresetExtrusionDirection.msoExtrusionNone
                a1 = 0
                a2 = 0
            Case MsoPresetExtrusionDirection.msoExtrusionLeft
                a1 = -vq
                a2 = 0
            Case MsoPresetExtrusionDirection.msoExtrusionTopRight
                a1 = vp
                a2 = -vp
            Case MsoPresetExtrusionDirection.msoExtrusionTop
                a1 = 0
                a2 = -vq
            Case MsoPresetExtrusionDirection.msoExtrusionTopLeft
                a1 = -vp
                a2 = -vp
            Case Else
        End Select

        For i = 1 To vnum '8
            f(i, 1) = p(i, 1) + a1 * p(i, 3) + l + hw
            f(i, 2) = p(i, 2) + a2 * p(i, 3) + t + hh
        Next
    End If

    Dim lb As Double, tb As Double, rb As Double, bb As Double  ' boundary

    ' find position and size
    lb = f(1, 1)
    rb = f(1, 1)
    tb = f(1, 2)
    bb = f(1, 2)
    For i = 2 To vnum   '8
        If f(i, 1) > rb Then
            rb = f(i, 1)
        ElseIf f(i, 1) < lb Then
            lb = f(i, 1)
        End If
        If f(i, 2) > bb Then
            bb = f(i, 2)
        ElseIf f(i, 2) < tb Then
            tb = f(i, 2)
        End If
    Next

    x = lb
    y = tb
    width = rb - lb
    height = bb - tb

    Erase v
    Erase p
    Erase f
'    With ActivePresentation.Slides(1).Shapes.AddShape(msoShapeRectangle, x, y, Width, Height)
'        .Line.ForeColor.RGB = RGB(255, 0, 0)
'        .Fill.Visible = msoFalse
'    End With

End Function


'
' Miscellaneous Functions
'

Private Function ShapeHasToBeSavedAsImage(sld As Slide, shp As Shape, paragraphDescription As String) As Boolean

    On Error Resume Next
    
    Dim bShapeIsSavedAsImage As Boolean
    bShapeIsSavedAsImage = False

    ' In this procedure, some important properties are set:
    ' a) ShapeSize (by SetSize(shp))
    ' b) ShpHas3D  (by Has3DEffect(shp))
    ' c) ShpHasShadow (by HasShadow(shp))
    ' d) ShpHasText   (by HasTextInShape(shp))
    ' e) ShpHasConvertableText
    '    e.1) "ConvertableText" means the Text is not null/invisible string,
    '         OrientationVertical and not rotated. So,
    '         if ShapeHasText and TextOrientation <> OrientationHorizontal
    '            and Shp.Rotate = 0 then ShpHasConvertableText is true,
    '         otherwise, false.
    '    e.2) If there is unconvertalbe text, the (whole) shape should be
    '         exported into image, and in WMF format in order to keep the
    '         fine display quality.
    '    (+) "ShpHasRotatedText" is more reasonable. (13.02.03)
    '    e.3) If ShpHasText and TextOrientation <> OrientationHorizontal
    '            and Shp.Rotate = 0
    '         then ShpHasRotatedText is false, set m_bConvertToPNG as true,
    '         else ShpHasRotatedText is true, set m_bConvertToPNG as false.
    ' f) ShpIsSolidFilled (by IsSolidFilled(shp), since Lecturnity only
    '      supports solid fill mode, shapes with other fill modes should be
    '      exported as images)
    
    Dim bSizecalculated As Boolean
    ' Some AutoShapes will be exported as Image
    If g_lApplicationVersion <> 2000 Then
        If shp.Type = msoAutoShape Then
            CheckAutoShapeType shp
            If m_bExportAutoformAsImage Then
                ImportShapeTextAsText sld, shp, paragraphDescription
                ImportShapeBackgroundAsImage shp, bSizecalculated
                bShapeIsSavedAsImage = True
            End If
        End If
    End If
        
    If Not bShapeIsSavedAsImage Then
        ' At present, all 3D objects are converted as images.
        If m_bShpHas3D Then
            Dim bHasRotation As Boolean: bHasRotation = False
#If COMPILE_VERSION = 2007 Then
            bHasRotation = shp.ThreeD.RotationX <> 0 Or _
                           shp.ThreeD.RotationY <> 0 Or _
                           shp.ThreeD.RotationZ <> 0
#End If
            ' If there is a rotation the text and the image are imported in the same image.
            If g_lApplicationVersion = 2007 Then
                If bHasRotation Then
                    PerformAsImage shp
                    bShapeIsSavedAsImage = True
                End If
            End If
            
            If Not bShapeIsSavedAsImage Then
                ' In this procedure, the "convertable" text should be converted to
                ' an individual object, the further content search and retrieve is
                ' therefore possible.
                ImportShapeTextAsText sld, shp
                ImportShapeBackgroundAsImage shp, bSizecalculated
                If Not bSizecalculated Then
                    ' This is the core function of 3D object conversion, the accurate
                    ' position and size of the exported image are given here.
                    Set3DObjectOffset shp
                    ' In this procedure, the WMF image would be converted into PNG.
                    ' Relevant properties (m_bConvertToPNG and m_iCutTransOff) should be set
                    ' befroe the conversion.
                    ' If the shape contians text, the resulting WMF should not be
                    ' converted into PNG format (by setting m_bConvertToPNG as False).
                    ConvertToPNG
                End If
                bShapeIsSavedAsImage = True
            End If
        End If ' m_bShpHas3D

    End If
    
    If Not bShapeIsSavedAsImage Then
      
        ' In this If section, we determine whether the shape (with shadow)
        ' should be exported as image or not. If it should be exported as image,
        ' the image position offset should be given. If not, the shape should
        ' be converted to a set of objects (normally shape object and shadow
        ' object(s)).
        If m_bShpHasShadow Then

            ' If there is unconvertable text in the shape, the whole shape (with
            ' the text) should be exported as image. It is difficult (and
            ' unmeaningful) to convert the text and the background separately.
            Dim bSaveShapeAsImage As Boolean: bSaveShapeAsImage = False
            If (m_bShpHasText And Not m_bShpHasConvertableText) Then
                bSaveShapeAsImage = True
            End If ' (ShpHasText and not ShpHasConvertableText)

            ' Shapes with fill modes other than solid fill mode should be
            ' exported as images.
            If Not m_bShpIsSolidFilled Then
                bSaveShapeAsImage = True
            End If
            
            If shp.Shadow.Type = msoShadowMixed Or shp.Shadow.Type = msoShadow17 Then
                bSaveShapeAsImage = True
            End If
            
            If Not bSaveShapeAsImage Then
                ' Convert the shape without shadow
                ' !!!IMPORTANT!!!
                ' In this precedure, all the vertices are set at first, and
                ' saved in Me.Vert() by invoke NewSetVertices().
                ' The array Vert() should be used to find out the bounding
                ' box (dimension) of the whole shape, which is very important
                ' for the shadow conversion.
                ' So that Vert() should not be erased before shadow generating
                ' procedure finished GenerateShadowItems().
                ' PerformAutoshape shp   ' should be deprecated .
                SetShapeVertices shp
                
                If Not m_bShpIsComplex And m_bShpIsUnsupported Then
                    bSaveShapeAsImage = True
                End If
            End If
            
            If bSaveShapeAsImage Then
                ' As described before, ConvertableText, if available, will be
                ' converted to an individual (text) object.
                Dim bIsNotFilled As Boolean: bIsNotFilled = (shp.Fill.Visible = msoFalse)
                ' If there is no filling the text in PowerPoint 2007 is displayed with shadow
                If g_lApplicationVersion = 2007 And _
                   bIsNotFilled And m_bShpHasText Then
                    PerformAsImage shp
                Else
                    ImportShapeTextAsText sld, shp
                    ImportShapeBackgroundAsImage shp, bSizecalculated
                    If Not bSizecalculated Then
                        ' An core procedure of shadow conversion.
                        ' New position and size of the image should be given here.
                        SetShadowOffset shp
                        ' Same with in "3D" section.
                        ConvertToPNG
                    End If
                End If
                
                bShapeIsSavedAsImage = True
            Else
                
                ' Complex autoshapes, like: CurvedArrows (Up/Down/Left/Right),
                ' Cube, Can, FoldedCorner, Bevel, SmilyFace, Sun, etc., should
                ' be converted as group. Therefore their shadow should also be
                ' saved as a group.
                If m_bShpIsComplex Then
                    ParseComplexShapes shp
                    ' convert the text within the shape
                    If m_bShpHasConvertableText Then
                        AddGroupItem
                        With GroupItems(GroupItemNum)
                            .ImportShapeAsText sld, shp
                        End With
                     End If
                   ' Generate shadow items (in ShadowItems())
                   ' If there is shadow effect, generate the shadowItems.
                   ' Meanwhile, the ShapeType should be aofUserDefinedGroup
                    If Not m_bShpIsUnsupported Then
                        GenerateComplexShadowItems shp
                    End If
                Else    ' simple autoshapes or unsupported shapes
                    ParseSimpleShape shp
                    ' convert text within the shape
                    ImportShapeTextAsText sld, shp, paragraphDescription
                    GenerateSimpleShadowItems shp
                End If
            End If
            bShapeIsSavedAsImage = True
        End If ' ShpHasShadow
    End If
    
    If Not bShapeIsSavedAsImage Then
        ' Shapes without 3D or shadow, but with rotated text, should be
        ' converted into images.
        If m_bShpHasText And Not m_bShpHasConvertableText Then
            Dim bIsCallout As Boolean: bIsCallout = (shp.Type = msoCallout)
            ' Callouts are special, they may have accent bar, callout line.
            If bIsCallout Then
                ' An important precedure (should be revised).
                ParseCalloutAsImage sld, shp
                bShapeIsSavedAsImage = True
            End If
        End If
    End If
            
    If Not bShapeIsSavedAsImage Then
        ' Shapes without 3D or shadow, but with rotated text, should be
        ' converted into images.
        If m_bShpHasText And Not m_bShpHasConvertableText Then
            PerformAsImage shp
            bShapeIsSavedAsImage = True
        End If 'ShpHasText And Not ShpHasConvertableText
    End If

    If Not bShapeIsSavedAsImage Then
        ' Shapes without 3D or shadow, without rotated text, but with special
        ' fill mode, should be converted into images.
        '
        If Not m_bShpIsSolidFilled Then
            ' Callouts.
            bIsCallout = (shp.Type = msoCallout)
            If bIsCallout Then
                ParseCalloutAsImage sld, shp
                bShapeIsSavedAsImage = True
            End If
        End If
    End If
    
    If Not bShapeIsSavedAsImage Then
        ' Shapes without 3D or shadow, without rotated text, but with special
        ' fill mode, should be converted into images.
        '
        If Not m_bShpIsSolidFilled Then

            ' If shape contains text (ConvertalbeText), then convert the text
            ' into an individual object.
            ImportShapeTextAsText sld, shp
            ImportShapeBackgroundAsImage shp, bSizecalculated
            If Not bSizecalculated Then
                ' Set the accurate position and size of the (rotated) shape.
                ' Pay attention to the "Known bugs No.1".
                SetShapeVertices shp
                NewRotateNodes shp
                NewSetBoundingPoints
                BPoints.GetDimension x, y, width, height
                ConvertToPNG
            End If
            bShapeIsSavedAsImage = True
        End If ' Not ShpIsSolidFilled
    End If
        
    If Not bShapeIsSavedAsImage Then
        ' Shapes with special reflection should be converted into images.
        Dim bHasReflection As Boolean: bHasReflection = False
#If COMPILE_VERSION = 2007 Then
        bHasReflection = shp.Reflection.Type <> msoReflectionTypeNone
#End If
        If bHasReflection Then
            ImportShapeTextAsText sld, shp
            ImportShapeBackgroundAsImage shp, bSizecalculated
            bShapeIsSavedAsImage = True
        End If
    End If
    
    If Not bShapeIsSavedAsImage Then
        ' Shapes with softened edges should be converted into images.
        ' If the shape is a table the SoftEdge type is not correct setted.
        If shp.Type <> msoTable Then
            Dim bHasSoftEdge As Boolean: bHasSoftEdge = False
#If COMPILE_VERSION = 2007 Then
            bHasSoftEdge = shp.SoftEdge.Type <> msoSoftEdgeTypeNone
#End If
            If bHasSoftEdge Then
                ImportShapeTextAsText sld, shp
                ImportShapeBackgroundAsImage shp, bSizecalculated
                bShapeIsSavedAsImage = True
            End If
        End If
    End If


    If Not bShapeIsSavedAsImage Then
        ' Shapes with gradient lines should be converted into images.
        Dim bHasLine As Boolean: bHasLine = (shp.Line.Visible = msoTrue)
        Dim bHasNormalLineStyle As Boolean: bHasNormalLineStyle = (shp.Line.Style = msoLineSingle)
        If bHasLine And Not bHasNormalLineStyle Then
            ImportShapeTextAsText sld, shp
            ImportShapeBackgroundAsImage shp, bSizecalculated
            bShapeIsSavedAsImage = True
        End If
    End If

    ShapeHasToBeSavedAsImage = bShapeIsSavedAsImage
    
End Function

Private Sub CheckIfShapeIsSupported(shp As Shape, iSlideNumber As Long)

    If shp.Type = msoMedia Then
        If shp.MediaType = ppMediaTypeMovie Then
            SetObjectWarningMessage NOT_SUPPORTED_VIDEO, iSlideNumber
        ElseIf shp.MediaType = ppMediaTypeSound Then
            SetObjectWarningMessage NOT_SUPPORTED_AUDIO, iSlideNumber
        End If
    End If
    
    If shp.Type = msoTextBox Or shp.HasTextFrame Then
        If shp.TextFrame.TextRange.Font.Shadow = msoTrue Then
            SetObjectWarningMessage NOT_SUPPORTED_TEXTEFFECT_SHADOW, iSlideNumber
        ElseIf shp.TextFrame.TextRange.Font.Emboss = msoTrue Then
            SetObjectWarningMessage NOT_SUPPORTED_TEXTEFFECT_RELIEF, iSlideNumber
        End If
    End If
    
    If shp.Type = msoEmbeddedOLEObject Or _
       shp.Type = msoLinkedOLEObject Or _
       shp.Type = msoOLEControlObject Then
        SetObjectWarningMessage NOT_SUPPORTED_OLE, iSlideNumber
    End If
    
End Sub

Private Sub CheckAutoShapeType(shp As Shape)

    If shp.Type <> msoAutoShape Then
        m_bExportAutoformAsImage = False
        Exit Sub
    End If

    m_bExportAutoformAsImage = False
    Select Case shp.AutoShapeType
        Case msoShapeFlowchartTerminator
            m_bExportAutoformAsImage = True
        Case msoShapeSmileyFace
            m_bExportAutoformAsImage = True
        Case msoShapeCan
            m_bExportAutoformAsImage = True
        Case msoShapeHeart
            m_bExportAutoformAsImage = True
        Case msoShapeBlockArc
            m_bExportAutoformAsImage = True
        Case msoShapeDonut
            m_bExportAutoformAsImage = True
        Case msoShapeNoSymbol
            m_bExportAutoformAsImage = True
        Case msoShapeLightningBolt
            m_bExportAutoformAsImage = True
        Case msoShapeSun
            m_bExportAutoformAsImage = True
        Case msoShapeMoon
            m_bExportAutoformAsImage = True
        Case msoShapePlaque
            m_bExportAutoformAsImage = True
        Case msoShapeArc
            m_bExportAutoformAsImage = True
        Case msoShapeFlowchartAlternateProcess
            m_bExportAutoformAsImage = True
        Case msoShapeFlowchartDocument
            m_bExportAutoformAsImage = True
        Case msoShapeFlowchartMultidocument
            m_bExportAutoformAsImage = True
        Case msoShapeFlowchartTerminator
            m_bExportAutoformAsImage = True
        Case msoShapeFlowchartPunchedTape
            m_bExportAutoformAsImage = True
        Case msoShapeFlowchartSummingJunction
            m_bExportAutoformAsImage = True
        Case msoShapeFlowchartStoredData
            m_bExportAutoformAsImage = True
        Case msoShapeFlowchartDelay
            m_bExportAutoformAsImage = True
        Case msoShapeFlowchartSequentialAccessStorage
            m_bExportAutoformAsImage = True
        Case msoShapeFlowchartMagneticDisk
            m_bExportAutoformAsImage = True
        Case msoShapeFlowchartDirectAccessStorage
            m_bExportAutoformAsImage = True
        Case msoShapeFlowchartDisplay
            m_bExportAutoformAsImage = True
        Case msoShapeRoundedRectangularCallout
            m_bExportAutoformAsImage = True
        Case msoShapeOvalCallout
            m_bExportAutoformAsImage = True
        Case msoShapeCloudCallout
            m_bExportAutoformAsImage = True
        Case msoShape24pointStar
            m_bExportAutoformAsImage = True
        Case msoShape32pointStar
            m_bExportAutoformAsImage = True
        Case msoShape16pointStar
            m_bExportAutoformAsImage = True
        Case msoShapeUpRibbon
            m_bExportAutoformAsImage = True
        Case msoShapeDownRibbon
            m_bExportAutoformAsImage = True
        Case msoShapeCurvedUpRibbon
            m_bExportAutoformAsImage = True
        Case msoShapeCurvedDownRibbon
            m_bExportAutoformAsImage = True
        Case msoShapeVerticalScroll
            m_bExportAutoformAsImage = True
        Case msoShapeHorizontalScroll
            m_bExportAutoformAsImage = True
        Case msoShapeWave
            m_bExportAutoformAsImage = True
        Case msoShapeDoubleWave
            m_bExportAutoformAsImage = True
        Case msoShapeBentArrow
            m_bExportAutoformAsImage = True
        Case msoShapeUTurnArrow
            m_bExportAutoformAsImage = True
        Case msoShapeLeftUpArrow
            m_bExportAutoformAsImage = True
        Case msoShapeBentUpArrow
            m_bExportAutoformAsImage = True
        Case msoShapeCurvedRightArrow
            m_bExportAutoformAsImage = True
        Case msoShapeCurvedLeftArrow
            m_bExportAutoformAsImage = True
        Case msoShapeCurvedUpArrow
            m_bExportAutoformAsImage = True
        Case msoShapeCurvedDownArrow
            m_bExportAutoformAsImage = True
        Case msoShapeCircularArrow
            m_bExportAutoformAsImage = True
        Case msoShapeQuadArrowCallout
            m_bExportAutoformAsImage = True
    End Select
End Sub

Private Function CreateImagePrefix() As String

    CreateImagePrefix = g_conversionOptions.ImgFileNamePrefix & "_s" & g_lCurrentPageNumber & _
                                                                "p" & m_lImageId
        
End Function

'
' Clone
'

Private Sub CloneTextRangeSetting(TarTr As TextRange, SrcTr As TextRange)

    Dim tmpPara As ParagraphFormat
    Dim tmpFont As Font

    Set tmpPara = SrcTr.ParagraphFormat
    Set tmpFont = SrcTr.Font

    On Error Resume Next

    With TarTr.ParagraphFormat
        .TextDirection = tmpPara.TextDirection
        .BaseLineAlignment = tmpPara.BaseLineAlignment
        .FarEastLineBreakControl = tmpPara.FarEastLineBreakControl
        .HangingPunctuation = tmpPara.HangingPunctuation
        .LineRuleAfter = tmpPara.LineRuleAfter
        .LineRuleBefore = tmpPara.LineRuleBefore
        .LineRuleWithin = tmpPara.LineRuleWithin
        .SpaceAfter = tmpPara.SpaceAfter
        .SpaceBefore = tmpPara.SpaceBefore
        .SpaceWithin = tmpPara.SpaceWithin
        .WordWrap = tmpPara.WordWrap
        .Alignment = tmpPara.Alignment
        .Bullet.Visible = tmpPara.Bullet.Visible
    End With

    With TarTr.Font
        .AutoRotateNumbers = tmpFont.AutoRotateNumbers  'XP?
        .BaselineOffset = tmpFont.BaselineOffset
        .Bold = tmpFont.Bold
        .color.RGB = tmpFont.color.RGB
        .Italic = tmpFont.Italic
        .Name = tmpFont.Name
        .NameAscii = tmpFont.NameAscii
        ' exception may be thrown from here
        .NameComplexScript = tmpFont.NameComplexScript
        .NameFarEast = tmpFont.NameFarEast
        .NameOther = tmpFont.NameOther

        .Size = tmpFont.Size
        .Subscript = tmpFont.Subscript
        .Superscript = tmpFont.Superscript
        .Underline = tmpFont.Underline
    End With
    
    On Error GoTo 0
    
End Sub

#If COMPILE_VERSION = 2007 Then

Private Sub CloneTextRange2Setting(TarTr As TextRange2, SrcTr As TextRange2)

    Dim tmpPara As ParagraphFormat2
    Dim tmpFont As Font2

    Set tmpPara = SrcTr.ParagraphFormat
    Set tmpFont = SrcTr.Font

    On Error Resume Next

    With TarTr.ParagraphFormat
        .TextDirection = tmpPara.TextDirection
        .BaseLineAlignment = tmpPara.BaseLineAlignment
        .HangingPunctuation = tmpPara.HangingPunctuation
        .LineRuleAfter = tmpPara.LineRuleAfter
        .LineRuleBefore = tmpPara.LineRuleBefore
        .LineRuleWithin = tmpPara.LineRuleWithin
        .SpaceAfter = tmpPara.SpaceAfter
        .SpaceBefore = tmpPara.SpaceBefore
        .SpaceWithin = tmpPara.SpaceWithin
        .WordWrap = tmpPara.WordWrap
        .Alignment = tmpPara.Alignment
        .Bullet.Visible = tmpPara.Bullet.Visible
    End With

    With TarTr.Font
        .AutoRotateNumbers = tmpFont.AutoRotateNumbers  'XP?
        .BaselineOffset = tmpFont.BaselineOffset
        .Bold = tmpFont.Bold
        .Caps = tmpFont.Caps
        .DoubleStrikeThrough = tmpFont.DoubleStrikeThrough
        .Equalize = tmpFont.Equalize
        CloneFill .Fill, tmpFont.Fill
        .Glow = tmpFont.Glow
        .Highlight = tmpFont.Highlight
        .Italic = tmpFont.Italic
        .Kerning = tmpFont.Kerning
        CloneLine .Line, tmpFont.Line
        .Name = tmpFont.Name
        .NameAscii = tmpFont.NameAscii
        ' exception may be thrown from here
        .NameComplexScript = tmpFont.NameComplexScript
        .NameFarEast = tmpFont.NameFarEast
        .NameOther = tmpFont.NameOther
        .Reflection = tmpFont.Reflection
        
        'CloneShadow .Shadow tmpFont.Shadow
        
        .Size = tmpFont.Size
        .Smallcaps = tmpFont.Smallcaps
        .SoftEdgeFormat = tmpFont.SoftEdgeFormat
        .Spacing = tmpFont.Spacing
        .Strike = tmpFont.Strike
        .Strikethrough = tmpFont.Strikethrough
        .Subscript = tmpFont.Subscript
        .Superscript = tmpFont.Superscript
        .UnderlineColor = tmpFont.UnderlineColor
        .UnderlineStyle = tmpFont.UnderlineStyle
        .WordArtFormat = tmpFont.WordArtFormat
    End With
    
    On Error GoTo 0
    
End Sub

#End If

Private Sub CloneTextFrame(tarShape As Shape, srcShape As Shape)

    On Error Resume Next
    
    With tarShape
        ' clone the properties
        .TextFrame.AutoSize = srcShape.TextFrame.AutoSize
        .TextFrame.MarginBottom = srcShape.TextFrame.MarginBottom
        .TextFrame.MarginLeft = srcShape.TextFrame.MarginLeft
        .TextFrame.MarginRight = srcShape.TextFrame.MarginRight
        .TextFrame.MarginTop = srcShape.TextFrame.MarginTop
        .TextFrame.Orientation = srcShape.TextFrame.Orientation
        .TextFrame.HorizontalAnchor = srcShape.TextFrame.HorizontalAnchor
        .TextFrame.VerticalAnchor = srcShape.TextFrame.VerticalAnchor
        .TextFrame.WordWrap = srcShape.TextFrame.WordWrap

        ' clone the Ruler (object)
        ' CloneRuler .TextFrame.Ruler, srcShape.TextFrame.Ruler
    End With

    CloneFill tarShape.Fill, srcShape.Fill
    CloneLine tarShape.Line, srcShape.Line
    
    On Error GoTo 0
    
End Sub

Private Sub CloneRuler(TarRl As Ruler, SrcRl As Ruler)

    On Error Resume Next
    
    Dim i As Long
    With TarRl
        For i = 1 To TarRl.Levels.Count
            .Levels(i).firstMargin = SrcRl.Levels(i).firstMargin
            .Levels(i).leftMargin = SrcRl.Levels(i).leftMargin
        Next

        ' clear the TabStops list
        For i = .TabStops.Count To 1 Step -1
            .TabStops(i).Clear
        Next

        ' clone the properties (only one property here)
        .TabStops.DefaultSpacing = SrcRl.TabStops.DefaultSpacing

        For i = 1 To SrcRl.TabStops.Count
            .TabStops.Add i, SrcRl.TabStops(i)
        Next
    End With
    
    On Error GoTo 0
    
End Sub

Private Sub CloneFill(tarFill As FillFormat, srcFill As FillFormat)

    If srcFill.Visible Then
        tarFill.Visible = msoTrue
        tarFill.BackColor = srcFill.BackColor
        tarFill.ForeColor = srcFill.ForeColor
        tarFill.transparency = srcFill.transparency
        If g_lApplicationVersion = 2007 Then
#If COMPILE_VERSION = 2007 Then
            tarFill.TextureAlignment = srcFill.TextureAlignment
            tarFill.RotateWithObject = srcFill.RotateWithObject
#End If
        End If
    Else
        tarFill.Visible = msoFalse
    End If

End Sub

Private Sub CloneLine(tarLine As LineFormat, srcLine As LineFormat)

    If srcLine.Visible Then
        tarLine.Visible = msoTrue
        tarLine.BackColor = srcLine.BackColor
        tarLine.DashStyle = srcLine.DashStyle
        tarLine.ForeColor = srcLine.ForeColor
        tarLine.Style = srcLine.Style
        tarLine.transparency = srcLine.transparency
        tarLine.Weight = srcLine.Weight
    Else
        tarLine.Visible = msoFalse
    End If
    
End Sub

'Private Sub CloneShadow(tarShadow As Shadow, srcShadow As Shadow)
'
'    If tarShadow. Then
'        tarLine.Visible = msoTrue
'        tarLine.BackColor = srcLine.BackColor
'        tarLine.DashStyle = srcLine.DashStyle
'        tarLine.ForeColor = srcLine.ForeColor
'        tarLine.Style = srcLine.Style
'        tarLine.transparency = srcLine.transparency
'        tarLine.Weight = srcLine.Weight
'    Else
'        tarLine.Visible = msoFalse
'    End If
'
'End Sub

'
' Groups
'

Private Sub AddGroupItem()
    If HasGroupItem Then
        GroupItemNum = GroupItemNum + 1
    Else
        GroupItemNum = 1
        HasGroupItem = True
    End If

    ReDim Preserve GroupItems(1 To GroupItemNum) As aofShape
    Set GroupItems(GroupItemNum) = New aofShape
    AddHyperlink GroupItems(GroupItemNum)
End Sub

'
' Hyperlinks
'

Private Sub AddHyperlink(shp As aofShape)

    If HypertextAddress <> "" Or InternLink <> "" Or ObjectLinkIds <> "" Then
        shp.HypertextAddress = HypertextAddress
        shp.InternLink = InternLink
        shp.CurrentDirectory = CurrentDirectory
        shp.ObjectLinkIds = ObjectLinkIds
        shp.ObjectId = ObjectId
    End If
    
End Sub

Private Sub AddHyperlinkToText(shp As aofTextItem)

    If HypertextAddress <> "" Or InternLink <> "" Or ObjectLinkIds <> "" Then
        shp.HypertextAddress = HypertextAddress
        shp.InternLink = InternLink
        shp.CurrentDirectory = CurrentDirectory
        shp.ObjectLinkIds = ObjectLinkIds
        shp.ObjectId = ObjectId
    End If
    
End Sub

Private Sub SearchForHyperlink(shp As Shape)
    If shp.ActionSettings.Count >= ppMouseClick Then
        If shp.ActionSettings.Item(ppMouseClick).Action <> ppActionNone Then
            If shp.ActionSettings.Item(ppMouseClick).Action = ppActionFirstSlide Then
                InternLink = "FIRST"
            ElseIf shp.ActionSettings.Item(ppMouseClick).Action = ppActionLastSlide Then
                InternLink = "LAST"
            ElseIf shp.ActionSettings.Item(ppMouseClick).Action = ppActionNextSlide Then
                InternLink = "NEXT"
            ElseIf shp.ActionSettings.Item(ppMouseClick).Action = ppActionPreviousSlide Then
                InternLink = "PREV"
            ElseIf shp.ActionSettings.Item(ppMouseClick).Action = ppActionRunProgram Then
                HypertextAddress = ReplaceBackslash(shp.ActionSettings.Item(ppMouseClick).Run)
                CurrentDirectory = ""
            ElseIf shp.ActionSettings.Item(ppMouseClick).Action = ppActionHyperlink Then
                If shp.ActionSettings.Item(ppMouseClick).Hyperlink.address <> "" Then
                    HypertextAddress = ReplaceBackslash(shp.ActionSettings.Item(ppMouseClick).Hyperlink.address)
                    CurrentDirectory = ReplaceBackslash(ActivePresentation.path)
                ElseIf shp.ActionSettings.Item(ppMouseClick).Hyperlink.SubAddress <> "" Then
                    InternLink = ExtractSlideID(shp.ActionSettings.Item(ppMouseClick).Hyperlink.SubAddress)
                End If
            End If
            'ElseIf shp.ActionSettings.Item(ppMouseClick).Action = ppActionEndShow Then
            '    InternLink = "EXIT"
            'ElseIf shp.ActionSettings.Item(ppMouseClick).Action = ppActionLastSlideViewed Then
            '    InternLink = "LASTVIEWED"
            'ElseIf shp.ActionSettings.Item(ppMouseClick).Action = ppActionOLEVerb Then
            'ElseIf shp.ActionSettings.Item(ppMouseClick).Action = ppActionPlay Then
            'ElseIf shp.ActionSettings.Item(ppMouseClick).Action = ppActionRunMacro Then
        End If
    End If
End Sub

Public Function MakeHypertextString(ByVal address As String, ByVal intern As String, ByVal path As String, ByVal ObjectIds As String, ByVal ObjectId As Long) As String

    Dim tmpString As String
    
    tmpString = ""
    If address <> "" Then
        tmpString = tmpString & """ address=""" & address
    End If
    
    If intern <> "" Then
        tmpString = tmpString & """ intern=""" & intern
    End If
    
    If path <> "" Then
        tmpString = tmpString & """ path=""" & path
    End If

    If ObjectIds <> "" Then
        tmpString = tmpString & """ linkedObjects=""" & ObjectIds
        If ObjectId > 0 Then
            tmpString = tmpString & """ id=""" & ObjectId
        End If
    End If
    
    
    MakeHypertextString = tmpString
    
End Function


'
' Callouts
'

Private Sub SetCalloutOffset(shp As Shape)
    Dim ratio1 As Single
    Dim ratio2 As Single
    Dim l As Single
    Dim r As Single
    Dim t As Single
    Dim b As Single

    With shp
        On Error Resume Next
        l = .Left
        t = .Top
        r = .Left + .width
        b = .Top + .height

        ratio1 = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio1 = 0.0625
            Err.Clear
        End If
        ratio2 = .Adjustments(2)
        If Err.Number <> 0 Then
            ratio2 = 1.2
        End If
        On Error GoTo 0

        If ratio1 < 0 Then
            l = .Left + .width * ratio1
        ElseIf ratio1 > 1 Then
            r = .Left + .width * ratio1
        End If

        If ratio2 < 0 Then
            t = .Top + .height * ratio2
        ElseIf ratio2 > 1 Then
            b = .Top + .height * ratio2
        End If

    End With

    x = l
    y = t
    width = r - l
    height = b - t
End Sub

Private Sub SetVertOfCalloutThree(shp As Shape, ByRef hasAccent As Boolean)
    Dim ratio1  As Single
    Dim ratio2  As Single
    Dim ratio3  As Single
    Dim ratio4  As Single
    Dim ratio5  As Single
    Dim ratio6  As Single

    If shp.Callout.Accent = msoTrue Then
        hasAccent = True
'        GroupItemNum = 4
        VertNum = 5
    Else
        hasAccent = False
'        GroupItemNum = 3
        VertNum = 3
    End If

    ReDim Vert(1 To VertNum) As aofNode

    With shp
        On Error Resume Next
        ratio1 = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio1 = -2
            Err.Clear
        End If
        ratio2 = .Adjustments(2)
        If Err.Number <> 0 Then
            ratio2 = -2
            Err.Clear
        End If
        ratio3 = .Adjustments(3)
        If Err.Number <> 0 Then
            ratio3 = -1
            Err.Clear
        End If
        ratio4 = .Adjustments(4)
        If Err.Number <> 0 Then
            ratio4 = 9 / .height
            Err.Clear
        End If
        ratio5 = .Adjustments(5)
        If Err.Number <> 0 Then
            ratio5 = -0.08333334
            Err.Clear
        End If
        ratio6 = .Adjustments(6)
        If Err.Number <> 0 Then
            ratio6 = ratio4
        End If
        
        If g_lApplicationVersion = 2007 Then
            Vert(1).x = .Left + .width * ratio2
            Vert(1).y = .Top + .height * ratio1
    
            Vert(2).x = .Left + .width * ratio4
            Vert(2).y = .Top + .height * ratio3
    
            Vert(3).x = .Left + .width * ratio6
            Vert(3).y = .Top + .height * ratio5
        Else
            Vert(1).x = .Left + .width * ratio1
            Vert(1).y = .Top + .height * ratio2
    
            Vert(2).x = .Left + .width * ratio3
            Vert(2).y = .Top + .height * ratio4
    
            Vert(3).x = .Left + .width * ratio5
            Vert(3).y = .Top + .height * ratio6
        End If

        If .Callout.Accent = msoTrue Then
                Vert(4).x = Vert(1).x
                Vert(5).x = Vert(1).x
            Else
                Vert(4).x = Vert(3).x
                Vert(5).x = Vert(3).x
            Vert(4).y = .Top
            Vert(5).y = .Top + .height
        End If
    End With
End Sub


' if the callout is not solid filled, then the text box
' should be exported as image, and the callout lines would
' be converted to lines.
Private Sub ParseCalloutAsImage(sld As Slide, shp As Shape)
    ' duplicate a gourp
    Dim tmpShp As Shape

    PerformCallout sld, shp

    Set tmpShp = shp.Duplicate(1)
    
    With tmpShp
        .Top = shp.Top
        .Left = shp.Left
        .AutoShapeType = msoShapeRectangle
        .Line.Visible = shp.Callout.Border
    End With
    
    Set GroupItems(GroupItemNum) = Nothing
    Set GroupItems(GroupItemNum) = New aofShape    ' rebuild the text box
    AddHyperlink GroupItems(GroupItemNum)
    GroupItems(GroupItemNum).Perform sld, tmpShp

    tmpShp.Delete
    Set tmpShp = Nothing

End Sub

Private Sub ParseCalloutOne(sld As Slide, shp As Shape)
    ParseCalloutTwo sld, shp
End Sub

Private Sub SetVertOfCalloutTwo(shp As Shape, ByRef hasAccent As Boolean)
    Dim ratio1  As Single
    Dim ratio2  As Single
    Dim ratio3  As Single
    Dim ratio4  As Single

    Dim bIsAccentCallout As Boolean: bIsAccentCallout = False
    With shp.Callout
        If g_lApplicationVersion = 2007 Then
            If .Type = msoCalloutOne And .Accent = msoTrue Then
                bIsAccentCallout = True
            End If
        Else
            If .Type = msoCalloutTwo And .Accent = msoTrue Then
                bIsAccentCallout = True
            End If
        End If
    End With
    
    If bIsAccentCallout Then
        hasAccent = True
'        GroupItemNum = 3
        VertNum = 4
    Else
        hasAccent = False
'        GroupItemNum = 2
        VertNum = 2
    End If

    ReDim Vert(1 To VertNum) As aofNode

    With shp
        On Error Resume Next
        ratio1 = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio1 = -1
            Err.Clear
        End If
        ratio2 = .Adjustments(2)
        If Err.Number <> 0 Then
            ratio2 = -0.08333334
            Err.Clear
        End If
        ratio3 = .Adjustments(3)
        If Err.Number <> 0 Then
            ratio3 = -1
            Err.Clear
        End If
        ratio4 = .Adjustments(4)
        If Err.Number <> 0 Then
            ratio4 = -0.08333334
            Err.Clear
        End If

        If g_lApplicationVersion = 2007 Then
            Vert(1).x = .Left + .width * ratio2
            Vert(1).y = .Top + .height * ratio1
        
            Vert(2).x = .Left + .width * ratio4
            Vert(2).y = .Top + .height * ratio3
        Else
            Vert(1).x = .Left + .width * ratio1
            Vert(1).y = .Top + .height * ratio2

            Vert(2).x = .Left + .width * ratio3
            Vert(2).y = .Top + .height * ratio4
        End If
      
        If hasAccent Then
            If Vert(2).x < .Left Or Vert(2).x > .Left + .width Then
                ' accent is vertical
                If g_lApplicationVersion = 2007 Then
                    Vert(3).x = Vert(1).x
                    Vert(4).x = Vert(1).x
                Else
                    Vert(3).x = Vert(2).x
                    Vert(4).x = Vert(2).x
                End If
                Vert(3).y = .Top
                Vert(4).y = .Top + .height
            ElseIf Vert(2).y < .Top Or Vert(2).y > .Top + .height Then
                Vert(3).x = .Left
                Vert(4).x = .Left + .width
                Vert(3).y = Vert(2).y
                Vert(4).y = Vert(2).y
            End If
        End If
    End With
End Sub

Private Sub ParseCalloutTwo(sld As Slide, shp As Shape)
    Dim arrh    As Boolean
    Dim arre    As Boolean
    Dim hasAccent As Boolean

    m_lecShapeType = LEC_SHAPETYPE_USERDEFINEDGROUP

    HasGroupItem = True

    SetVertOfCalloutTwo shp, hasAccent

    If hasAccent Then
        GroupItemNum = 3
    Else
        GroupItemNum = 2
    End If

    ReDim GroupItems(1 To GroupItemNum) As aofShape


    FlipNodes Vert, VertNum, shp
    NodesRotate shp.Rotation

    If shp.Line.BeginArrowheadStyle <> msoArrowheadNone Then
        arrh = True
    End If
    If shp.Line.EndArrowheadStyle <> msoArrowheadNone Then
        arre = True
    End If

    'point line
    Set GroupItems(1) = New aofShape
    AddHyperlink GroupItems(1)
    With GroupItems(1)
        .SetShapeType (LEC_SHAPETYPE_LINE)
        .SetLineAttributes shp
        .SetVerts Vert, 1, 2
        .BuildLineWithVert arrh, arre
    End With

    ' text box
    ' accent
    If hasAccent Then
        Set GroupItems(2) = New aofShape
        AddHyperlink GroupItems(2)
        With GroupItems(2)
            .SetShapeType (LEC_SHAPETYPE_LINE)
            .SetLineAttributes shp
            .arrowStyle = "none"        ' no arrow
            .SetVerts Vert, 3, 2
            .BuildLineWithVert arrh, arre
        End With
    End If

    Set GroupItems(GroupItemNum) = New aofShape
    AddHyperlink GroupItems(GroupItemNum)
    With GroupItems(GroupItemNum)
        .ImportShapeAsFourPointsRect shp

        If shp.Callout.Border = msoTrue Then
            If .m_lecDrawStyle = LEC_DRAWSTYLE_NONE Or .m_lecDrawStyle = LEC_DRAWSTYLE_FILLED Then
                .m_lecDrawStyle = LEC_DRAWSTYLE_OUTLINE + .m_lecDrawStyle
            End If
        ElseIf shp.Callout.Border = msoFalse Then
            If .m_lecDrawStyle = LEC_DRAWSTYLE_OUTLINE Or .m_lecDrawStyle = LEC_DRAWSTYLE_FILLEDOUTLINE Then
                .m_lecDrawStyle = .m_lecDrawStyle - LEC_DRAWSTYLE_OUTLINE
            End If
        End If

        If HasTextInShape(shp) Then
            .ContainText = True
            Set .TextInShape = New aofShape
            AddHyperlink .TextInShape
            .TextInShape.ImportShapeAsText sld, shp
        End If
    End With


End Sub

' a callout object in mlb is presented as a group
' there are 3 or 4 shapes in the group
' 1st:  line
' 2nd:  line
' 3rd:  if with Accent, line
'       with out Accent, Autoshape (normally Rect)
' 4th:  only when with Accent, Autoshape (normally Rect)
Private Sub ParseCalloutThree(sld As Slide, shp As Shape)
    Dim arrh    As Boolean
    Dim arre    As Boolean
    Dim hasAccent As Boolean

    m_lecShapeType = LEC_SHAPETYPE_USERDEFINEDGROUP
    HasGroupItem = True

    SetVertOfCalloutThree shp, hasAccent

    If hasAccent Then
        GroupItemNum = 4
    Else
        GroupItemNum = 3
    End If

    ReDim GroupItems(1 To GroupItemNum) As aofShape


    FlipNodes Vert, VertNum, shp
    NodesRotate shp.Rotation

    ' the arrow setting of the callout
    If shp.Line.BeginArrowheadStyle <> msoArrowheadNone Then
        arrh = True
    End If
    If shp.Line.EndArrowheadStyle <> msoArrowheadNone Then
        arre = True
    End If

    Set GroupItems(1) = New aofShape
    AddHyperlink GroupItems(1)
    With GroupItems(1)
        .SetShapeType (LEC_SHAPETYPE_LINE)
        .SetLineAttributes shp
        .SetVerts Vert, 1, 2
        .BuildLineWithVert arrh, False
    End With

    Set GroupItems(2) = New aofShape
    AddHyperlink GroupItems(2)
    With GroupItems(2)
        .SetShapeType (LEC_SHAPETYPE_LINE)
        .SetLineAttributes shp
        .SetVerts Vert, 2, 2
        .BuildLineWithVert False, arre
    End With

    If hasAccent Then
        Set GroupItems(3) = New aofShape
        AddHyperlink GroupItems(3)
        With GroupItems(3)
            .SetShapeType (LEC_SHAPETYPE_LINE)
            .SetLineAttributes shp
            .arrowStyle = "none"
            .SetVerts Vert, 4, 2
            .BuildLineWithVert False, arre
        End With
    End If

    Set GroupItems(GroupItemNum) = New aofShape
    AddHyperlink GroupItems(GroupItemNum)
    With GroupItems(GroupItemNum)
        .ImportShapeAsFourPointsRect shp

        If shp.Callout.Border = msoTrue Then
            If .m_lecDrawStyle = LEC_DRAWSTYLE_NONE Or .m_lecDrawStyle = LEC_DRAWSTYLE_FILLED Then
                .m_lecDrawStyle = LEC_DRAWSTYLE_OUTLINE + .m_lecDrawStyle
            End If
        ElseIf shp.Callout.Border = msoFalse Then
            If .m_lecDrawStyle = LEC_DRAWSTYLE_OUTLINE Or .m_lecDrawStyle = LEC_DRAWSTYLE_FILLEDOUTLINE Then
                .m_lecDrawStyle = .m_lecDrawStyle - LEC_DRAWSTYLE_OUTLINE
            End If
        End If

        If HasTextInShape(shp) Then
            .ContainText = True
            Set .TextInShape = New aofShape
            AddHyperlink .TextInShape
            .TextInShape.ImportShapeAsText sld, shp
        End If
    End With


End Sub

Private Sub SetVertOfCalloutFour(shp As Shape, ByRef hasAccent As Boolean)
    Dim ratio1  As Single
    Dim ratio2  As Single
    Dim ratio3  As Single
    Dim ratio4  As Single
    Dim ratio5  As Single
    Dim ratio6  As Single
    Dim ratio7  As Single
    Dim ratio8  As Single

    If shp.Callout.Accent = msoTrue Then
        hasAccent = True
'        GroupItemNum = 5
        VertNum = 6
    Else
        hasAccent = False
'        GroupItemNum = 4
        VertNum = 4
    End If

    ReDim Vert(1 To VertNum) As aofNode

    With shp
        On Error Resume Next
        ratio1 = .Adjustments(1)
        If Err.Number <> 0 Then
            ratio1 = -3
            Err.Clear
        End If
        ratio2 = .Adjustments(2)
        If Err.Number <> 0 Then
            ratio2 = -4
            Err.Clear
        End If
        ratio3 = .Adjustments(3)
        If Err.Number <> 0 Then
            ratio3 = 3
            Err.Clear
        End If
        ratio4 = .Adjustments(4)
        If Err.Number <> 0 Then
            ratio4 = -2
            Err.Clear
        End If
        ratio5 = .Adjustments(5)
        If Err.Number <> 0 Then
            ratio5 = ratio3
            Err.Clear
        End If
        ratio6 = .Adjustments(6)
        If Err.Number <> 0 Then
            ratio6 = 9 / .height
        End If

        ratio7 = .Adjustments(7)
        If Err.Number <> 0 Then
            ratio7 = 6 / .width
            Err.Clear
        End If
        ratio8 = .Adjustments(8)
        If Err.Number <> 0 Then
            ratio8 = ratio6
        End If

        If g_lApplicationVersion = 2007 Then
            Vert(1).x = .Left + .width * ratio2
            Vert(1).y = .Top + .height * ratio1
    
            Vert(2).x = .Left + .width * ratio4
            Vert(2).y = .Top + .height * ratio3
    
            Vert(3).x = .Left + .width * ratio6
            Vert(3).y = .Top + .height * ratio5
    
            Vert(3).x = .Left + .width * ratio6
            Vert(3).y = .Top + .height * ratio5
    
            Vert(4).x = .Left + .width * ratio8
            Vert(4).y = .Top + .height * ratio7
        Else
            Vert(1).x = .Left + .width * ratio1
            Vert(1).y = .Top + .height * ratio2
    
            Vert(2).x = .Left + .width * ratio3
            Vert(2).y = .Top + .height * ratio4
    
            Vert(3).x = .Left + .width * ratio5
            Vert(3).y = .Top + .height * ratio6
    
            Vert(3).x = .Left + .width * ratio5
            Vert(3).y = .Top + .height * ratio6
    
            Vert(4).x = .Left + .width * ratio7
            Vert(4).y = .Top + .height * ratio8
        End If
        
        If .Callout.Accent = msoTrue Then
            If g_lApplicationVersion = 2007 Then
                Vert(5).x = Vert(1).x
                Vert(6).x = Vert(1).x
            Else
                Vert(5).x = Vert(4).x
                Vert(6).x = Vert(4).x
            End If
            Vert(5).y = .Top
            Vert(6).y = .Top + .height
        End If
    End With
End Sub

Private Sub ParseCalloutFour(sld As Slide, shp As Shape)
    Dim arrh    As Boolean
    Dim arre    As Boolean
    Dim hasAccent As Boolean


    m_lecShapeType = LEC_SHAPETYPE_USERDEFINEDGROUP
    HasGroupItem = True

    SetVertOfCalloutFour shp, hasAccent

    If hasAccent Then
        GroupItemNum = 5
    Else
        GroupItemNum = 4
    End If

    ReDim GroupItems(1 To GroupItemNum) As aofShape

    FlipNodes Vert, VertNum, shp
    NodesRotate shp.Rotation

    If shp.Line.BeginArrowheadStyle <> msoArrowheadNone Then
        arrh = True
    End If
    If shp.Line.EndArrowheadStyle <> msoArrowheadNone Then
        arre = True
    End If

    Set GroupItems(1) = New aofShape
    AddHyperlink GroupItems(1)
    With GroupItems(1)
        .SetShapeType (LEC_SHAPETYPE_LINE)
        .SetLineAttributes shp
        .SetVerts Vert, 1, 2
        .BuildLineWithVert arrh, False
    End With

    Set GroupItems(2) = New aofShape
    AddHyperlink GroupItems(2)
    With GroupItems(2)
        .SetShapeType (LEC_SHAPETYPE_LINE)
        .SetLineAttributes shp
        .SetVerts Vert, 2, 2
        .BuildLineWithVert False, False
    End With

    Set GroupItems(3) = New aofShape
    AddHyperlink GroupItems(3)
    With GroupItems(3)
        .SetShapeType (LEC_SHAPETYPE_LINE)
        .SetLineAttributes shp
        .SetVerts Vert, 3, 2
        .BuildLineWithVert False, arre
    End With

    If hasAccent Then
        Set GroupItems(4) = New aofShape
        AddHyperlink GroupItems(4)
        With GroupItems(4)
            .SetShapeType (LEC_SHAPETYPE_LINE)
            .SetLineAttributes shp
            .SetVerts Vert, 5, 2
            .BuildLineWithVert False, arre
        End With
    End If

    Set GroupItems(GroupItemNum) = New aofShape
    AddHyperlink GroupItems(GroupItemNum)
    With GroupItems(GroupItemNum)
        .ImportShapeAsFourPointsRect shp

        If shp.Callout.Border = msoTrue Then
            If .m_lecDrawStyle = LEC_DRAWSTYLE_NONE Or .m_lecDrawStyle = LEC_DRAWSTYLE_FILLED Then
                .m_lecDrawStyle = LEC_DRAWSTYLE_OUTLINE + .m_lecDrawStyle
            End If
        ElseIf shp.Callout.Border = msoFalse Then
            If .m_lecDrawStyle = LEC_DRAWSTYLE_OUTLINE Or .m_lecDrawStyle = LEC_DRAWSTYLE_FILLEDOUTLINE Then
                .m_lecDrawStyle = .m_lecDrawStyle - LEC_DRAWSTYLE_OUTLINE
            End If
        End If

        If HasTextInShape(shp) Then
            .ContainText = True
            Set .TextInShape = New aofShape
            AddHyperlink .TextInShape
            .TextInShape.ImportShapeAsText sld, shp
        End If
    End With


End Sub


'
' Bezier
'

' insert the point list into a Bezier curve segment
'
' args:     sgPoint()             - 4 control points of a Bezier curve segment
'           lgNumOfInsertedPoints - byRef, return the number of generated points
' return:   AOFwb script of point list
Private Function InsertBezierPoints(sgPoint() As WBPoint, lgNumOfInsertedPoints As Long) As String
    Dim strScript           As String
    Dim nPointNum           As Long
    Dim i                   As Long
    Dim bzrPnts()           As WBPoint

    strScript = ""
    ' POINTDIST is the distance between two points
    ' POINTDIST = 2
    nPointNum = BzrPntNum(sgPoint, POINTDIST)
    ReDim bzrPnts(0 To nPointNum + 1) As WBPoint

    Call GenBzrPnts(sgPoint, bzrPnts, nPointNum)

    lgNumOfInsertedPoints = nPointNum + 1

    For i = 0 To nPointNum
'        strScript = strScript & vbLf & "<pt x=" & CLng(bzrPnts(i).x) _
'                    & " y=" & CLng(bzrPnts(i).y) & "></pt>"
        strScript = strScript & "{" & CLng(bzrPnts(i).x) _
                    & " " & CLng(bzrPnts(i).y) & "} "

        BPoints.Add CLng(bzrPnts(i).x), CLng(bzrPnts(i).y)

    Next
    InsertBezierPoints = strScript
End Function

' inner function to generate Bezier curve
'
' return: the number of the points in one Bezier curve segment
Private Function BzrPntNum(p() As WBPoint, nPntDist As Long) As Long
        Dim maxx, maxy, minx, miny As Double
        Dim i As Long

        maxx = p(0).x: minx = p(0).x
        maxy = p(0).y: miny = p(0).y
        For i = 1 To 3
            If maxx < p(i).x Then
                maxx = p(i).x
            End If
            If maxy < p(i).y Then
                maxy = p(i).y
            End If
            If minx > p(i).x Then
                minx = p(i).x
            End If
            If miny > p(i).y Then
                miny = p(i).y
            End If
        Next
        maxx = maxx - minx: maxy = maxy - miny

        If maxx < maxy Then
            maxx = maxy
        End If
        BzrPntNum = maxx / nPntDist

End Function

' inner sub to generate Bezier curve
Private Sub GenBzrPnts(sgPoint() As WBPoint, bzrPnts() As WBPoint, pntNum As Long)
    'Dim MaxCtlPoints       As Long
    Dim u                  As Double
    Dim k                  As Long
    Dim pt                 As WBPoint

    'MaxCtlPoints = 12

    Dim bc(0 To MAXCTLPOINTS - 1)   As WBPoint

    Call BzrForm(4, sgPoint, bc)

    For k = 0 To pntNum
       pt = BzrCurve(4, bc, CDbl(k) / CDbl(pntNum))
       bzrPnts(k).x = pt.x
       bzrPnts(k).y = pt.y
    Next

End Sub

' inner sub to generate Bezier curve
Private Sub BzrForm(NumCtlPoints As Long, p() As WBPoint, c() As WBPoint)
    Dim k               As Long
    Dim n               As Double
    Dim choose          As Double

    n = NumCtlPoints - 1
    For k = 0 To n
        If k = 0 Then
            choose = 1
        ElseIf k = 1 Then
            choose = n
        Else
            choose = choose * (n - k + 1) / k
        End If

        c(k).x = p(k).x * choose
        c(k).y = p(k).y * choose
     Next

End Sub
Private Function BzrCurve(NumCtlPoints As Long, c() As WBPoint, t As Double) As WBPoint
    Dim k           As Long
    Dim n           As Long
    Dim t1, tt, u   As Double
    Dim pt          As WBPoint
    Dim b(0 To MAXCTLPOINTS - 1) As WBPoint

    n = NumCtlPoints - 1: u = t
    b(0).x = c(0).x
    b(0).y = c(0).y
    For k = 1 To n
        b(k).x = c(k).x * u
        b(k).y = c(k).y * u
        u = u * t
    Next

    pt.x = b(n).x:    pt.y = b(n).y
    t1 = 1 - t:         tt = t1

    k = n - 1
    Do While k >= 0
        pt.x = pt.x + b(k).x * tt
        pt.y = pt.y + b(k).y * tt
        tt = tt * t1
        k = k - 1
    Loop
    BzrCurve = pt

End Function

Private Sub lerp(dest As aofNode, A As aofNode, b As aofNode, t As Double)
  dest.x = A.x + (b.x - A.x) * t
  dest.y = A.y + (b.y - A.y) * t
End Sub

Private Sub bezier(dest As aofNode, t As Double, A As aofNode, b As aofNode, c As aofNode, d As aofNode)
  Dim ab As aofNode, bc As aofNode, cd As aofNode, abbc As aofNode, bccd As aofNode

  Call lerp(ab, A, b, t)          ' point between a and b
  Call lerp(bc, b, c, t)          ' point between b and c
  Call lerp(cd, c, d, t)          ' point between c and d
  Call lerp(abbc, ab, bc, t)      ' point between ab and bc
  Call lerp(bccd, bc, cd, t)      ' point between bc and cd
  Call lerp(dest, abbc, bccd, t)  ' point on the bezier-curve
End Sub

'
' Write to Source document
'
Public Function ScriptTextShadow() As String
    Dim strScript As String
    Dim rStr        As String
    Dim i As Long

    If HasGroupItem Then
        For i = 1 To GroupItemNum
            strScript = strScript & GroupItems(i).ScriptTextShadow()
        Next
        ScriptTextShadow = strScript
        Exit Function
    End If

    If HasTextShadow Then
'        IncIndent
        If Not g_conversionOptions.NoGroup And TextItemNum > 1 Then
            strScript = NewLine() & "<GROUP>" '  name=""" & NameForAnim & """>"
            IncIndent
        End If
        For i = 1 To TextItemNum
            With TextItems(i)
                If g_shapeIsInTemplate Then
                    rStr = ReplaceAutoTextField(.text)
                    If rStr <> .text Then
                        .width = 0
                    End If
                Else
                    rStr = .text
                End If
                .length = Len(rStr)

                If .length > 0 Then
                    ' add text shadow
                    strScript = strScript & NewLine() _
                            & "<TEXT x=""" & ConvertDoubleToString(.x + ShadowOffX) _
                            & """ y=""" & ConvertDoubleToString(y + .offY + ShadowOffY) _
                            & """ width=""" & ConvertDoubleToString(.width) _
                            & """ color=""" & ShadowColor _
                            & """ size=""" & .FontSize _
                            & """ family=""" & .Family _
                            & """ weight=""" & .Weight _
                            & """ slant=""" & .Slant _
                            & """ style=""" & .Style _
                            & """ position=""" & .Position _
                            & """ length=""" & Len(rStr) _
                            & """ ZPosition=""" & ZPosition _
                            & """ linkcolor=""" & .LinkColor _
                            & """>" _
                            & NewLine() & "  """ & rStr & """" _
                            & NewLine() & "</TEXT>"
                End If
            End With
        Next
        If Not g_conversionOptions.NoGroup And TextItemNum > 1 Then
            DecIndent
            strScript = strScript & NewLine() & "</GROUP>"
        End If
'        DecIndent
    End If
    ScriptTextShadow = strScript
End Function

Private Function MakeArrowString(ByVal szArrowStyle As String, ByVal szArrowConfig As String) As String

    Dim tmpString As String
    
    tmpString = ""
    If (arrowStyle <> "none") Then
        tmpString = """ arrowStyle=""" & szArrowStyle _
                  & """ arrowConfig=""" & szArrowConfig
    End If
    
    MakeArrowString = tmpString
End Function



'
' End
'
